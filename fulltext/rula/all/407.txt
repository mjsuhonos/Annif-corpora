A Logic For Decidable Reasoning About Actions 
Yilan Gu Department of Computer Science, University of Toronto, 10 King's College Road, Toronto, ON, M5S 3G4, Canada yilan@cs.toronto.edu Mikhail Soutchanski Department of Computer Science, Ryerson University, 245 Church Street, ENG281, Toronto, ON, M5B 2K3, Canada Tel.: +1-416-9795000, ext 7954 Fax: +1-416- 979-5064 mes@scs.ryerson.ca

October 6, 2008

Abstract We consider a modified version of the situation calculus built using a two-variable fragment of the first-order logic extended with counting quantifiers. We mention several additional groups of axioms that can be introduced to capture taxonomic reasoning. We show that the regression operator in this framework can be defined similarly to regression in Reiter's version of the situation calculus. Using this new regression operator, we show that the projection and executability problems (the important reasoning tasks in the situation calculus) are decidable in the modified version even if an initial knowledge base is incomplete. We also discuss the complexity of solving the projection problem in this modified language in general. Furthermore, we define description logic based sub-languages of our modified situation calculus. They are based on the description logics ALCO(U ) (or ALCQO(U ), respectively). We show that in these sub-languages solving the projection problem has better computational complexity than in the general modified situation calculus. We mention possible applications to formalization of Semantic Web services and some connections with reasoning about actions based on description logics.

This research has been partially supported by the Natural Sciences and Engineering Research Council of Canada (NSERC) and by the Ryerson University.  A corresponding author.



1

Contents
1 Introduction 2 The Situation Calculus 3 Description Logics and Two-Variable First-order Logics 3.1 Description Logics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.2 C 2 and Its Relationship to Description Logics . . . . . . . . . . . . . . . . . . . . . . . . 4 Modeling Dynamical Systems in a Modified Situation Calculus 5 Reasoning about Actions using Regression 5.1 Modified Regression with Lazy Unfolding . . . . . . . . . . . . . . . . . . . . . . . . . . 5.2 Some Computational Complexity Results . . . . . . . . . . . . . . . . . . . . . . . . . . 5.3 A Description-Logic Based Situation Calculus . . . . . . . . . . . . . . . . . . . . . . . . 6 An Example of Regression in LC sc 7 Discussion and Future Work A Semantics of Description Logics B Proofs of Lemmas and Theorems B.1 ALCQIO (, , ¬, |, id) and C 2 are Equally Expressive . . . . . B.2 The Correctness of the Modified Regression Operator . . . . . B.3 ALCO (U ) and F ODL are Equally Expressive . . . . . . . . . . B.4 Restricting Syntax of BATs to Gain Computational Advantages
2

3 4 7 7 8 10 12 12 17 19 23 26 29 30 30 34 36 37

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

2

"All is change; all yields its place and goes." - Euripides (c. 485-406 BCE) "Nothing is permanent but change." - Heraclitus (c. 540 -c. 480 BCE)

1 Introduction
The situation calculus (SC) is a well known and popular logical theory for reasoning about changes caused by events and actions. There are several different formulations of SC. According to John McCarthy the history is the following: "[50] proposed mathematical logic as a tool for representing facts about the consequences of actions and using logical reasoning to plan sequences of actions that would achieve goals. Situation calculus as a formalism was proposed in [51] and elaborated in [55]. The name situation calculus was first used in [55] but wasn't defined there. [52] proposed to solve the frame and qualification problems by circumscription, but the proposed solution to the frame problem was incorrect. [76] and [70] describe several situation calculus formalisms and give references" (see the footnote 4 in [54]). In this paper we would like to consider the SC from [70] that extends the original SC with time, concurrency, stochastic actions, etc. It serves as a foundation for the Process Specification Language (PSL) that axiomatizes a set of primitives adequate for describing the fundamental concepts of manufacturing processes (PSL has been accepted as an international standard) [31, 30]. It is used to provide a well-defined semantics for Web services and a foundation for a high-level programming language Golog [41, 56, 61, 7]. However, because the situation calculus is formulated in a general predicate logic, reasoning about effects of sequences of actions is undecidable (unless some restrictions are imposed on the theory that axiomatizes the initial state of the world). The first motivation for our paper intends to overcome this difficulty. We propose to use a two-variable fragment FO2 of the first-order logic (FOL) as a foundation for an initial theory in a modified situation calculus. Because the satisfiability problem in this fragment is known to be decidable (it is in NE XP T IME ) [28, 64], we demonstrate that by reducing reasoning about effects of actions to reasoning in this fragment, one can always guarantee decidability no matter what is the syntactic form of the theory representing the initial state of the world. Note an important caveat. We are not going to design a decidable logic for reasoning about actions (see work in this direction reviewed in Section 7) by imposing strong restrictions on the language such as allowing only action constants and disallowing more complex action terms. Instead, we consider a fragment of the SC where only particular reasoning problems become decidable, but these problems are exactly those that can be important in applications. Consequently, it should not be a surprise for the readers to see that even if an initial theory is an FO2 theory, that is formulated using object variables x and y , we include additional variables (a, for actions, and s, for situations), action terms and situation terms common in the SC. As we show in this paper, the reasoning problems that we care about can still be reduced to the theorem proving task in FO2 (or in fragments of FO2 ). The second motivation for our paper comes from description logics. Description Logics (DLs) [4] are a well-known family of knowledge representation formalisms, which play an important role in providing the formal foundations of several widely used Web ontology languages including the Web Ontology Language (OWL) [36] in the area of the Semantic Web. Many expressive DLs can be translated to FO2 (or to C 2 that is FO2 extended with counting quantifiers [65, 68]) and offer considerable expressive power going far beyond propositional logic, while ensuring that reasoning is decidable [9]. DLs have been mostly used to describe static knowledge bases. However, several research groups consider formalization of actions using DLs or extensions of DLs. Following the key observation that reasoning about complex actions 3

can be carried out in a fragment of the propositional situation calculus, in [25], an epistemic extension of DLs was given to provide a framework for the representation of dynamical systems. However, the representation and reasoning about actions in this framework are strictly propositional, which reduces the representation power of this framework. In [2], another proposal was proposed for integrating description logics and action formalisms. They take the well-known description logic ALCQIO (and its sub-languages) as foundation and show that the complexity of executability and projection problems (two basic reasoning problems for possibly sequentially composed actions) coincides with the complexity of standard DL reasoning. However, actions (services) are represented in their paper meta-theoretically, not as first-order (FO) terms. This can potentially lead to some complications when specifications of other reasoning tasks are considered because it is not possible to quantify over actions in their framework. Other related work is reviewed in Section 7. In our paper, we take a different approach and represent actions as FO terms, but achieve integration of taxonomic reasoning and reasoning about actions by restricting the syntax of the situation calculus and by introducing additional axioms to represent a taxonomy. The main contribution of our paper to the area of service composition and discovery is the following. We show that by using services that are composed from atomic services with no more than two parameters and by using only those properties of the world which have no more than two parameters (to express a goal condition), one can guarantee that the executability and projection problems for these services can always be solved even if information about the current state of the world is incomplete. Our paper is structured as follows. In Section 2, we briefly review Reiter's situation calculus. In Section 3 we review description logics and the extension of FO2 with counting quantifiers. In Section 4, 2 we discuss details of our proposal: the language LC sc of our modified SC . In Section 5.1, we consider an extension of regression (the main reasoning mechanism in the situation calculus) and investigate the computational complexity in Section 5.2. In Section 5.3, we consider a fragment of FO2 that corresponds to a DL with better complexity properties than FO2 . Then we define a new SC based on this fragment, 2 which can be considered as a sub-language of LC sc . In Section 6, we consider an example that illustrates potential applications to Semantic Web Services. Finally, in Section 7, we discuss briefly other related approaches to reasoning about actions.

2 The Situation Calculus
The situation calculus (SC) Lsc is a predicate language for axiomatizing dynamical systems. All dialects of the SC Lsc include three disjoint sorts: action, situation and object. Actions are FO terms consisting of an action function symbol and its arguments. Actions change the world. Situations are FO terms which denote world histories. A distinguished constant S0 is used to denote the initial situation, and function do(a, s) denotes the situation that results from performing action a in situation s. Every situation corresponds uniquely to a sequence of actions. Moreover, notation s s means that either situation s is a subsequence of situation s or s = s .1 Objects are FO terms other than actions and situations that depend on the domain of application. We assume that distinct individual names denote distinct objects, i.e., we have the unique name axioms for object constants. Fluents are relations or functions whose values may vary from one situation to the next. Normally, a fluent is denoted by a predicate or function symbol whose last argument has the sort situation. For example, F (x, do([1 , · · · , n ], S0 )) represents a
Reiter [70] uses the notation s  s, but we use s s to avoid confusion with the inclusion relation < that is commonly used in description logic literature. In this paper, we use < to denote the inclusion relation between concepts or roles.
1

4

relational fluent in the situation do(n , do(· · · , do(1 , S0 ) · · · )) resulting from execution of ground action terms 1 , · · · , n in S0 . We do not consider functional fluents in this paper. The SC includes the distinguished predicate P oss(a, s) to characterize actions a that are possible to execute in s. For any SC formula W and a term s of sort situation, we say W is a formula uniform in s iff it does not mention the predicates P oss, it does not quantify over variables of sort situation, it does not mention equality on situations, and whenever it mentions a term of sort situation in the situation argument position of a fluent, then that term is s (see [70]). We also introduce a notation [s] to represent the SC formula obtained by restoring situation s back to all the fluents and/or P oss predicates (if any) in . It is obvious that [s] is uniform in s. A basic action theory (BAT) D in the SC is a set of axioms written in Lsc with the following five classes of axioms to model actions and their effects [70]: action precondition axioms Dap , successor state axioms (SSAs) Dss , initial theory DS0 , unique name axioms for actions Duna , domain independent foundational axioms for situations . Action precondition axioms Dap : For each action function A(x), there is an axiom of the form P oss(A(x), s)  A (x, s), where A (x, s) is a formula uniform in s with free variables among x and s at most, characterizing the preconditions of action A. Successor state axioms Dss : For each relational fluent F (x, s), there is an axiom of the form F (x, do(a, s))  F (x, a, s), (1)

where F (x, a, s) is a formula uniform in s with free variables among x, a and s at most. It completely characterizes the value of F in the next situation do(a, s) in terms of what holds in the current situation s. In fact, the general syntactic form of F (x, a, s) is
+ - F (x, a, s) = F (x, a, s)  F (x, s) ¬F (x, a, s), + - where F (x, a, s) (F (x, a, s), respectively) is a formula uniform in s with free variables among x, a and s at most that completely describes the positive (negative, respectively) effects of actions on fluent F . Here and subsequently, we say that an action  has a positive effect on fluent F , if F becomes true in the situation resulting from executing this action. Similarly,  has a negative effect, if F becomes false. By using (a) in Eq. (1), Reiter solves the frame problem succinctly because all action functions not explicitly mentioned in F (x, a, s) have neither positive, nor negative effects on F . For all of them, the value of F in do(a, s) remains the same as it was in s. Recall that actions in Eq. (1) that cause positive or negative effects can be arbitrary FO terms, not just action constants. In [70], Section 3.2.4 and Section 3.2.5, Reiter provides a systematic way of automatically generating SSAs from effect axioms based on the causal completeness assumption and unique name axioms for actions. There, Reiter shows a precise way + - + - of constructing the normal form of F (x, a, s) (F (x, a, s), respectively). That is, F (x, a, s) (F (x, a, s), (i) (i) h respectively) can be represented as i=1 F for some finite index h  0, where each F is a formula of the syntactic form

[y ](a = A(t )   (x, y, s))

(2)

for some action term A(t ) and some FOL formula  (x, y, s). Note that y are those new variables which do not occur in F (x, do(a, s)), if there are any. If y is empty, then there is no quantifier [y ] at front. Here, t is a vector of object terms with free variables (at most) among x and the quantified new variables y if there are any, (x, y, s) is uniform in s and its free variables are (at most) among x and y , if there are any. 5

In other words, the SSA of fluent F (Eq. (1)) has the following syntactic form (integers m+ , m-  0):
m+

F (x, do(a, s)) 

[yi ](a = P osActi (ti )  + i (x, yi , s)) 
i=1 m-

F (x, s) ¬(

[zj ](a = NegActj (t j )  - j (x, zj , s))),
j =1

(3)

where for i = 1..m+ (j = 1..m- , respectively), each ti (t j , respectively) is a vector of terms with free variables (at most) among x and the quantified new variables yi (zj , respectively) if there are any, each con- text condition + i (x, yi , s) (j (x, zj , s), respectively) is an SC formula uniform in s that has free variables (at most) among x and yi (zj , respectively) if there are any, and each P osAct(ti ) (NegAct(t j ), respectively) is an action term that makes F (x, do(a, s)) true (false, respectively) if the condition + i (x, yi , s) (- ( x, z , s ) , respectively) is satisfied. j j Initial theory DS0 : A set of FO formulas whose only situation term is S0 . It specifies the values of all fluents in the initial state. It also describes all the facts that are not changeable by any actions in the domain (static sentences). In particular, it includes unique name axioms for object constants. Unique name axioms for actions Duna : Includes axioms specifying that two actions are different if their names are different, and identical actions have identical arguments.2 Foundational axioms for situations : The axioms for situations which characterize the basic properties of situations. These axioms are domain independent. They are included in the axiomatization of any dynamical system in the SC (see [70] for details). Suppose that D = Duna  DS0  Dap  Dss   is a BAT, 1 , · · · , n is a sequence of ground action terms, and G(s) is a uniform formula with one free variable s. One of the most important reasoning tasks in the SC is the projection problem, that is, to determine whether D |= G(do([1 , · · · , n ], S0 )). Another basic reasoning task is the executability problem. Let executable(do([1 , · · · , n ], S0 )) be an abbreviation of the formula P oss(1 , S0 )  n i=2 P oss(i , do([1 , · · · , i-1 ], S0 )). Then, the executability problem is to determine whether D |= executable(do([1 , · · · , n ], S0 )). Planning and high-level program execution are two important settings where the executability and projection problems arise naturally. Regression is a central computational mechanism that forms the basis for automated solution to the executability and projection tasks in the SC ([70]). A recursive definition of the regression operator R on any regressable formula W is given in [70]. A formula W of Lsc is regressable iff (1) every term of sort situation in W is starting from S0 and has the syntactic form do([1 , · · · , n ], S0 ), where each i is of sort action; (2) for every atom of the form P oss(,  ) in W ,  has the syntactic form A(t1 , · · · , tn ) for some n-ary function symbol A of Lsc ; and (3) W does not quantify over situations, and does not mention the relation symbols "" or "=" between terms of situation sort. For a regressable formula W , we use notation R[W ] to denote the regressed formula that results from eliminating P oss atoms in favor of their definitions as given by action precondition axioms, and replacing fluent atoms about do(, s) by logically equivalent expressions about s as given by SSAs repeatedly, until no more such replacement can be made. The formula G(do([1 , · · · , n ], S0 )) is a particularly simple example of a regressable formula because it is uniform in do([1 , · · · , n ], S0 )), but generally, regressable formulas can mention several different situation terms. Roughly speaking, the regression of a regressable formula W through an action a is a formula W  that
2

For the second type of axioms, we use the form A(x1 , · · · , xn ) = A(y1 , · · · , yn )  x1 = y1 · · · xn = yn .

6

holds prior to a being performed iff W holds after a. Both precondition axioms and SSAs support regression in a natural way and are no longer needed when regression terminates. This is because each step of regression either eliminates a P oss atom by replacing it with an equivalent formula, or replaces a fluent with a compound situation term by a logically equivalent formula with a situation term that has one less occurrence of an action term. The regression theorem proved in [66] shows that one can reduce the evaluation of a regressable sentence W to an FOL theorem proving task in the initial theory together with unique names axioms for actions: D |= W iff DS0  Duna |= R[W ]. This fact is the key result for our paper: it demonstrates that an executability or a projection task can be reduced to an FOL theorem proving task. However, because DS0 is an arbitrary FO theory, this type of reasoning is undecidable. Two of the most common ways to overcome this difficulty are to introduce the closed world assumption or introduce the domain closure assumption (i.e., assume the domain is finite). In many practical application domains these assumptions are unrealistic. Therefore, we propose a version of the SC with DS0 based on C 2 , or on a weaker fragment of FO2 . Fragments of FO2 that are syntactic versions of DLs are particularly interesting because for them the satisfiability problem is more tractable than for a general FO2 . For this reason, in the next section, we review definitions and results relevant to DLs, FO2 and C 2 .

3 Description Logics and Two-Variable First-order Logics
In this section we review a few popular expressive description logics [4] and related fragments of FOL [9].

3.1 Description Logics
We start with the language of logic ALCQIO . Let NC = {AC1 , AC2 , . . .} be a non-empty set of atomic concepts and NR = {R1 , R2 , . . .} be a non-empty set of atomic roles. In ALCQIO , nominals are allowed. Nominals are singleton concepts obtained by picking one of the object names. An ALCQIO role is either some R  NR or an inverse role R- for R  NR . In addition, (R- )- is R itself. The set of ALCQIO concepts is the minimal set built inductively from NC and ALCQIO roles using the following rules: all AC  NC are concepts, nominals are concepts, and, if C , C1 , and C2 are ALCQIO concepts, R is a role and n  N, then ¬C , C1  C2 , and nR.C are also ALCQIO concepts. Concepts that are not atomic are called complex. A literal concept is a possibly negated concept name. The abbreviations for complex concepts such as C1  C2 , C1  C2 , nR.C ,  R. C ,  R. C (and other complex concepts) can be easily defined. For example, def def C1  C2 = ¬(¬C1  ¬C2 ) nR.C = ¬( (n + 1)R.C ) C1  C2 = ¬C1  C2 R.C =
def def

=n R. C = ( nR.C )  ( nR.C )  = AC  ¬AC for some AC  NC  = AC  ¬AC for some AC  NC
def def

def

1R.C

R.C = ¬R.¬C

def

The semantics of description terms is given denotationally, using the notion of an interpretation I = I , (·)I , where I is a domain (non-empty universe) of objects, and (·)I maps from atomic concept names to subsets of the domain (i.e., AC I  I for all AC  NC ), and atomic role names to sets of 7

pairs over the domain (i.e., RI  I × I for all R  NR ). Moreover, the interpretation function (·)I is extended recursively to composite descriptions in Table 1 (see Appendix A). We assume that the interpretation of nominals has to respect the unique name assumption. A TBox T is a finite set of equality axioms C1  C2 .3 An equality with an atomic concept on the lefthand side (LHS) is a concept definition. In the sequel, we always consider TBox axioms set T that is a terminology: a finite set of concept definition formulas with unique left-hand sides, i.e., no atomic concept occurs more than once as a left-hand side. We say that a defined concept name C1 directly uses a concept name C2 wrt T if C1 is defined by a concept definition axiom in T with C2 occurring on the right-hand side (RHS) of the axiom. Let uses be the transitive closure of directly uses, and a TBox axioms set T is acyclic if no concept name uses itself wrt T . An ABox A is a finite set of assertions of the forms C (b) and R(b, b1 ), where b and b1 are some object names, C is a concept, and R is a role. An RBox HR , called a role hierarchy, is a finite set of role inclusion axioms of the form R1  R2 , where R1 (R2 , respectively) is either an atomic role or its inverse. A DL knowledge base KB in DL is a tuple (T , A) (or, a triple (HR , T , A) if role inclusion axioms are allowed). The semantics of terminological and assertional axioms are provided in Table 3 (see Appendix A). The logic ALCQI is obtained by disallowing nominals in ALCQIO . The logic ALCQO is obtained by disallowing inverse roles in ALCQIO . The logic ALCQO (U ) is obtained by adding the universal role U to ALCQO . The semantics of U is given in Table 2 (see Appendix A). The logic ALCQIO (, , ¬, |, id) is obtained from ALCQIO by introducing concept identity id(C ) (relating each individual in C with itself), and allowing complex role expressions: if R1 , R2 are ALCQIO (, , ¬, |, id) roles and C is a concept, then - R1 R2 , R1 R2 , ¬R1 , R1 and R1 |C are ALCQIO (, , ¬, |, id) roles too. These complex roles can be used in constructing complex concepts. The semantics of complex roles are given in Table 2 (see Appendix A). Subsequently, we call a role R primitive if it is either R  NR or it is an inverse role R- for R  NR . The logic ALCHQIO (, , ¬, |, id) allows RBox axioms based on the language of ALCQIO (, , ¬, |, id). Moreover, notice that the universal role can be implicitly constructed in ALCQIO (, , ¬, |, id): U can be replaced using R  ¬R for any R  NR . There are different reasoning tasks in DLs, such as the concept satisfiability problem and the ABox consistency problem, etc. The concept satisfiability problem is to decide given a TBox T and a concept C , whether there exists a model I of T such that C I is nonempty. Given any DL KB (T , A), the ABox consistency problem is to check whether there is a interpretation that is a model for both T and A. The complexity of solving the concept satisfiability problem or the ABox consistency problem has been studied for different versions of DLs [85]. For example, it has been shown that the complexity of solving these two problems is PS PACE-complete in ALC , in ALCO and in ALCQO [75, 81, 3], but is E XP T IME-complete in ALCQIO [80, 81]. However, it is also known that the complexity for these two problems is E XP T IME-complete in ALC (U ) (i.e., ALC plus the universal rule) [78, 34, 48] and in SHOQ [35]. Because one can implicitly represent the universal role in SHOQ, it is also known that the complexity of solving these two problems is still E XP T IME-complete in ALCO(U ) or in ALCQO (U ).

3.2 C 2 and Its Relationship to Description Logics
The two-variable FOL FO2 is a well-known fragment of ordinary FOL, whose formulas can be built with the help of predicate symbols (including equality) and constant symbols (but without general function symbols) using no more than two variable symbols x and y (free or bound). Note that each variable
3

Sometimes, general inclusion axioms of the form C1  C2 are also allowed, where C1 , C2 are complex concepts.

8

can be reused arbitrarily often. The two-variable FOL with counting C 2 extends FO2 by allowing FO counting quantifiers m and m for all m  1 [28, 64, 65, 38, 68]. Because the semantics of FO2 (C 2 , respectively) are the same as the semantics of FOL, the details are omitted here. It is well-known that modal logic is a "big brother" of DLs. In particular, it is proved that the DL ALC is a notational variant of a basic multi-modal logic K [72]. For this reason, it is important to note that the standard translation from a basic modal logic to FOL is proposed in [5]. Later, it was realized that a basic modal logic can be translated to FO2 [20, 6]. The standard translation and other results in modal logic are extensively discussed in [8] and in [63]. Now we consider some relationships between C 2 and DLs. In [9], an expressive description logic B is defined4 , and it is shown that C 2 and the language B are equally expressive, that is, C 2 is as expressive as B and vice versa. Generally speaking, a language L2 is as expressive as language L1 , if there is a translation function transl from L1 to L2 such that for every sentence l in L1 , transl(l) expresses the meaning of l [9]. Moreover, in [9], the translation in both directions between C 2 and B leads to no more than a linear increase in the size of the translated formula. His translation is similar to the standard translation earlier proposed for modal logics. Using the same approach as in [9], we prove the following theorem (the detailed proof is provided in Appendix B.1). Theorem 1 The description logic ALCQIO (, , ¬, |, id) and C 2 are equally expressive (i.e., each sentence in language ALCQIO (, , ¬, |, id) can be translated to a sentence in C 2 , and vice versa). In addition, translation in both directions leads to no more than a linear increase in the size of the translated formula. Notice that ALCHQIO (, , ¬, |, id) includes RBox in the knowledge bases, in contrast to ALCQI (, , ¬, id) that has no RBox . However, it is obvious that every axiom in RBox still can be translated into a sentence in C 2 . Hence, the language of ALCHQIO (, , ¬, |, id) and C 2 are also equally expressive. In [49], another DL is considered5 and alternative translation between that DL and FO2 is proposed. It is proved that translation from FO2 -formulae into concepts in the considered DL involves an exponential blow-up in formula size. This statement has an important consequence. Gradel et. al. [29] and Pacholski et. al. [64] show that the satisfiability problem for C 2 is decidable and recently in [68] it is proved that this problem is in NE XP T IME even when counting quantifiers are coded succinctly. Hence, the satisfiability and/or subsumption problems of concepts w.r.t. an acyclic or empty TBox in description logic ALCQIO (, , ¬, |, id) (ALCHQIO (, , ¬, |, id), respectively) is also decidable with the same computational complexity.6 See additional background on DLs and discussion of connections between DLs with C 2 in [4, 9].
In [9], the language B is denoted as DL - {trans, compose}, in which trans represents the role constructor reflexivetransitive closure and compose represents the role constructor composition. We change it to notation B in order to avoid confusion. Besides, the syntax and semantics of reflexive-transitive closure and composition can be found in Table 2, Appendix A. 5 ALC extended with full Boolean operators on roles, the inverse operator on roles and an identity role. 6 In [4], it is shown that the satisfiability problem and the subsumption problem can be reduced to each other; moreover, if a TBox T is acyclic, the reasoning problems w.r.t. T can always be reduced to problems w.r.t. the empty TBox.
4

9

4 Modeling Dynamical Systems in a Modified Situation Calculus
In this section, we consider dynamical systems formulated in a modification of the language of the SC so that it can be considered as an extension to C 2 (with an additional situation argument).7 The key idea is to consider a syntactic modification of the SC such that the executability and projection problems are guaranteed to be decidable as a consequence of the decidability of the satisfiability problem in C 2 . We 2 will denote this language LC sc . 2 Firstly, the three sorts in LC sc (i.e., actions, situations and objects) are the same as those in Lsc , except that they obey the following restrictions: (1) all terms of sort object are variables (x and y ) or constants, i.e., object functional symbols are not allowed; (2) all action functions include no more than two arguments. Each argument of any term of sort action is either a constant or an object variable (x or y ); (3) variable s of sort situation and/or variable a of sort action are the only additional variables allowed in D in addition to variables x, y . 2 Secondly, any fluent in LC sc is a predicate with either two or three arguments (including the one of sort situation). We call fluents with two arguments dynamic concepts, and call fluents with three arguments 2 dynamic roles. Intuitively, each dynamic concept in LC sc , say F (x, s) with variables x and s only, can be 2 considered as a changeable concept F in a dynamical system specified in LC sc ; the truth value of F (x, s) 2 could vary from one situation to another. Similarly, each dynamic role in LC sc , say F (x, y, s) with variables 2 x, y and s, can be considered as a changeable role R in a dynamical system specified in LC sc ; the truth value 2 of F (x, y, s) could vary from one situation to another. In LC sc , (static) concepts (i.e., monadic predicates with no situation argument) and (static) roles (i.e., dyadic predicates with no situation argument), if any, are considered as unchangeable taxonomic properties and unchangeable classes of an application domain. Moreover, each concept (static or dynamic) can be either primitive or defined. For each primitive dynamic concept, an SSA must be provided in the basic action theory for a given domain. Because defined dynamic concepts are expressed in terms of primitive concepts by axioms in an acyclic TBox, SSAs for them are not provided. In addition, SSAs are provided for dynamic roles. Thirdly, apart from the standard FO logical symbols  ,  and , with the usual definition of a full 2 m set of connectives and quantifiers, LC and m for all m  1. sc also includes counting quantifiers  2 Equality = is allowed in LC sc too. The dynamical systems we are dealing with here satisfy the open world assumption (OWA): what is not stated explicitly in an initial theory DS0 is unknown rather than false. In this paper, the dynamical systems we are interested in can be formalized as a basic action theory (BAT) D using the following seven groups 2 of axioms in LC sc : D =   Dap  Dss  DT  DR  Duna  DS0 . Five of them (, Dap , Dss , Duna , DS0 ) are similar to those groups in a BAT in Lsc , and the other two (DT , DR ) are introduced to axiomatize 2 description logic related facts and properties (see below). However, because LC sc allows only one or two object variables, all axioms must conform to the following additional requirements.8 Action precondition axioms Dap : For each action A in LC sc , there is one axiom of the form P oss(A, s)  A [s] (or P oss(A(x), s)  A (x)[s], or P oss(A(x, y ), s)  A (x, y )[s], respectively), if A is an action constant (or unary, or binary action term, respectively), where A (or A (x), or A (x, y ), respectively) is a C 2 formula with no free variables (or with at most x, or with at most x, y as the only free variables,
The reason that we call it a "modified" SC rather than a "restricted" SC is that we extend the SC with other features, such as adding acyclic TBox axioms to BATs. 8 Subsequently, we write axioms with action and situation variables, and use action and situation terms. However, we will see that they can be eliminated when we solve the projection problem.
7
2

10

respectively). This set of axioms characterizes the preconditions of all actions. Successor state axioms Dss : Let variable vector x be x, or y , or x, y . An SSA is specified for each primitive dynamic concept that is not defined in TBox (see below) and each dynamic role F (x, do(a, s)). According to the detailed syntactic form of the SSAs Eq. (3), without loss of generality, we can assume that the axiom has the form
m+

F (x, do(a, s)) 

+ [x][y ](a = P osActi (t(i,+) )  i (x(i,+) )[s])  i=1 m-

F (x, s) ¬(

- [x][y ](a = NegActj (t(j,-) )  j (x(j,-) )[s])). j =1

(4)

Here, each vector t(i,+) , i = 1..m+ , (t(j,-) , j = 1..m- , respectively) represents a vector of object terms appearing in the corresponding action term, which can be either empty, O , O1, O2 , x, x, x , O, x , x, O , y , y, y , O, y , y, O x, y or y, x for free variables x, y and some object constants O , O1 , O2 . Each variable vector x(i,+) (or x(j,-) , respectively), i = 1..m+ , j = 1..m- , represents a vector of free variables appearing in the corresponding context condition, which can be either empty, x, y , x, y or + y, x . Moreover, [x] or [y ] represents that the quantifier included in [ ] is optional; and each i (x(i,+) ), - 2 i = 1..m+ , (i (x(j,-) ), j = 1..m- , respectively), is a C formula with variables (both free and bound) among x and y at most. Note that when m+ (or m- , respectively) is equal to 0, the corresponding disjunctive sub-formula is equivalent to f alse. Acyclic TBox axioms DT : Similar to the TBox axioms in DL, we may define new concepts using TBox axioms. Any group of TBox axioms DT may include two sub-classes: static TBox DT,st and dynamic TBox DT,dyn . Every formula in static TBox is a concept definition formula of the form G(x)  G (x), (5) where G is a monadic predicate symbol and G (x) is a C 2 formula with a free variable x, and there is no fluent in it. Every formula in dynamic TBox is a concept definition formula of the form G(x, s)  G (x)[s], where G (x) is a C 2 formula with free variable x, and there is at least one fluent in it. All the concepts appeared on the LHS of TBox axioms are called defined concepts. We also require that the set of TBox axioms must be acyclic (acyclicity in DT is defined exactly as it is defined for TBox ). Note that the defined dynamic concepts are not provided with SSAs. There is no need to provide an SSA for a defined concept because regression can expand TBox definitions instead of an SSA. RBox axioms DR : Similar to the idea of RBox in DL, we may also specify a group of axioms, called RBox axioms below, to support a role taxonomy. Each role inclusion axiom is represented as R1 (x, y )[s]  R2 (x, y )[s], where R1 and R2 are primitive roles (either static or dynamic). If these axioms are included in the BAT D , then it is assumed that D is specified correctly in the sense that the meaning of any RBox axiom included in the theory is correctly compiled into SSAs. This means that an axiomatizer is responsible for writing Dss such that axioms from RBox become logical consequences. That is, it should be provable by induction that (D - DR ) |= s.R1 (x, y )[s]  R2 (x, y )[s]. This is the common approach to state constraints, e.g., it was taken in [70]. In some special (but realistic) cases, RBox axioms can be automatically compiled into Dss . Let us say R2 (x, y, s) directly depends on R1 (x, y, s), if R1 (x, y, s)  R2 (x, y, s) belongs to RBox, and say R3 (x, y, s) depends on R1 (x, y, s), if R3 (x, y, s) directly depends on R2 (x, y, s), and R2 (x, y, s) 11

depends on R1 (x, y, s). Then, we can say that RBox is acyclic, if there is no dynamic role R(x, y, s) that depends on itself. In [57], it is proved that acyclic state constraints can be automatically compiled into SSAs. Because acyclic RBox is just a special case of state constraints considered in McIlraith's paper, her approach is applicable to acyclic TBox as well. Additional details related to state constraints in the SC can be found in [43, 42]. Although RBox axioms are not used by the regression operator, they are used for taxonomic reasoning in the initial theory. Initial theory DS0 : It is a finite or countably infinite set of C 2 sentences (assuming that we suppress the only situation term S0 in all fluents). It specifies the incomplete information about the initial problem state and also describes all the facts that are not changeable over time in the domain of an application. In particular, it includes static TBox axioms DT,st as well as RBox axioms in the initial situation S0 (if any). In addition, DS0 also includes all unique name axioms for object constants. Note that this definition of DS0 includes ABox as a special case. In the sequel, DS0 is assumed to be finite, unless stated otherwise. The remaining two classes (foundational axioms for situations  and unique name axioms for actions Duna ) are the same as those in the BATs of the usual SC. Note that these axioms (as well as Dap and Dss ) use more than two variables (e.g., Dss use action and situation variables in addition to object variables), but we will see in the next section, that these axioms will be eliminated in the process of regressing a regressable sentence to a sentence that will use no more than two object variables and no other variables.

5 Reasoning about Actions using Regression
After giving the definition of what is a BAT in LC sc , we turn our attention to the reasoning tasks. We 2 want to identify reasoning problems that are decidable in LC sc . To achieve such goal, for certain type of 2 2 formulas in LC sc , we expect the regressed formulas are C formulas.
2

5.1 Modified Regression with Lazy Unfolding
C Given a formula W of LC sc in the domain D , the definition of W being regressable (called Lsc regressable below) is slightly different from the definition of W being regressable in Lsc (see [70]). C Definition 1 A formula W of LC sc is Lsc regressable iff (1) Each term of sort situation in W is ground.
2 2 2 2

(2) Other than the action terms occurred in the predicate P oss, there are no function terms in W . Moreover, variables x and y (free or bound) are the only variables used in W , if any. (3) For every atom of the form P oss(,  ) in W ,  has the syntactic form A(t1 ,· · ·, tn ) for some n-ary 2 function symbol A of LC sc , where n  2. Moreover, each ti is either variable x, variable y or some constant O if there is any. (4) Each term of sort situation in W is starting from S0 and has the syntactic form do([1 , · · · , n ], S0 ), where each i is of sort action. (5) W does not quantify over situations. (6) W does not mention the relation symbols "" or "=" between terms of sort situation.

12

The requirements in conditions (2) and (3) are obvious, because our language is restricted to LC sc . The intuition for adding condition (1) is as follows. Consider the following counter example. Example 1 Assume D is a BAT of LC sc , which includes an SSA F (x, do(a, s))  a = A(x)  (y.G(x, y, s))  F (x, s) for some fluents F (x, s), G(x, y, s) and action function A(x). Consider a formula x.y.F (x, do(A(O ), do(A1(y ), S0))) (denoted as W0 below) of To perform a correct regression on W0 in the sense that the formula resulting from regression should be logically equivalent to W0 w.r.t. D , we have to rename the quantified variable y in Eq. (6) so that it is different from any variables appearing in W0 . That is, the one step regression on F using Eq. (6) should be x.y.R[A(O ) = A(x) z.G(x, z, do(A1 (y ), S0))  F (x, do(A1 (y ), S0))]. Then, the regressed formula is no longer a formula of language LC sc . Otherwise, if we do not rename the 2 quantified variable y in Eq. (6) to assure the regressed formula is still of language LC sc , then the one step regression on F using Eq. (6) without renaming will result in the following formula: x.y.R[A(O ) = A(x) y.G(x, y, do(A1(y ), S0))  F (x, do(A1(y ), S0))]. It is obvious that the above regressed formula is not logically equivalent to W0 , because the variable y that occurs in the situation term A1 (y ) should not be quantified by y at the front of G. Hence, to avoid the problem described in Example 1, we add (1) to Def. 1. Below, with a carefully de2 fined regression operator, we are able to show that for every LC sc regressable formula, there is an equivalent regressed C 2 formula uniform in S0 . 2 In the language of LC sc , we have to be more careful with the definition of the regression operator R for 2 two main reasons. First, to deal with TBox we have to extend regression. For an LC sc regressable formula W , we extend the regression operator defined in [70] with the lazy unfolding technique (see [4]) to expand 2 defined dynamic concepts. Second, LC sc uses only two object variables and we have to make sure that 2 after regressing a fluent atom we still get an LC sc formula, i.e., that we never need to introduce new (free or bound) object variables. To deal with the two-variable restriction, we modify our regression operator in comparison to the conventional operator defined in [70], and still denote this operator as R. The key idea is to reuse variables when doing replacement. For example, when replacing P oss atoms or fluent atoms about do(,  ), the definition of the conventional regression operator in [70] has the assumption that the quantified variables on the RHS of the corresponding axioms should be renamed to new variables different from the free variables in the atoms to be replaced. This assumption of using new variables for renaming assures logical equivalence of the original formula and the formula after regression. But in C 2 new variables cannot be used. To avoid introducing new variables (as required by Reiter's regression operator) and to assure defined dynamic concepts being handled, we modify the regression operator for 2 each LC sc regressable formula. The possibility of reusing variables is guaranteed by the general format of the SSAs given in the previous section and the additional conditions (1-3) in Def. 1. The complete formal definition of our R is as follows,9 where  denotes the term of sort situation, and  denotes the term of sort action. Note that below, if (x) represents a formula  with free variables among a variable vector x at most, then for any vector of terms t such that |t| = |x|, (t ) represents the
9
2 2

2

(6)

C2 Lsc .

It is also called LC sc regression sometimes below to avoid confusion.

2

13

resulting formula obtained by substituting each xi in vector x with ti in vector t if xi occurs in . For example, in particular, if (x) in fact has no free variables, then no substitution happens and (t ) is the same as (x). · If W is not atomic, i.e., W is of the form W1  W2 , W1  W2 , ¬W  , or Qv.W  where Q represents a quantifier (including counting quantifiers) and v represents a variable symbol, then R[W1  W2 ] = R[W1 ] R[W2 ], R[W1  W2 ] = R[W1 ] R[W2 ], · R[¬W  ] = ¬R[W  ], R[Qv.W  ] = Qv.R[W  ].

Otherwise, W is an atom. There are several cases.

a. If W is a regressable P oss atom, then it has the form P oss(A(t ),  ), for terms of sort action and 2 situation, respectively, in LC sc . Then there must be an action precondition axiom for A of the form P oss(A(z ), s)  A (z, s), where the argument z of sort object can either be empty (i.e., A is an action constant), a single variable x, or two-variable vector x, y . Because of the syntactic 2 restrictions of LC sc and according to the condition (2,3) in Def. 1, each term in t can only be a variable x, y or some constant if any. Then,  R[(y.x = y  A (x, y,  ))] if t = x, x ,    R[(x.y = x   (x, y,  ))] if t = y, y ,   A R[W ] = R[A (t,  )] if t  {y, y, O , O, x , y, x },    R[A (t,  )] otherwise, i.e., if t is empty or   t  {O, x, x, y , x, O , O, y , O, O1 },

where O and O1 are constants and  denotes a dual formula for formula  obtained by replacing every variable symbol x (free or bound) with variable symbol y and replacing every variable symbol y (free or bound) with variable symbol x in , i.e.,  = [x/y, y/x]. In this definition, in order to avoid introducing new variables but still ensure the correctness of regression in the sense that the regressed formula is logically equivalent to W w.r.t. D , we consider all the possible syntactic forms of the arguments t in action terms and treat them carefully in each of the four cases. Because of the 2 C2 restriction of the language of LC sc and the additional conditions (1)­(3) of Lsc regressable formula, we are able to reuse the variables x and y by switching their occurrences when t is either y , y, O , O, x or y, x .

b. If W is a defined dynamic concept, it has the form G(t,  ) for some object term t and ground situation term  , and there must be a TBox axiom for G of the form G(x, s)  G (x, s). Because of the 2 restrictions of the language LC sc , term t can only be a variable x, y or a constant. Then, we use the lazy unfolding technique as follows: R[W ] = R[G (t,  )] R[G (y,  )] if t  {O, x}, otherwise, i.e., if t = y.

c. If W is a primitive dynamic concept (a dynamic role, respectively) of the form F (t1 , do(,  )) (or F (t1 , t2 , do(,  )), respectively) for some terms t1 (and t2 ) of sort object, ground term  of sort action and ground term  of sort situation, there must be an SSA for fluent F of the form F (x, do(a, s))  2 F (x, a, s), whose detailed syntax is Eq. (4). Because of the restriction of the language LC sc , the terms t1 and t2 can only be a variable x, y or some constant O . Then, when W is a primitive dynamic concept, i.e., W is of the form F (t1 , do(,  )), 14

R[W ] =

R[F (t1 , ,  )] R[F (y, ,  )]

if t1  {O, x}, otherwise, i.e., if t1 = y ;

d. If W is of the form A1 (t ) = A2 (t ) for some action function symbols A1 and A2 , then by using axioms in Duna ,10 we define the regression of W as  f alse if A1 = A2 ,     true if A1 = A2 and A1 , A2 are constant action functions, R[W ] = |t|    ti = ti otherwise. 
i=1

and, when W is a dynamic role, i.e., W is of the form F (t1 , t2 , do(,  )),  R[(y.x = y  F (x, y, ,  ))] if t1 , t2 = x, x ;      R[(x.y = x  F (x, y, ,  ))] if t1 , t2 = y, y ; R[W ] = R[F (y, t2 , ,  )] if t1 , t2  { y, x , y, O , O, x };    R[F (t1 , t2 , ,  )] otherwise, i.e, if t1 , t2    { x, y , x, O , O, y , O, O1 }.

Otherwise, if W is any other situation independent atom (including equality between object terms) or W is a concept or role uniform in S0 , then R[W ] = W. (7)

Our intention here is to get a C 2 formula (with situation terms suppressed) that has no (in)equality between action terms after regression. We therefore cannot leave (in)equalities between action terms untouched in the regressed formula unlike Reiter's definition of the regression operator that simply used Eq. (7) when dealing with (in)equalities between terms. By using unique name axioms for actions during regression, we can avoid functional terms in the resulting formula. Note that in this definition (case (c.) and case (d.)), when t is x, x (or y, y , respectively), we define regression by using quantified variable y (or x, respectively); otherwise, we cannot ensure the correctness of regression in the sense that the regressed formula is logically equivalent to W w.r.t. D , i.e., D |= 2  W  R[W ]. In particular, for any LC = W  W  , a correct sc regressable formulas W and W such that |  definition of regression should result in D |= R[W ]  R[W ]. For example, in case (c), notice that |= F (x, x, do(,  ))  (y.x = y  F (x, y, do(,  )), and it is easy to see that our definition of R ensures that |= R[F (x, x, do(,  ))]  R[(y.x = y  F (x, y, do(,  ))]. Consider the following counterexample if we perform regression by directly substituting x, y by x, x (or y, y ) on the RHS of SSAs or precondition axioms. Example 2 Assume that D is a BAT of LC sc , which includes an SSA F (x, y, do(a, s))  a = A(x)  (x.F1 (x, y, s))  F (x, y, s).
10
2

(8)

Notice that the action functions with different number of arguments always use different function symbols (i.e., different names).

15

Consider an LC sc regressable formula W = F (x, x, do(A(C ), S0 )). Then if we perform regression by directly substituting x, y with x, x on the RHS of Eq. (8), we get A(C ) = A(x)  (x.F1 (x, x, S0 ))  F (x, x, S0 )), which obviously will not be logically equivalent to W w.r.t. D . Indeed, in Eq. (8), the variable y in F1 is free, but once substituted by x directly, it becomes quantified by x. at the front of F1 , which should not happen. Based on the above definition, we are able to prove the following theorems. Theorem 2 Suppose W is an LC sc regressable formula, then the regression R[W ] defined above terminates in a finite number of steps. Proof of Theorem 2. This immediately follows from Def. 1, acyclicity of the TBox axioms, and from the assumption that RBox axioms are compiled into the SSAs and consequently do not participate in regression. Note also that each time, the application of R either goes from a formula to a sub-formula, or expands a P oss or a fluent atom using a corresponding precondition axiom or an SSA, but only finitely many expansions are possible because W mentions only finitely many ground situation terms. According to the definition of the modified regression operator, the following statement can be proved by induction over the structure of W . The detailed proof is provided in Appendix B.2.
C Theorem 3 Suppose W is an LC sc regressable sentence with the background BAT D in language Lsc . 2 2 Then, R[W ] is an LC sc sentence uniform in S0 and it is a C sentence when the situation argument S0 is suppressed. Moreover, D |= W  R[W ].
2 2 2

2

Consequently, we have the following theorem.
C Theorem 4 Suppose W is an LC sc regressable sentence with the background BAT D in language Lsc . Then, D |= W iff DS0 |= R[W ].
2 2

Proof of Theorem 4. Part of our proof is almost word-by-word repetition of the laborious proof of the regression theorem given in [66]. Therefore, we will only briefly explain the idea of what has been done in [66] and provide details for what is different. In [66], Pirri and Reiter first proved that "a BAT D is satisfiable iff DS0  Duna is satisfiable". It is trivial that if a BAT D is satisfiable then DS0  Duna is satisfiable. For the other direction, Pirri and Reiter proved it by constructing a model step by step for D that interprets axioms in D - (DS0  Duna ) properly, 2 starting from any model of DS0  Duna . Similarly, we can also prove that "a BAT D in LC sc is satisfiable iff DS0  Duna is satisfiable". We use the same idea with the following modification. For any model M of DS0  Duna , we also add interpretations for the defined concepts, such that the interpretations for G(x)[s] are true iff those of G (x)[s] are. Subsequently, in [66], Pirri and Reiter proved the following lemma that "suppose W is a regressable sentence with the background BAT D that is uniform in S0 , then D |= W iff DS0 Duna |= W " by using 2 C2 the above result. This lemma is also valid for LC sc . That is, "suppose W is an Lsc regressable sentence 2 with the background BAT D in LC = W iff DS0  Duna |= W ". sc , if W is uniform in S0 , then D | C2 Now we prove the following statement: "suppose W is an Lsc regressable sentence with the back2 2 ground BAT D in LC sc , if W is uniform in S0 and W is a C formula when S0 is suppressed, then DS0  Duna |= W iff DS0 |= W ". It is trivial to see that if DS0 |= W , then DS0  Duna |= W . For the other direction, it is the same as proving if DS0  Duna  {¬W } is inconsistent, so is DS0  {¬W }. We can prove it by contradiction. That is, assume that DS0  {¬W } is consistent, then there is a model 16

M0 , such that M0 |= DS0  {¬W }. We can then construct a model M0 such that M has the same domain on object sort. For any action functions A(x1 ), B (x2 ), we construct M so that (A(x1 ))M = (B (x2 ))M for any variable vectors x1 and x2 if symbol A is different from B ; and for any object terms t1 = t1,1 · · · t1,n and t2 = t1,1 · · · t1,n and any n-ary action function A, (A(t1 ))M = (A(t2 ))M iff (t1,i )M = (t2,i )M for all M i = 1..n. Moreover, S0 = [] (i.e., the empty sequence). Since DS0  {¬W } has no action terms in it, M is well defined and is a model of DS0  Duna  {¬W }, which is a contradiction. Hence, all in all, we have: 2 C2 Suppose W is an LC sc regressable sentence with the background BAT D in Lsc , if W is uniform in S0 and W is a C 2 formula when S0 is suppressed, then D |= W iff DS0 |= W . Then, by Theorem 3 and the above proved statement, we have D |= W iff D |= R[W ] iff DS0 |= R[W ]. We can also obtain the following theorem about decidability of the projection problem for LC sc regressable sentence W . (In particular, when W is of the form executable(S ) for some ground situation S , it becomes the executability problem.)
C Theorem 5 Suppose W is an LC sc regressable sentence with the background BAT D in language Lsc . Then, determining whether D |= W is decidable.
2 2 2

Proof of Theorem 5. According to Theorem 4, D |= W iff DS0 |= R[W ], where R[W ] and the axioms in DS0 are C 2 formulas. Therefore, determining whether D |= W is equivalent to determining whether DS0 ¬R[W ] (DS0 can be considered as a conjunction of all axioms in the initial theory) is unsatisfiable or not, which is a decidable problem, according to the fact that the satisfiability problem in C 2 is decidable. This theorem is important because it guarantees that the projection and executability problems in LC sc are decidable even if the initial KB DS0 is incomplete. In Section 6, we give a detailed example that illustrates the basic reasoning tasks described above and reduction techniques for dealing with properties 2 that need more than two variables, and show that using LC sc , one can model realistic dynamic domains such as school enrolment services.
2

5.2 Some Computational Complexity Results
We now consider the computational complexity of solving the projection problems in LC sc . We introduce a few new notations for later convenience. 2 For any LC sc regressable formula W , let function size(W ) be the size of formula W , which is defined recursively: 1. If W is atomic (including equality), then size(W ) = 1. 2. If W is of the form ¬W1 , x.W1 , x.W1 , n x.W1 , n x.W1 , y.W1 , y.W1 , n y.W1 , or n y.W1 , then size(W ) = size(W1 ) + 1. 3. If W is of the form W1  W2 or W1  W2 , then size(W ) = size(W1 ) + size(W2 ) + 1. 4. If W is of the form W1  W2 , then size(W ) = size(¬W1  W2 ). 5. If W is of the form W1  W2 , then size(W ) = size(W1  W2 ) + size(W2  W1 ) + 1.
2

17

For any situation term  = do([1 , · · · , k ], S0 ), let function sitLength( ) = k represent the number of action terms mentioned in  . In particular, sitLength(S0 ) = 0. For any formula W , let function height(W ) = max{sitLength( ) |  appears in W }.


Given any BAT D , for any fluent F whose SSA is of the form Eq. (4), let function numF luent(F ) be the number of fluents (including repeated ones) appearing in F (the RHS of the SSA of fluent F ), and let numF luentSSA(D ) = max{numF luent(F ) | any F that has an SSA in D}.
F

Besides, let sizeSSA(D ) = max{size(F ) | any SSA F (x, do(a, s))  F in D}.
F

Note that numF luentSSA(D ) and sizeSSA(D ) are different: the former one is the maximal number of fluents appearing in the formulas that are on the RHS of the SSAs of a given BAT D , and the latter one is the maximal size of the formulas (including non-fluent atoms and logical connectives) that are on the RHS of the SSAs of a given BAT D . Moreover, notice that once D is given, numF luentSSA(D ) and sizeSSA(D ) are fixed. In general, we have the following result.
C Theorem 6 Consider any LC sc regressable formula W with a given BAT D in Lsc . Then, answering the query whether D |= W is in the complement of NEE XP T IME.
2 2

Proof of Theorem 6. According to the discussion in the proof of Theorem 5, determining whether D |= W is equivalent to determining whether DS0 ¬R[W ] is unsatisfiable or not, i.e., the complement problem of whether DS0 ¬R[W ] is satisfiable or not. Note that DS0 ¬R[W ] is a C 2 formula (when the situation argument S0 is suppressed). Moreover, according to [68], the satisfiability problem in language C 2 is in NE XP T IME, that is, NTIME(2l ) if the input size of the formula is l. Since for any given D , the size of DS0 is fixed, the size of ¬(DS0 ¬R[W ]) is in (n1 ), where n1 = size(R[W ]). Hence, answering the query whether D |= W is in co-NTIME(2n1 ), i.e., the complement of NE XP T IME w.r.t. the size of R[W ]. However, in the worst case, computing R[W ] takes E XP T IME w.r.t. n, where n = height(W ), and causes exponential blow-up in the size of formula W w.r.t. n. In detail, without loss of generality, we assume that there is no defined concept in W . Otherwise, each defined concept will be replaced by its 2 definitions from the TBox axioms with fixed steps of LC sc regression. This can cause no more than a constant increase to the size of the original formula, because TBox is fixed (once D is given), TBox is acyclic, there are only finitely many TBox axioms and the size of the formula on the RHS of each TBox axiom is limited from above by a constant. Let k = numF luentSSA(D ) and h = max(2, sizeSSA(D )). Both k 2 and h are constants for the given BAT D , and h > k . Moreover, since all action functions in LC sc have no more than two arguments, the regression on equalities between action terms (see a. in the above definition 2 of the LC sc regression operator) no more than triples the size of the regressed atomic formulas (including at most 1 conjunction operator and at most 2 equality atoms), and such regression applies only once to each equality between action terms. The worst case scenario happens if each SSA mentions all k fluents and the size of the RHS of the SSA is h. In this case, each step of regression on a fluent atom creates at most h new branches in a regression tree (k out of these h branches have one atomic fluent as its node). The next application of the regression operator replaces fluents in these k nodes by the RHS of the corresponding SSAs, and so on. If the length of the longest situation term in W before regression is n, then the height of the resulting regression tree is no more than n + 1 (including n levels of regressions on fluents and at most 1 level of regression on the equalities between actions). Finally, we are looking for a total number of

18

leaves in this tree (this number is the size of the regressed formula R[W ]), which is n-1 3(h - 1)mn + 3m if k = 1 size(R[W ])  3m(1 + (h - 1) ki)  3h(mk n ) if k > 1.
i=0

Clearly, 3h(mk n ) is no more than 3h(m2n log2 (k+1) ). Formally, it is straightforward to prove by induction according to the recursive definition of the regression operator that size(R[W ])  O (mn) when k = 1, and size(R[W ])  O (mk n ) (which is the same as size(R[W ])  O (m2n log2 (k+1) )) when k  2. Overall, in the worst case scenario, answering the query whether D |= W is in the complen log (k+1) ment of NTIME(23hm2 2 ) according to the above discussion, where h and k are constants. That is, answering the query whether D |= W is in the complement of NEE XP T IME (non-deterministic doublyexponential time). We further consider some special cases of BATs that have better computational complexity results, but less expressive power. We say that the SSA for a fluent F is context-free if the SSA of F has the syntactic form
+ - F (x, do(a, s))  F (x, a)  F (x, s) ¬F (x, a), + - that is, both the positive condition F (x, a) and the negative condition F (x, a) are situation independent (see Chapter 4 in [70]). According to this definition, it is easy to see that all the context conditions + - (i (x(i,+) )[s] for all 1  i  m+ and j (x(j,-) )[s] for all 1  i  m- ) in Eq. (4) are situation independent (i.e., there is no s in any of the context conditions). Note that there is a special case if a positive (or negative, respectively) effect only depends on some action term (i.e., there is no context condition, or, the corresponding context condition is always equivalent to true). Then, we have the following theorem about the computational complexity for reasoning about projection problems.

Theorem 7 Given a BAT D in LC sc , suppose that the SSA for a fluent F is context-free. Then, the computational complexity of answering the queries of the form F (X,  ) is in co-NE XP T IME, where X is a vector of object constants and  is a ground situation term. Proof of Theorem 7. The result follows from the analysis of the computational complexity of the projection problem in [70] (Chapter 4), which shows that the complexity is at most linear to the complexity of evaluating a sentence in the initial situation under such assumptions. In fact, from the proof of Theorem 6, when a fluent F is context-free, numF luent(F ) = 1. Let size(F ) = h0 , then the number of leaves in the regression tree of F (X,  ), i.e., the size of the regressed formula, equals n(h0 - 1) + 1, which is in O (n). Again, using the same reasoning as in the proof of Theorem 6, the problem of answering the queries of the form F (X,  ) is the complement of the problem whether DS0 ¬F (X,  ) is satisfiable or not. Hence, its computational complexity is in co-NTIME(2O(n)), i.e, it is in co-NE XP T IME. Using the same reasoning as in Theorem 7, in general, we have the following corollary.
C Corollary 1 Given a BAT D in LC sc , suppose that every SSA in D is context-free. Then, for any Lsc regressable formula W , answering the query whether D |= W is in co-NE XP T IME.
2 2

2

5.3 A Description-Logic Based Situation Calculus
We see from Theorem 6 that the computational complexity of solving the projection problems in LC sc (using the regression mechanism) is quite high. On the other hand, with context-free SSAs, although we can gain better complexity (see Theorem 7), the expressive power of context-free SSAs is quite limited. 19
2

Motivated by the observation that some DL languages have better computational complexity for concept satisfiability problems and/or ABox consistency problems than C 2 (see Section 3.2) and the idea of restricting the context conditions in the SSAs similar to context-free SSAs, we now consider another type 2 of restriction on BATs in the language of LC sc . We would like to get better complexity results than that of Theorem 6 when solving the projection problem in general. At the same time, we consider a fragment that is more expressive than context-free SSAs. Moreover, we will see that this language has natural connections with DLs. We first consider a sub-language of FO2 , denoted F ODL. The language of F ODL includes constants, y x monadic and dyadic predicates. Moreover, it is a union of two sub-languages: F ODL = F ODL  F ODL , y x where the detailed definition of F ODL is provided below and F ODL is obtained by renaming every x x x with y and every y with x for every formula in F ODL . The set F ODL is a minimal set of formulas built inductively as follows:
x · true and f alse are in F ODL . x · If AC is a monadic predicate name, then AC (x) is in F ODL . x · If b is a constant, then x = b is in F ODL . x x · If  is in F ODL , then ¬ is in F ODL . x x · If  and  are in F ODL , then    and    are in F ODL . x · If (x) is in F ODL , and (x) has at most one free variable x, and R is a dyadic predicate name, (y ) is the dual formula of (x), obtained by renaming every x (both free and bound) with y and every y x (both free and bound) with x in , then y.R(x, y )  (y ) and y.R(x, y )  (y ) are in F ODL . x · If  is in F ODL ,  is the dual formula of , obtained by renaming every x (both free and bound) x , with y and every y (both free and bound) with x in , then [y.](y ) and [y.](y ) are in F ODL where [y.] ([y.], respectively) means that if  has a free variable y , then it is quantified by y (y , respectively); otherwise, there is no need to add the quantifier. x The semantics of F ODL are the same as the usual semantics of FO2 . Notice that for any   F ODL y y x (  F ODL, respectively),  is in F ODL (F ODL , respectively). Moreover, it is easy to see that any y x sentence (i.e., closed formula) in F ODL is in both F ODL and F ODL . We then are able to prove the following lemma (the detailed proof is provided in Appendix B.3).

Lemma 1 There are syntactic translations between F ODL and the DL language ALCO (U ), i.e., they are equally expressive. Moreover, such translations lead to no more than a linear increase in the size of the translated formula. Recall from the review of DLs in Section 3.1 that the satisfiability problem of a concept and/or the consistency problem of an ABox in the DL language ALCO (U ) can be solved in E XP T IME. This is an improvement over C 2 and FO2 (see Section 3.2). For this reason we would like to investigate a new SC based on F ODL. Definition 2 We say that the SSA for a fluent F is ALCO (U )-restricted if the SSA of F has the form of + - Eq. (4), where each context condition i (or i , respectively) is a formula in F ODL when all situation 20

variables are suppressed. Moreover, we say that the set of SSAs Dss in a BAT D is ALCO (U )-restricted if every axiom of a primitive dynamic concept in Dss is ALCO (U )-restricted and every axiom of a dynamic role in Dss is both ALCO(U )-restricted and context-free. We say that a concept definition of the form Eq. (5) for any defined concept G (including static or dynamic) is ALCO (U )-restricted if the formula G (x) on the RHS of Eq. (5) is in F ODL. Moreover, we say that the acyclic TBox DT of a BAT D is ALCO (U )-restricted if every axiom in the set is ALCO (U )restricted. We can then prove the following lemma (its proof is provided in Appendix B.4).
C Lemma 2 Consider a BAT D in LC sc whose Dss and DT are ALCO (U )-restricted. Let W be an Lsc regressable formula that is uniform in a ground situation S and has no appearance of P oss. Let n = sitLength(S ) and m = size(W ). Then, if W with the situation term S suppressed is in F ODL , there is a W in F ODL such that R[W ] is equivalent to W [S0 ]. It takes no more than c · n · size(W ) steps of deduction from R[W ] (with S0 suppressed) to find such W , where c is a positive integer. Moreover, 2 2 size(W ) is in O (2hmn+3h n ) for some positive integer h. That is, the size of W is no more than exponential in the size of W .
2 2

Then we have the following complexity result. Theorem 8 Consider a BAT D in LC sc whose Dss and DT are ALCO (U )-restricted. Let DS0 , with the 2 situation term S0 suppressed, be in F ODL . Let W be any LC sc regressable sentence in D that is uniform in a ground situation S and has no appearance of P oss. If W , with the situation term S suppressed, is in F ODL, then answering the query whether D |= W can be solved in EE XP T IME. Proof of Theorem 8. First, D |= W iff DS0 |= R[W ] by Theorem 4. Also, by Lemma 2, we can find a formula  in F ODL in no more than exponential time wrt the size of W , such that |= [S0 ]  R[W ], and the size of  is no more than exponential in the size of W . Hence, DS0 |= R[W ] iff DS0 |= [S0 ]. It is the same as answering whether DS0¬[S0 ] is unsatisfiable or not, which is a complement problem of whether DS0¬[S0 ] is satisfiable or not. Let  be the formula DS0¬[S0 ] with situation term S0 suppressed, and it is easy to see that  is in F ODL, because DS0 is in F ODL when the situation term S0 is suppressed and  is in F ODL.  has the same size as DS0 ¬[S0 ], and it is unsatisfiable iff DS0 ¬[S0 ] unsatisfiable. Using the syntactic translation function  defined in the proof of Lemma 1 (see Appendix B.3),  () is a concept in DL language ALCO (U ). To decide whether a concept  () is satisfiable in ALCO (U ) is in E XP T IME with respect to the size of  (), which is linear in the size of . Hence, deciding whether DS0 |= R[W ] is in co-E XP T IME wrt the size of DS0 ¬[S0 ]. However, when D is given the size of DS0 is fixed, hence, deciding whether DS0 |= R[W ] is in fact in co-E XP T IME wrt the size of [S0 ] (which is the same as the size of ). Again, because the size of  is exponential in the size of W , deciding whether DS0 |= R[W ] is in the complement of EE XP T IME ( wrt the size of W ), which is the same as EE XP T IME. Recall from the review of DLs in Section 3.1 that the satisfiability problem of a concept and/or the consistency problem of an ABox in the DL language ALCQO (U ) can also be solved in E XP T IME. For this reason, similar to the development above, we can extend F ODL to a sub-language of C 2 , say F ODL+ , y x x by adding counting quantifiers to F ODL. Formally, F ODL+ = F ODL +  F ODL+ , where F ODL+ is a y x minimal set of formulas built inductively below, and F ODL + = { |   F ODL+ }.
x · true and f alse are in F ODL +.
2

21

x · If AC is a monadic predicate name, then AC (x) is in F ODL +. x · If b is a constant, then x = b is in F ODL +. x x · If  is in F ODL + , then ¬ is in F ODL+ . x x · If  and  are in F ODL + , then    and    are in F ODL+ . x · If (x) is in F ODL + , and (x) has at most one free variable x, and R is a dyadic predicate name, (y ) is the dual formula of (x), obtained by renaming every x (both free and bound) with y and every y (both free and bound) with x in , then y.R(x, y )(y ), y.R(x, y )  (y ), n y.R(x, y ) x (y ) and n y.R(x, y )  (y ) for any n  N are in F ODL +. x · If  is in F ODL + ,  i dual formula of , obtained by renaming every x (both free and bound) with y and every y (both free and bound) with x in , then [y.](y ), [y.](y ), [n y.](y ) and x n [n y.](y ) for any n  N are in F ODL y.], or [n y.], respectively) + , where [y.] ([y.], [ means that if  has a free variable y , then it is quantified by y (y , n y , or n y , respectively); otherwise, there is no need to add such quantifier.

The semantics of F ODL+ is the same as the usual semantics of C 2 . Similar to Lemma 1, we are able to prove the following lemma.11 Lemma 3 There are syntactic translations between F ODL+ and the DL language ALCQO (U ), i.e., they are equally expressive. Moreover, such translations lead to no more than a linear increase in the size of the translated formula. Similarly, we say that the SSA for a fluent F is ALCQO (U )-restricted if the SSA of F has the form of + - Eq. (4), where each context condition i (or i , respectively) is a formula in F ODL+ when all situation variables are suppressed. Moreover, we say that the set of SSAs Dss in a BAT is ALCQO (U )-restricted if every axiom of a primitive dynamic concept in Dss is ALCQO (U )-restricted and every axiom of a dynamic role in Dss is both ALCQO (U )-restricted and context-free. We say that a concept definition of the form Eq. (5) for any defined concept G (including static or dynamic) is ALCQO (U )-restricted if the formula G (x) on the RHS of Eq. (5) is in F ODL+ . Moreover, we say that the acyclic TBox DT of a BAT D is ALCQO (U )-restricted. Similar to Lemma 2, we can also prove a lemma for ALCQO (U )-restricted regressable formulas as follows.
C Lemma 4 Consider a BAT D in LC sc whose Dss and DT are ALCQO (U )-restricted. Let W be an Lsc regressable formula that is uniform in a ground situation S and has no appearance of P oss. Let n = sitLength(S ) and m = size(W ). Then, if W with the situation term S suppressed is in F ODL+ , there is a W in F ODL+ such that R[W ] is equivalent to W [S0 ]. It takes no more than c · n · size(W ) steps of deduction from R[W ] (with S0 suppressed) to find such W , where c is a positive integer. Moreover, 2 2 size(W ) is in O (2hmn+3h n ) for some positive integer h. That is, the size of W is no more than exponential in the size of W .
11 The proof of Lemma 3 is exactly the same as the proof of Lemma 1 except that we only need to add translation for counting quantifiers, which is straightforward. Hence, the proof of Lemma 3 is omitted.
2 2

22

Proof of Lemma 4. The proof is exactly the same as the proof of Lemma 2 (see Appendix B.4), where y y x x F ODL (F ODL , or F ODL , respectively) is replaced by F ODL+ (F ODL + , or F ODL+ , respectively), and we need to consider sub-cases constructed using the counting quantifiers n and n in the proof. But the proof for cases that are constructed using n and n are the same as the proof for the case using the -quantifier (see case (d) of the inductive step of the nested induction on the structure of the regressable formula W in the proof of Lemma 2, Appendix B.4). Hence, the detailed proof of Lemma 4 is omitted here. As a consequence, similar to the proof of Theorem 8, we also have the following result. Theorem 9 Consider a BAT D in LC sc whose Dss and DT are ALCQO (U )-restricted. Let DS0 , with the 2 situation term S0 suppressed, be in F ODL+ . Let W be any LC sc regressable sentence in D that is uniform in a ground situation S and has no appearance of P oss. If W , with the situation term S suppressed, is in F ODL+ , then answering the query whether D |= W can be solved in EE XP T IME.
2

6 An Example of Regression in LC sc
2

2

In this section, we give an example of a BAT D in LC sc to illustrate the ideas described above. Example 1 Consider some university that provides student administration and management services on the Web: admitting students, paying tuition fees, enrolling or dropping courses and entering grades. Although the number of object arguments in the predicates can be at most two, sometimes, we are still able to handle those features of the systems that require more than two arguments. For example, the grade z of a student x in a course y may be represented as a predicate grade(x, y, z ) in the general FOL (i.e., with three object arguments). Because the number of distinct grades is finite and they can be easily enumerated as "A", "B", "C" or "D", we can handle grade(x, y, z ) by replacing it with a finite number of extra predicates, say gradeA(x, y ), gradeB (x, y ), gradeC (x, y ) and gradeD(x, y ) such that they all have two variables only. However, the restriction on the number of variables limits the expressive power of the language if more than two arguments vary over infinite domains (such as energy, weight, time, etc). Despite this limitation, we conjecture that many web services still can be represented with at most two variables either by introducing extra predicates (just like we did for the predicate grade) or by grounding some of the arguments if their domains are finite and relatively small. Intuitively, it seems that most of the practical dynamical systems can be specified by using properties and actions with small arities, hence the techniques for arity reductions mentioned above and below require no more than polynomial increase in the number of axioms. The high-level features of our example are specified as the following concepts and roles. · Primitive static concepts: person(x) (x is a person); course(x) (x is a course provided by the university). · Primitive dynamic concepts: incoming (x, s) (x is an incoming student in the situation s, it is true when x was admitted). · Defined dynamic concepts: eligF ull(x, s) (x is eligible to be a full-time student by paying more than 5000 dollars tuition fee); eligP art(x, s) (x is eligible to be a part-time student by paying no more than 5000 dollars tuition); qualF ull(x, s) (x is a qualified full-time student if he or she pays full time tuition fee and takes at least 4 courses); qualP art(x, s) (x is a part-time student if he or she pays part-time tuition and takes 2 or 3 courses). · Static role: preReq (x, y ) (course x is a prerequisite for course y ). 23

· Dynamic roles: hasGrade(x, y, s) (x has a grade for course y in the situation s), tuitP aid(x, y, s) (x paid tuition fee y in the situation s), enrolled(x, y, s) (x is enrolled in course y in the situation s), completed(x, y, s) (x completes course y in the situation s), gradeA(x, y, s), gradeB (x, y, s), gradeC (x, y, s), gradeD(x, y, s). Web services are specified as actions: reset (at the beginning of each academic year, the system is being reset so that students need to pay tuition fee again to become eligible), admit(x) (the university admits student x), payT uit(x, y ) (x pays tuition fee with the amount of y ), enroll(x, y ) (x enrols in course y ), drop(x, y ) (x drops course y ), enterA(x, y ) (enter grade "A" for student x in course y ), enterB (x, y ), enterC (x, y ), enterD (x, y ). The BAT is as follows (most of the axioms are self-explanatory). Precondition Axioms: P oss(reset, s)  true, P oss(admit(x), s)  person(x) ¬incoming (x, s), P oss(payT uit(x, y ), s)  incoming (x, s) ¬tuitP aid(x, y, s), P oss(drop(x, y ), s)  enrolled(x, y, s) ¬completed(x, y, s), P oss(enterA(x, y ), s)  enrolled(x, y, s) ¬completed(x, y, s), and the precondition axiom for enterB (x, y ) (enterC (x, y ) and enterD (x, y ), respectively) is similar to the axiom for enterA(x, y ). Moreover, in the traditional SC, the precondition for action enroll(x, y ) would be equivalent to (z )(preReq (z, y )  completed(x, z, s) ¬gradeD(x, z, s)). However, in the modified SC, we only allow at most two object variables (including free or bound). Fortunately, the number of the courses offered in a university is limited (finite and relatively small) and relatively stable over years (if we manage the students in a college-wise range or department-wise range, the number of courses may be even smaller). Therefore, we can specify the precondition for the action enroll(x, y ) for each instance of y . That is, assume that the set of courses is {CS1 , · · · , CSn }, the precondition axiom for each CSi (i = 1..n) is P oss(enroll(x, CSi ), s)  (y )(preReq (y, CSi)  completed(x, y, s) ¬gradeD(x, y, s)). On the other hand, when we do this transformation, we can omit the statements course(x) for each course available at the university in the initial theory. Successor State Axioms: The SSAs for the fluents gradeB (x, y, s), gradeC (x, y, s) and gradeD(x, y, s) are very similar to the one for fluent gradeA(x, y, s). Therefore they are not repeated here. They ensure that for each student and each course there is no more than one grade assigned. The SSA for the fluent hasGrade(x, y, s) is also similar and for this reason it is omitted. incoming (x, do(a, s))  a = admit(x)  incoming (x, s), tuitP aid(x, y, do(a, s))  a = payT uit(x, y )  tuitP aid(x, y, s)  a = reset, enrolled(x, y, do(a, s))  a = enroll(x, y ) enrolled(x, y, s) ¬(a = drop(x, y )  a = enterA(x, y ) a = enterB (x, y )  a = enterC (x, y )  a = enterD (x, y )),

24

completed(x, y, do(a, s))  a = enterA(x, y )  a = enterB (x, y ) a = enterC (x, y )  a = enterD (x, y ) completed(x, y, s)  a = enroll(x, y ), gradeA(x, y, do(a, s))  a = enterA(x, y )  gradeA(x, y, s) ¬(a = enterB (x, y )  a = enterC (x, y )  a = enterD (x, y )), and the SSA for fluent gradeB (x, y, s) (for gradeC (x, y, s) and for gradeD(x, y, s), respectively) is similar to the one for fluent gradeA(x, y, s). Acyclic TBox Axioms: (no static TBox axioms in this example) eligF ull(x, s)  (y )(tuitP aid(x, y, s)  y > 5000), eligP art(x, s)  (y )(tuitP aid(x, y, s)  y  5000), qualF ull(x, s)  eligF ull(x, s)  (4 y )enrolled(x, y, s), qualP art(x, s)  eligP art(x, s)  (2 y )enrolled(x, y, s) (3 y )enrolled(x, y, s). An example of the initial theory DS0 could be the conjunctions of the following sentences: (x, y )¬paidT uit(x, y, S0), (x)incoming (x, S0 )  x = P2  x = P3 , preReq (CS1 , CS4 )  preReq (CS3 , CS4 ), (x)x = CS4  ¬(y ).preP eq (y, x), person(P1 ),· · · , person(Pm ). One can also imagine that some RBox axioms, for example gradeA(x, y, s)  hasGrade(x, y, s), may be used for taxonomic reasoning in this domain. 2 Finally, we give an example of regression of an LC sc regressable formula: R[(x).qualF ull(x, do([admit(P1 ), payT uit(P1, 6000)], S0))] = R[(x).eligF ull(x, do([admit(P1 ), payT uit(P1, 6000)], S0)) (4 y )enrolled(x, y, do([admit(P1), payT uit(P1, 6000)], S0))] = ··· = (x).(4 y )enrolled(x, y, S0)  ((y )R[y > 5000 tuitP aid(x, y, do([admit(P1), payT uit(P1, 6000)], S0))]) = ··· = (x).(4 y )enrolled(x, y, S0)  ((y ).tuitP aid(x, y, S0) y > 5000  (x = P1  y = 6000  y > 5000)), which is false given the above initial theory. Suppose we denote the above BAT as D . Given goal G, for example x.qualF ull(x), and a composite web service starting from the initial situation, for example, do([admit(P1 ), payT uit(P1, 6000)], S0) (we denote the corresponding resulting situation as Sr ). We can check if the goal is satisfied after the execution of this composite web service by solving the projection problem whether D |= G[Sr ]. In our example, this corresponds to solving whether D |= x.qualF ull(x, Sr ). We may also check if a given (ground) composite web service A1 ; A2 ; · · · ; An is possible to execute starting from the initial state by solving the executability problem whether D |= executable(do([A1 , A2 , · · · , An ], S0 )). For example, we can check if the composite web service admit(P1 ); payT uit(P1, 6000) is possible to be executed from the starting state by solving whether D |= executable(Sr ). Note that both entailment problems can be decided (not only for the query that we consider, but also for any query) because they can be reduced to the satisfiability problem in C 2 .

25

7 Discussion and Future Work
The major consequence of the results proved above for the problem of service composition is the following. If both atomic services and properties of the world that can be affected by these services have no more than two parameters (other than the situation argument), then we are guaranteed that even in the state of incomplete information about the world, one can always determine whether a sequentially composed service is executable and whether this composite service will achieve a desired effect. The previously proposed approaches made different assumptions: [56] assumes that the complete information is available about the world when effects of a composite service are computed, and [25, 18] consider the propositional fragment of the SC. In [56, 61], it was proposed to use Golog for composition of Semantic Web services. Because our primitive actions correspond to elementary services, it is desirable to define Golog in our modified SC too. It is surprisingly straightforward to define almost all Golog operators starting from our C 2 -based SC. The only restriction in comparison with the original Golog [41, 70] is that we cannot define the operator 2 (x) (x), non-deterministic choice of an action argument, because LC sc regressable formulas cannot have occurrences of non-ground action terms in situation terms. In the original Golog this is allowed, because the regression operator is defined for a larger class of regressable formulas. However, everything else from the original Golog specifications remain in force, no modifications are required. In addition to providing a well-defined semantics for Web services, our approach also guarantees that the evaluation of tests in Golog programs is decidable (w.r.t. an arbitrary initial theory DS0 ), which is missing in other approaches (unless one can make the closed world assumption or impose another restriction to regain decidability). In [2], an integration of the description logic ALCQIO (and its sub-languages) with an action formalism for reasoning about Web services is proposed. Their paper starts with a description logic and then defines services (actions) meta-theoretically: an atomic service is defined as the triple of sets of description logic formulas. To solve the executability and projection problems the paper introduces an approach similar to regression, and reduces this problem to description logic reasoning. The main aim is to show how the executability of sequences of actions and a solution to the projection problem can be computed, and how the complexity of solving these problems depends on the chosen description logic. Despite that our paper and [2] have common goals, our developments start differently and proceed in different directions. We start from the syntactically restricted FO language (that is significantly more expressive than ALCQIO ), use it to construct the modified SC (where actions are terms), define BATs in this language and show that by augmenting (appropriately modified) regression with lazy unfolding one can reduce the executability and projection problems to the satisfiability problem in C 2 , which is decidable. Furthermore, C 2 formulas can be translated to ALCQIO (, , ¬, |, id), if desired. Because our regression operator unfolds fluents "on demand" and uses only relevant part of the (potentially huge) TBox , we avoid potential computational problems that could occur if the TBox axiom were eliminated in advance. The advantage of [2] is that all reasoning is reduced to reasoning in description logics (and, consequently, can be efficiently implemented especially for less expressive fragments of ALCQIO ). Our advantages are two-fold: the convenience of 2 2 representing actions as terms, and the expressive power of LC sc . Because C and ALCQIO (, , ¬, |, id) are equally expressive, there are some (situation suppressed) formulas in our SC that cannot be expressed in ALCQIO (that does not allow complex roles). In particular, [79] shows that ALCQI has the same complexity as C 2 , but ALCQI is strictly less expressive than C 2 : reflexive binary relations cannot be expressed in ALCQI . The more recent papers of the same research group continue to explore the research direction initiated in [2]: [59, 58] investigate complexity of planning in a description logic based action formalism, [45] attempts to solve the ramification problem when a TBox consists of general concept inclusion axioms 26

(GCIs), and it is no longer an acyclic TBox as in [2]. Propositional dynamic logic (PDL) was derived from dynamic logic and has several nice properties: PDL has the finite model property and is decidable [33]. Its satisfiability problem is E XP T IME-complete [19, 67]. It turned out to be popular not only for reasoning about regular programs, but also as a logic of action [24, 69]. It is well known that dynamic logic extends modal logic by associating to every action a, basic or complex, the modal operators [a] and a , thereby making it a multimodal logic. But, in PDL quantification over actions is not allowed. More recently, [12, 16, 15] adapt PDL to reasoning about actions by quantifying over actions and allowing for equality between actions. They use regression and formulate the successor state axioms to solve the frame problem similar to [70]. However, in their framework, action terms can be constants or variables only (the domain closure axiom for actions or another similar assumption is required) and all fluents are propositional only. In our paper, actions in BATs can be first-order terms, and the arity of each action function is no greater than two. Moreover, in our language, fluents can be dynamic concepts or dynamic roles, not just propositional statements. Also, as we mentioned above, it is possible to define complex Golog programs in our language. In [84], the combined dynamic description language PDLC has been proposed as an attempt to reason about dynamics in description logics. From the perspective of modal logic, [84] combines polymodal K with PDL and proves the decidability of the resulting hybrid logic. PDLC is somewhat related to the products of modal logics (see [21, 22, 23] for the definition and survey of results). The issues related to combining modal logics in a more general context are reviewed in [40]. The proposed dynamic description logic is intended to define and classify concepts referring to actions and to describe dynamically changing domains by means of varying extensions of concepts. A careful examination of the syntax of PDLC shows that actions can only be terms built from atomic actions (i.e., action variables) using standard dynamic logic constructors (composition, alternation, iteration) and from formulas using tests. Another restriction is that only concepts can change after executing an action: []C is a concept, where  is an action term and C is a concept, but there is no similar constructor for roles. However, for any atomic formula  which is either an ABox statement (a : C , or aRb, where a, b are object names) or a boolean combination of ABox statements, and for any action term , [] is also a formula. The main contribution of [84] is the proof of the theorem that the satisfiability problem for PDLC -formulas is decidable, but the complexity of the decision problem and the design of efficient decision algorithms are not explored. Our modified situation calculus can use action functions with arity no greater than two, and our dynamic roles can change after executing a sequence of actions too. However, we do not prove the decidability of the satisfiability problem for arbitrary formulas in our language. Moreover, we conjecture that this problem is undecidable in our language. From the positive side, we demonstrate that the executability and the projection problem are decidable for a wide class of queries and because these problems are the most essential in applications, the ability to solve these problems is sufficient for practical purposes. In [14, 13], the authors propose a logic that is similar to [3, 2, 84]. In the proposed logic, one not only can reason about complex actions similar to [84], but also can characterize actions by preconditions and conditional effects as in [2]. Also, a tableau algorithm for deciding satisfiability proposed in [14, 13] is based on an elaborated combination of previously known tableau algorithms. In our paper [32], we investigated not only regression, but also progression as an alternative approach to solving the projection problem. We considered a modified progression that is weaker than the classical progression [44] for an incomplete KB given local-effect SSAs defined in [47], . We proved that the modified progression is sound wrt the classical progression, and we also provided an algorithm to compute our progression for the case when the initial theory is a CNF-based KB (a set of disjunctions of equalitybased formulas). Recently, [82] considers a notion of strong progression, a slight variant of the classical 27

progression. In [82], it is shown that the strong progression is first-order definable for a BAT D with localeffect SSAs and the algorithm for computing progression was proposed for a special case of a BAT D with the so-called strong local-effect SSAs. Whether or not a similar result applies to our modified SC, i.e., 2 whether or not the strong progression is C 2 definable for a BAT D in LC sc with local-effect SSAs, requires further study. It is easy to check that in all special cases from [44, 77, 47] when the progression is FOL 2 definable, similar results can also be formulated for our LC sc simply because we restrict the language to two object variables only. There is research on updating in the description logic community that is somewhat related to computing progression in the SC. [46] considers update of an ABox in a DL with an acyclic TBox following [83] and also mentions that update can be applied to a boolean ABox formulated in C 2 , but their update is defined in terms of a conjunction of primitive fluent literals, i.e., it is different from classical progression (the exact relations remain unexplored). [26] uses a less expressive DL language DL-Lite, but defines update for the case when TBox consists of GCIs in comparison to acyclic TBox that is required in [46]. It is shown that the result of an update is always expressible by a DL-Lite ABox and a polynomial-time algorithm is provided that computes the update over a DL-Lite KB. The more recent paper [11] from the same research group proposes to use Golog-like programs to efficiently reason about actions over ontologies based on a functional view of ontology with cyclic TBox in the case when the ontology is expressed in DL-Lite. There are several other proposals to capture the dynamics of the world in the framework of description logics and/or its slight extensions. Similar to our paper [32], Drescher and Thielscher [17] explored reasoning about actions based on a description logic, but they concentrate on the fluent calculus [71] instead of the situation calculus. Instead of dealing with actions and the changes caused by actions, some of the approaches turned to extensions of description logics with temporal logics to capture the changes of the world over time [1, 4], and some others combined planning techniques with description logics to reason about tasks, plans and goals and exploit descriptions of actions, plans, and goals during plan generation, plan recognition, or plan evaluation [27]. Both [1] and [27] review several other related papers. Researchers also proposed to describe actions and the changes in terminological knowledge bases, closely related to description logics. For example, C. Kemke [39] describes action concepts by a set of parameters or object variables which refer to concepts in the object taxonomy, and precondition formulas as well as effect formulas describing how the world changes through actions (similar to STRIPS planning systems). In [7], all the actions of e-services are specified as constants, all the fluents of the system have only situation arguments, and BATs are translated under such assumptions into the description logic framework. It has a limited expressive power without using arguments of objects for actions and/or fluents: this may cause a blow-up of the knowledge base. In the future, we plan to extend this work along several directions. It would be interesting to see how our modified situation calculus can be used in real applications along the lines of SNAP, an e-commerce ontology developed at IBM for an automated system for recommending products and services in the domains of banking, insurance and telephony [60]. The most important direction for future research is an efficient implementation of practical scenarios 2 of reasoning in LC sc and in its fragments: an efficient implementation of a decision procedure for solving 2 the executability and projection problems. This procedure should handle the modified LC sc regression and perform efficient reasoning in DS0 . It should be straightforward to modify existing implementations of the regression operator for our purposes, but it is less obvious which reasoner will work efficiently on practical problems. There are several different directions that can be explored. First, according to [9] and Theorem 1, there exists an efficient algorithm for translating C 2 formulas to ALCQIO (, , ¬, |, id) formulas. Also, 2 if we consider fragments of LC sc introduced in Section 5.3 that guarantee a better complexity of solving 28

the projection problem (see Theorem 8), more specifically, a BAT D whose Dss and DT are ALCO (U )restricted, then a reasoning procedure working with DS0 should be able to handle the description logic ALCO (U ). Consequently, one can try to adapt tableaux-based decision procedures, such as those proposed in [73, 74], for (un)satisfiability checking in ALCQIO (, , ¬, |, id) and in ALCO (U ). Second, one can try to avoid any translation from C 2 to ALCQIO (, , ¬, |, id) and adapt resolution based automated theorem provers for the purposes of reasoning in DS0 [37, 62]. Although in general, the worst-case computational 2 complexity for the reasoning problems in LC sc or in its fragments is high, some practical scenarios may facilitate empirically efficient solutions to the projection and executability problems. Finally, we would like to explore how our version of the SC can accommodate events considered by John McCarthy in [54].

Acknowledgments
Thanks to the Natural Sciences and Engineering Research Council of Canada (NSERC) and to the Department of Computer Science of the University of Toronto for providing partial financial support.

Appendix A Semantics of Description Logics
In this appendix, we list the semantics of description logic syntax appearing in this paper. More details can be found in [4]. Name Top Bottom Nominal Negation Intersection Union Qualified at-least restriction Qualified at-most restriction Existential quantification Value restriction Syntax   {b} ¬C C1  C2 C1  C2 nR.C nR.C R.C R.C Interpretation I  bI  I I \C I I I C1  C2 I I C1  C2 {  I | |{1  I | (, 1 )  RI  1  C I }|  n} {  I | |{1  I | (, 1 )  RI  1  C I }|  n} {  I | 1 .(, 1 )  RI  1  C I } {  I | 1 .(, 1 )  RI  1  C I }

Figure 1: The semantics of some common description logic concept constructors.

29

Name Universal role Inverse Complement Intersection Union Role restriction Identity Reflexive-transitive closure Composition

Syntax U R- ¬R R1  R2 R1  R2 R |C id(C ) R R1  R2

Interpretation I × I {(1 ,  )  I × I | (, 1 )  RI } I × I \RI I I R1  R2 I I R1  R2 RI  I × C I {(,  )  I × I |   C I } I n n  0 (R ) {(1 , 2 )  I × I | I I   I .(1 ,  )  R1  (, 2 )  R2 }

Figure 2: The semantics of some common description logic role constructors. Name Concept inclusion Role inclusion Concept equality Role equality Concept assertion Role assertion Syntax C1  C2 R1  R2 C1  C2 R1  R2 C (b) R(b1 , b2 ) Interpretation I I C1  C2 I I R1  R2 I I C1 = C2 I I R1 = R2 bI  C I I I (bI 1 , b2 )  R

Figure 3: The semantics of terminological and assertional axioms.

B Proofs of Lemmas and Theorems
B.1 ALCQIO (, , ¬, |, id) and C 2 are Equally Expressive
In this subsection, we will provide detailed proof for Theorem 1. First, we prove the following two lemmas. Lemma 5 C 2 is as expressive as the language of ALCQIO (, , ¬, |, id). In addition, the translation leads to no more than a linear increase in the size of the translated formula. Proof of Lemma 5. Similar to the proof in [9], we present the translation function from ALCQIO (, , ¬, | , id) to C 2 in several variants that behave as follows:  x makes x be the free variable of the monadic predicate, which is produced for its argument concept, while  y makes the free variable be y . So, for an atomic concept AC  CN ,  x C = C (x), while  y C = C (y ). For an atomic role R  CN ,  x,y R produces a dyadic predicate R(x, y ), while  y,x R produces a dyadic predicate R(y, x). The translation functions  x ,  y , and  x,y are presented in the following two tables (Table 4 and Table 5).  y,x is obtained from  x,y by simultaneously exchanging all occurrences of x and y (whether free or bound).

30

Term C AC , AC  NC   {b} ¬C C1  C2 C1  C2 nR.C nR.C R.C R.C

x C AC (x) x=x ¬(x = x) x=b ¬ x C  x C1   x C2  x C1   x C2 n y.  x,y R   y C n y.  x,y R   y C y.  x,y R   y C y.  x,y R   y C

y C AC (y ) y=y ¬(y = y ) y=b ¬ y C  y C1   y C2  y C1   y C2 n x.  y,x R   x C n x.  y,x R   x C x.  y,x R   x C x.  y,x R   x C

Figure 4: A translation from ALCQIO (, , ¬, |, id) to C 2 for concept constructors. Term R R, R  NR U (universal role) id(C ) ¬R R |C R- R1  R2 R1  R2  x,y R R(x, y ) x = xy = y x = y  x C ¬ x,y R  x,y R   y C  y,x R  x,y R1   x,y R2  x,y R1   x,y R2

Figure 5: A translation from ALCQIO (, , ¬, |, id) to C 2 for role constructors. The translation function  can now be defined simply as  C =  x C for any concept C , def  R =  x,y R for any role R. Then, the translation of terminological and assertional axioms can be defined as: def  C (b) = x. x C  x = b for any concept assertion C (b); def  R(b, b ) = x.y. x,y R  x = b  y = b for any role assertion R(b, b ); def  C1  C2 = x. x (C1 )   x (C2 ) for any concept inclusion C1  C2 if any; def  C1  C2 = x. x (C1 )   x (C2 ) for any concept equality C1  C2 if any; def  R1  R2 = x.y. x,y (R1 )   x,y (R2 ) for any role inclusion R1  R2 if any. For any DL interpretation I , and the conventional FO interpretation I1 such that I1 = I and AC I1 = AC I (RI1 = RI , respectively ) for each atomic concept AC (atomic role R, respectively), it is straightforward to prove by induction that ()I = ( ())I1 for any formula  in ALCQIO (, , ¬, |, id). In addition, it is obvious that the translation from ALCQIO (, , ¬, |, id) to C 2 can be done in linear time and causes no more than a linear increase in the size of the translated formula according to the translation function  defined above. Lemma 6 The language of ALCQIO (, , ¬, |, id) is as expressive as C 2 . In addition, the translation 31
def

leads to no more than a linear increase in the size of the translated formula. Proof of Lemma 6. We proceed by structural induction on the syntax of formulas in C 2 with up to two free variables x and y . Table 6 lists all possible kinds of formulas (x) that have a single free variable x, and shows how each kind is translated into a concept C . Let NC = {AC | AC (x) or AC (y ) is a monadic predicate in language C 2 }, and NR = {R | R(x, y ) or R(y, x) is a dyadic predicate in language C 2 }. (x) AC (x), AC  NC R(x, b), R  NR R(b, x), R  NR R(x, x), R  NR x=b x=x ¬(x) C AC  R.{b}  R- .{b}  (R  id()). {b}  ¬C (x) ()  (x) (x)  (x) y.(x, y ) n y.(x, y ) n y.(x, y ) y.(x) n y.(x) n y.(x) C C()  C C  C R . nR . nR . C C C

Figure 6: A translation from C 2 to ALCQIO (, , ¬, |, id) for formulas with a single free variable x.

The translation of formulas with a single free variable y is identical, except for the case when (y ) is of the form x.(x, y ), (n x.(x, y ), and n x.(x, y ), respectively), when we need to invert the relationship represented by . So, it is translated as (R )- . ( n(R )- ., and n(R )- ., respectively). Formulae of the form (x, y ) with two free variables are translated to roles R relating x to y according to Table 7. (x, y ) R(x, y ), R  NR R(y, x), R  NR x=y ¬(x, y ) (x)  (y ) (x, y )  () (x, y )  (x) (x, y )  (y ) (x, y )  (x, y ) R R R- id() ¬R C × C R  R() R  (C × ) R  ( × C ) R  R

Figure 7: A translation from C 2 to ALCQIO (, , ¬, |, id) for formulas with two free variables.

In Table 7, notice that the role constructor C1 × C2 for any two concepts C1 and C2 is introduced in [9], I I whose semantics is defined as C1 × C2 given any interpretation I . It is easy to see that × can be replaced using the standard role constructors in ALCQIO (, , ¬, |, id), that is, 32

C1 × C2 = ((R  ¬R)|C1 )-  (R  ¬R)|C2 for any atomic role R  NR . When a formula () without free variables occurs as a conjunct, then the number of free variables (1 or 2) in its context determines its translation: a concept or a role. For the case when a concept is desired, we need a translated concept C() with the property that for any conventional C 2 interpretation I1 and a DL interpretation I such that I1 = I and AC I1 = AC I (RI1 = RI , respectively) for each atomic concept AC (atomic role R, respectively), I1 |= ()  true iff (C )I = I , and I1 |= ()  f alse iff (C )I = . Table 8 provides such translations. () true f alse C (b) R(b, b) R(b , b) b=b b = b ¬() ()  () x.(x) y.(y ) C()   (×{b}).C (×{b}).(R.{b}) (×{b }).(R.{b})   ¬C() R()  R() U.C U.C () x.() y.() n x.(x) n y.(y ) n x.() n y.() n x.(x) n y.(y ) n x.() n y.() C() C() C() nU.C nU.C C() C() nU.C nU.C C() C()

def

Figure 8: A translation from C 2 to ALCQIO (, , ¬, |, id) for formulas without free variables.

In contexts where we require roles, the translation is just R() = C() × C() . For any formula  in C 2 , the translation function transl can now be defined as: transl() = C if  has no free variables, or has only one free variable x or y ; and transl() = R if  has exactly two free variables. We can prove by induction that for any conventional C 2 interpretation I1 and a DL interpretation I such that I1 = I and AC I1 = AC I (RI1 = RI , respectively ) for each atomic concept AC (atomic role R, respectively), we have I1 |=   true iff (transl())I = I and I1 |=   f alse iff (transl())I =  for any (closed) sentence . It is obvious that the translation from C 2 to ALCQIO (, , ¬, |, id) can be done in linear time and causes no more than a linear increase in the size of the translated formula according to the translation function  defined above. Theorem 1 (Section 3.2) The description logic ALCQIO (, , ¬, |, id) and C 2 are equally expressive. In addition, translation in both directions leads to no more than a linear increase in the size of the translated formula. Proof of Theorem 1. It is a direct consequence of combining Lemma 5 and Lemma 6.

33

B.2 The Correctness of the Modified Regression Operator
In this subsection we provide a detailed proof for Theorem 3 in Section 5.1. Theorem 3 (Section 5.1) Suppose W is an LC sc regressable sentence with the background BAT D in C2 C2 language Lsc . Then, R[W ] is an Lsc sentence uniform in S0 and it is a C 2 sentence when the situation argument S0 is suppressed. Moreover, D |= W  R[W ]. Proof of Theorem 3. This theorem can be proved by induction on the number of regression steps. Base case: It takes one step to terminate the regression. If W is of the form A1 (t ) = A2 (t ) for some action function symbols A1 and A2 , then there are three sub-cases: (1) If A1 = A2 , R[W ] = f alse (by definition), which is uniform in S0 and is a C 2 sentence. Note that D |= W  f alse by the unique name axioms for actions in D . Hence, D |= R[W ]  W . (2) If A1 = A2 and A1 , A2 are constant action functions, R[W ] = true (by definition), which is uniform in S0 and is a C 2 sentence. Note that D |= W  true by the unique name axioms for actions in D . Hence, D |= R[W ]  W . |t|  (3) Otherwise, i.e., A1 = A2 and A1 , A2 are not constant action functions, then R[W ] = i =1 ti = ti (by |t|  definition), which is uniform in S0 and is a C 2 sentence. Note that D |= W  i =1 ti = ti by the unique name axioms for actions in D . Hence, D |= R[W ]  W . Otherwise, W is any other situation independent atom (including equality between object terms) or W is a concept or role uniform in S0 , so R[W ] = W (by definition), and it is obvious that R[W ] is uniform in S0 and is a C 2 formula when S0 is suppressed. Moreover, D |= R[W ]  W . Inductive step: Assume that our theorem is true for any regression that takes no more than n steps (n  1), now we prove it is true for any regression that takes n + 1 steps. There are several cases as follows. a. W is of the form P oss(A(t ),  ), for terms of sort action and situation, respectively, in LC sc . Assume that the precondition axiom for action function A(x) is of the form P oss(A(x), s)  A (x, s), where x is either empty, x, or x, y . There are four sub-cases: (a.1) If t = x, x , then D |= R[W ]  R[y.x = y  P oss(A(x, y ),  )] = y.x = y R[A (x, y,  )] (by the definition of R)  y.x = y  A (x, y,  ) (by the induction hypothesis) Moreover,  y.x = y  P oss(A(x, y ),  ) (by Dap )  P oss(A(x, x),  ) = W by the induction hypothesis that R[y.x = yA (x, y,  )] is uniform in S0 and is a C 2 formula (when S0 is suppressed), and so is R[W ]. (a.2) Similarly to case (a.1) above, we can prove that the theorem is true if t = y, y . (a.3) If t  {y, y, O , O, x , y, x }, we need to ensure the result of substituting t into the precondition axiom is still logically equivalent to the original one. It can be proved case by case. We will just show one case as an example, and the rest of the cases can be proved similarly. For example, when t is y, O x can only be x, y in the precondition axiom. It is obvious that P oss(A(y, x), s)  A (y, x, s) is logically equivalent to P oss(A(x, y ), s)  A (x, y, s) by renaming all x with y and all y with x (free or bound). Hence, we are able to substitute t into the precondition of P oss(A(y, x), s) without introducing new variables. Then, 34
2 2

D |= R[W ] =   =

R[A (y, O,  )] (by the definition of R) A (y, O,  ) (by the induction hypothesis) P oss(A(y, O ),  ) (by the renamed precondition axiom) W

Moreover, by the induction hypothesis that R[A (y, O,  )] is uniform in S0 and is a C 2 formula (when S0 is suppressed), and so is R[W ]. (a.4) Otherwise, i.e., if t either is empty or t  {O, x, x, y , x, O , O, y , O, O1 }, it is obvious that we can substitute t directly into the precondition axiom without causing any problem. That is, D |= R[W ] = R[A (t,  )] (by the definition of R)  A (t,  ) (by the induction hypothesis)  P oss(A(t),  ) (by Dap ) = W Again, by using the induction hypothesis, R[A (t,  )] is uniform in S0 and is a C 2 formula (when S0 is suppressed), and so is R[W ]. b. W is a defined dynamic concept of the form G(t,  ) for some object term t and ground situation term  , and there must be a TBox axiom for G of the form G(x, s)  G (x, s). Because of the restrictions 2 of the language LC sc , term t can only be a variable x, y or a constant. There are two sub-cases. (b.1) When t  {O, x}, it is obvious see that D |= R[W ] = R[G (t,  )] (by the definition of R)  G (t,  ) (by the induction hypothesis)  G(t,  ) (by the TBox axiom) = W Again, by using the induction hypothesis, R[G (t,  )] is uniform in S0 and is a C 2 formula (when S0 is suppressed), and so is R[W ]. (b.2) When t is variable y , then we can rename all x (y , respectively) in the TBox axiom with y (x, respectively), and still get an equivalent TBox axiom: G(y, s)  G (y, s). Then, D |= R[W ] = R[G (y,  )] (by the definition of R)  G (y,  ) (by the induction hypothesis)  G(y,  ) (by the renamed TBox axiom) = W Again, by using the induction hypothesis, R[G (y,  )] is uniform in S0 and is a C 2 formula (when S0 is suppressed), and so is R[W ]. c. W is a primitive dynamic concept (a dynamic role, respectively) of the form F (t1 , do(,  )) (or F (t1 , t2 , do(,  )), respectively) for some terms t1 (and t2 ) of sort object, ground term  of sort action and ground term  of sort situation. There must be an SSA for fluent F of the form F (x, do(a, s))  F (x, a, s), whose detailed syntax is Eq. (4). Because of the restriction of the 2 language LC sc , the terms t1 and t2 can only be a variable x, y or some constant O . In fact, the discussion of sub-cases for a primitive dynamic concept F (t1 , do(,  )) is very similar to the proof for defined concepts except that instead of using a TBox axiom, we will use the SSA of F . The discussion of sub-cases for a dynamic role F (t1 , t2 , do(,  )) is very similar to the proof for an atom of the form P oss(A(t1 , t2 ),  ) except that instead of using precondition axioms, we use the SSA of F . Since it is straightforward, details are omitted here. 35

d. W is not atomic, i.e., W is of the form W1  W2 , W1  W2 , ¬W  , or Qv.W  where Q represents a quantifier (including counting quantifiers) and v represents a variable symbol. This is the last case we need to consider for the inductive step. Therefore, it is obvious that there are four sub-cases depending on the different forms of W . Because the discussions for all sub-cases are very similar except that they use different logical constructors, we will provide details for one of the sub-cases, and omit the rest. As an example, we consider the sub-case that W is of the form W1  W2 . Then, D |= R[W ] = R[W1 ] R[W2 ] (by the definition of R)  W1  W2 (by the induction hypothesis) = W Again, by using the induction hypothesis, R[W1 ] and R[W2 ] are uniform in S0 and are both C 2 formulas (when S0 is suppressed), hence R[W ] is still uniform in S0 and is a C 2 formula (when S0 is suppressed). Overall, we proved that for any LC sc regressable sentence W with the background BAT D in language 2 C2 LC , R [ W ] is an L sentence uniform in S0 and it is a C 2 sentence when the situation argument S0 is sc sc suppressed. Moreover, D |= W  R[W ].
2

B.3 ALCO (U ) and F ODL are Equally Expressive
In this subsection, we prove Lemma 1 presented in Section 5.3. Notice that in the proof of this Lemma, we provide purely syntactic translation functions between ALCO (U ) and F ODL. Lemma 1 (Section 5.3) There are syntactic translations between F ODL and the DL language ALCO(U ), i.e., they are equally expressive. Moreover, such translations lead to no more than a linear increase in the size of the translated formula. Proof of Lemma 1. We first prove that there is a syntactic translation function from ALCO (U ) to F ODL. def A syntactic translation  from ALCO(U ) to F ODL for any concept C is defined as follows:  (C ) =  x (C ) for any concept C .  x () makes x be the free variable of the monadic predicate, which is produced for its argument concept (see Table 9). During translation we also need a variant of  ­  y () makes y be the free variable of the monadic predicate (see Table 9).

Then, the translation of terminological and assertional axioms can be defined as: def  (C (b)) =  (U.(C  {b})) for any concept assertion C (b); def  (R(b, b )) =  (U.((R.{b })  {b})) for any role assertion R(b, b ); def  (C1  C2 ) =  (¬U.(C1 ¬C2 )) for any concept inclusion axiom C1  C2 if there is any; def  (C1  C2 ) =  (U.((¬C1  C2 )  (¬C1  C1 ))) for any concept equality axiom C1  C2 if there is any. In addition, according to the definition of  in Table 9 and the fact that there are no nested appearances of  and  in DL KBs, it is obvious that the translation from ALCO (U ) to F ODL can be done in linear time and causes no more than a linear increase in the size of the translated formula. Now, we prove that there is a syntactic translation function from F ODL to ALCO (U ). A syntactic translation  from F ODL to ALCO (U ) for any formula   F ODL is defined in Table 10. 36

Term C AC , AC  NC   {b} ¬C1 C1  C2 C1  C2 R.C1 , R  NR R.C1 , R  NR U.C1 U.C1

 x (C ) AC (x) true f alse x=b ¬ x (C1 )  x (C 1 )   x (C 2 )  x (C 1 )   x (C 2 ) y. R(x, y )   y (C1 ) y. R(x, y )   y (C1 ) y. y (C1 ) y. y (C1 )

 y (C ) AC (y ) true f alse y=b ¬ y (C1 )  y (C 1 )   y (C 2 )  y (C 1 )   y (C 2 ) x. R(x, y )   x (C1 ) x. R(x, y )   x (C1 ) x. x (C1 ) x. x (C1 )

Figure 9: A syntactic translation from ALCO (U ) to F ODL.

In addition, it is obvious that the translation from F ODL to ALCO(U ) can be done in linear time and causes no more than a linear increase in the size of the translated formula according to the translation function  defined above.

B.4 Restricting Syntax of BATs to Gain Computational Advantages
In this subsection, we will prove Lemma 2 in Section 5.3. But first, we define an operator  on any LC sc regressable formula W , such that it will replace all atomic formula of the form A1 (t ) = A2 (t ) for some action terms A1 (t ) and A2 (t ) using the unique name axioms for actions in Duna for any given BAT D . 2 For any given BAT D and an LC sc regressable formula W in it, we define  recursively as follows: · If W is of the form A1 (t ) = A2 (t ) for some action terms A1 (t ) and A2 (t ) (i.e., equality between action terms), then  f alse if A1 = A2 ,     true if A1 = A2 and A1 , A2 are constant action functions, [W ] = |t|    ti = ti otherwise. 
i=1
2

Otherwise, if W is any other situation independent atom, then [W ] = W .

· Otherwise, if W is not atomic, i.e., W is of the form W1  W2 , W1  W2 , ¬W  , or Qv.W  where Q represents a quantifier (including counting quantifiers) and v represents a variable symbol, then [W1  W2 ] = [W1 ]  [W2 ], [W1  W2 ] = [W1 ]  [W2 ], [¬W  ] = ¬[W  ], [Qv.W  ] = Qv.[W  ].
2

Note that  can be considered as performing one step of LC sc regression on equalities between action terms C2 in the given Lsc regressable formula W , and it is easy to see that if W is uniform in situation S , then [W ] is still uniform in situation S . Moreover, we can prove the following property for . 37

 AC (x), AC (x) is atomic AC (y ), AC (y ) is atomic true f alse x = b, b is a constant y = b, b is a constant ¬, 1  2 1  2 y. R(x, y )  (y ), R  NR x. R(y, x)  (x), R  NR y. R(x, y )  (y ), R  NR x. R(y, x)  (x), R  NR y.(y ), (y ) has only one free variable y x.(x), (x) has only one free variable x y.(y ), (y ) has only one free variable y x.(x), (x) has only one free variable x

 () AC AC   {b} {b} ¬ ()  (1 )   (2 )  (1 )   (2 ) R. ((y )) R. ((x)) R. ((y )) R. ((x)) U. ((y )) U. ((x)) U. ((y )) U. ((x))

Figure 10: A syntactic translation from F ODL to ALCO(U ).
C Property 1 For any given BAT D and an LC sc regressable formula W in D , we have that [W ] is still Lsc regressable and D |= W  [W ].
2 2

Proof of Property 1. It is easy to prove by induction on the structure of W . Base case: If W is atomic, there are two sub-cases. (1) W is of the form A1 (t ) = A2 (t ) for some action terms A1 (t ) and A2 (t ). If A1 = A2 , we have D |= W  f alse by axioms in Duna , which is D |= W  [W ], since [W ] = f alse by the definition of ; else, if A1 = A2 and A1 , A2 are constant action functions, then by axioms in Duna , D |= W  true, |t|  therefore D |= W  [W ] according to the definition of ; otherwise, D |= W  i =1 ti = ti by axioms |t|  in Duna , which is D |= W  [W ], since [W ] = i =1 ti = ti by the definition of . Moreover, it is 2 obvious that [W ] is still LC sc regressable. (2) Otherwise, W is atomic and not of the above form. By the definition of , we have [W ] = W , hence 2 D |= W  [W ]. Moreover, it is obvious that [W ] is still LC sc regressable. Inductive step: W is not atomic and W is of the form W1W2 , W1W2 , ¬W  , or Qv.W  where Q represents a quantifier (including counting quantifiers) and v represents a variable symbol. Then for each sub-case, it is easy to prove that D |= W  [W ] by the induction hypothesis. For instance, if W is of the form W1  W2 , then D |= W = W1  W2  [W1 ]  [W2 ] (by the induction hypothesis) = [W1  W2 ] (by the definition of ) = [W ]. Moreover, it is obvious that [W ] is still LC sc regressable by the induction hypothesis that [W1 ] and [W2 ] C2 are both Lsc regressable. 38
2

It is easy to see that for other sub-cases, such as W1W2 , ¬W  , and Qv.W  where Q represents a quantifier (including counting quantifiers), the proof is very similar to the sub-case of W1  W2 and therefore details are omitted here. 2 C2 Overall, D |= W  [W ] for any LC sc regressable formula W in D and [W ] is still Lsc regressable. We prove the following lemma that will be useful when proving Lemma 2 in Section 5.3. Notice that the lemma says that the regression of W is the same as (not just equivalent to) the regression of [W ].
C Lemma 7 Consider any given BAT D , the LC sc regression operator R defined in Section 5.1, and any Lsc regressable formula W in D . Then, R[W ] = R[[W ]].
2 2

Proof of Lemma 7. It is easy to prove by induction on the structure of W . Base case: If W is atomic, there are two sub-cases. (1) W is of the form A1 (t ) = A2 (t ) for some action terms A1 (t ) and A2 (t ). If A1 = A2 , we have R[W ] = f alse by the definition of R in Section 5.1, and R[[W ]] = R[f alse] = f alse by the definitions of  and R, therefore, R[W ] = R[[W ]]; else, if A1 = A2 and A1 , A2 are constant action functions, by the definition of  and R, it is easy to see that R[W ] = R[[W ]] = true; |t|  otherwise, we have R[W ] = R[ i =1 ti = ti ] by the definition of R, |t|  and since R[[W ]] = R[[ i =1 ti = ti ]] by the definition of  and R, it is easy to see that R[W ] = R[[W ]]. (2) Otherwise, W is atomic and not of the above form, by the definition of , we have [W ] = W , hence R[W ] = R[[W ]]. Inductive step: W is not atomic and W is of the form W1W2 , W1W2 , ¬W  , or Qv.W  where Q represents a quantifier (including counting quantifiers) and v represents a variable symbol. Then for each sub-case, it is easy to prove that R[W ] = R[[W ]] by the induction hypothesis. For instance, if W is of the form W1  W2 , then R[W ] = = = = = R[W1 ] R[W2 ] R[[W1 ]] R[[W2 ]] R[[W1 ]  [W2 ]] R[[W1  W2 ]] R[[W ]]. (by the definition of R) (by the induction hypothesis) (by the definition ofR) (by the definition of )

It is easy to see that for other sub-cases, such as W1W2 , ¬W  , and Qv.W  where Q represents a quantifier (including counting quantifiers), the proof is very similar to the sub-case of W1  W2 and therefore details are omitted here. 2 Overall, R[W ] = R[[W ]] for any LC sc regressable formula W in D . Moreover, according to the definition of , it is straightforward to prove the following property of . Because the proof is rather obvious, it is omitted here. Property 2 Given any LC sc regressable formula W whose size is m, i.e., m = size(W ), it takes no more than m steps to obtain [W ], and the size of [W ] is no more than 3m. We also recursively define a one-step regression operator  for any LC sc regressable formula W , which C2 has no appearances of P oss, such that it performs one step of Lsc regression on each fluent in W . This operator  will also be useful in the proof of Lemma 2. The formal definition of  is as follows, where  denotes the term of sort situation, and  denotes the term of sort action. 39
2 2

· If W is not atomic, i.e., W is of the form W1  W2 , W1  W2 , ¬W  , or Qv.W  where Q represents a quantifier (including counting quantifiers) and v represents a variable symbol, then [W1  W2 ] = [W1 ]  [W2 ], [W1  W2 ] = [W1 ]  [W2 ], [¬W  ] = ¬[W  ], [Qv.W  ] = Qv.[W  ]. [W ] =

· Otherwise, W is an atom. There are several cases. a. If W is a situation independent atom, or W is a concept or role uniform in S0 , then W.

b. If W is a defined dynamic concept, so it has the form G(t,  ) for some object term t and situation term  , then there must be a TBox axiom for G of the form G(x, s)  G (x, s). Because of the 2 restrictions of the language LC sc , term t can only be a variable x, y or a constant. Then, we use the lazy unfolding technique as follows: [W ] = [G (t,  )] [G (y,  )] if t is not variable y, otherwise.

c. If W is a primitive dynamic concept (a dynamic role, respectively), it has the form F (t1 , do(,  )) or F (t1 , t2 , do(,  )) for some terms t1 (and t2 ) of sort object, term  of sort action and term  of sort situation. Then there must be an SSA Eq. (1) for fluent F , whose detailed syntax is Eq. (4). 2 Because of the restriction of the language LC sc , the terms t1 and t2 can only be a variable x, y or a constant O and  can only be an action function with no more than two arguments of sort object. Then, when W is a concept, [W ] = F (t1 , ,  ) F (y, ,  ) if t1 is not variable y, otherwise, i.e., if t1 = y ; if t1 = x, t2 = x, if t1 = y, t2 = y, if t1 = y, t2  {x, O } or t1 = O, t2 = x, otherwise.

Similar to the proof of Property 1, we can prove the following property for  by using induction on the structure of formulas.
C Property 3 For any given BAT D and an LC sc regressable formula W in D , we have that [W ] is still Lsc regressable and D |= W  [W ].
2 2

and, when W is a role,  (y )(x = y  F (x, y, ,  ))    (x)(y = x   (x, y, ,  )) F [W ] =   (y, t2, ,  )   F F (t1 , t2 , ,  )

In addition, also using induction on the structure of the formulas, it is straightforward to prove the following property, which is useful in the proof of Lemma 2. Because the proof is rather obvious, it is omitted here.
C Property 4 Consider a BAT D in the language of LC sc , if a given Lsc regressable formula W is uniform in do(, S ) for some ground action  and ground situation S , and predicate P oss does not appear in W , then [W ] is uniform in S and there is still no appearance of P oss.
2 2

Again, similar to the proof of Lemma 7, we can prove the following lemma.

40

C Lemma 8 Consider any given BAT D , the LC sc regression operator R defined in Section 5.1, and any Lsc regressable formula W in D . Then, R[W ] = R[[W ]].

2

2

Moreover, according to the definition of , it is straightforward to prove the following property of . Property 5 Consider any LC sc regressable formula W with a background BAT D . Assume that there is no appearance of P oss in W . Let m = size(W ), h = max(2, sizeSSA(D )), and h1 = maxG {size(G ) | G(x)  G (x) is a TBox axiom} if there are TBox axioms, or h1 = 0. Notice that h and h1 are fixed when D is given. Then, it takes no more than (h1 + 1)m steps to obtain [W ], whose size is no more than h(h1 + 1)m. We also have the following corollary of Lemma 7 and Lemma 8. Corollary 2 Consider any given BAT D , the LC sc regression operator R defined in Section 5.1, and any 2 LC regressable formula W in D . Then, R [ W ] = R[[[W ]]]. sc Proof of Corollary 2. By Lemma 7, R[[[W ]]] = R[[W ]], and by Lemma 8, R[[W ]] = R[W ]. Therefore, R[W ] = R[[[W ]]]. Now, we provide a detailed proof of Lemma 2 in Section 5.3. Lemma 2 (Section 5.3) Consider a BAT D in LC sc whose Dss and DT are ALCO (U )-restricted. Let W 2 be any LC regressable formula in D that is uniform in a ground situation S and has no appearance of sc P oss. Let n = sitLength(S ) and m = size(W ). Thene if W with the situation term S suppressed is in F ODL , there is a W in F ODL such that R[W ] is equivalent to W [S0 ]. It takes no more than c · n · size(W ) steps of deduction from R[W ] (with S0 suppressed) to find such W for some constant 2 2 number c. Moreover, size(W ) is in O (2hmn+3h n ) for some positive integer h. That is, the size of W is no more than exponential in the size of W . Proof of Lemma 2. Without loss of generality, we assume that there is no defined concept in W  F ODL. Otherwise, each defined concept will be replaced by its definitions from the TBox axioms with fixed steps 2 of LC sc regression. This can cause no more than a constant increase in the size of the original formula, because TBox is fixed (once D is given), TBox is acyclic, there are only finitely many TBox axioms and the size of the formula on the RHS of each TBox axiom is limited from above by a constant. We will first prove such a formula always exists, and then estimate the size of the formula. We define a notation for later convenience. If W is a formula uniform in any situation s, we denote the formula with all situation terms suppressed (if any) in W simply as W [-s] . Moreover, to simplify the presentation of the proof, below we write W1  W2 whenever |= W1  W2 for any formulas W1 and W2 . We will first prove the following more specific statement (Statement (1)) below wrt the given D : 2 "Consider any ground situation S and a LC sc regressable formula W with the background BAT D , where y x W is uniform in S and has no occurrences of P oss. If W [-S ] is in F ODL (F ODL , respectively), there is a y x formula  in F ODL (F ODL , respectively) such that R[W ] is equivalent to [S0 ]." The structure of our proof will consist of two nested proofs by induction, where the internal proof by induction will include an analysis of many sub-cases. The main proof will proceed by induction on the length of S , i.e., the number of actions involved in S . Inside the inductive step of this proof, we 2 will prove the statement by induction on the structure of a LC sc regressable formula W . In the latter, the most time consuming parts will be two cases: when W is a primitive dynamic concept (a fluent with one object argument and one situation argument); or, when W is of the form y.R(x, y, S )  W1(y )[S ] for 41
2 2 2

some dynamic role R (a fluent with two object arguments and one situation argument) and formula W1 . These two cases are laborious and require an analysis of numerous sub-cases depending on the structure of logical formulas in SSAs. Base case of the induction on the length of S : If S = S0 , then let  = W [-S0 ] , and it is trivial to see that Statement (1) is true. Inductive step of the induction on the length of S : 2 Now, without loss of generality, we assume that S = do(, S1) and Statement (1) is true for any LC sc regressable formula W  that is uniform in S1 and has no appearance of P oss. We prove Statement (1) for 2 any LC sc regressable formula W that is uniform in S and has no appearance of P oss by induction on the structure of W [-S ] . y x Since every formula in F ODL is a dual formula to a formula in F ODL , the proof for Statement (1) y [ -S ] [ -S ] x where W is in F ODL is "dual" to the proof for Statement (1) where W is in F ODL , in the sense that we only need to replace every appearance of x with y and y with x. Hence, below we will only provide x detailed proof for Statement (1) where W [-S ]  F ODL , and omit details for the proof of Statement (1) y [ -S ] where W  F ODL . In order to prove Statement (1) for ground situation S , we will prove Statement (1) and the following statement (Statement (2)) for S together using the induction proof on the structure of W : 2 "For any LC sc regressable formula W that is uniform in S (where S = do(, S1 )) and has no appearance of y y x x P oss, if W [-S ] is in F ODL (F ODL , respectively), then there is a formula  in F ODL (F ODL , respectively) which can be found in no more than c · size() steps for some constant positive integer c. Moreover, [S1 ] 2 is equivalent to [[W ]], and [S1 ] is LC sc regressable with no appearance of P oss." Base case of the induction on the structure of W [-S ] : x First, we consider when W [-S ] is in F ODL and is atomic. There are in total three cases (a-c) below.
x a. W [-S ] is either true or f alse. Then, [[W ]][-S1 ] is still true or f alse, which is in F ODL ; and, [ - S0 ] x (R[W ]) is still true or f alse, which is in F ODL. Hence, it is trivial to see that Statement (1) and Statement (2) hold. x b. W [-S ] is of the form x = b for some constant b. Then, [[W ]][-S1 ] is still x = b, which is in F ODL ; x and, (R[W ])[-S0 ] is still x = b, which is in F ODL . Again, it is trivial to see that Statement (1) and Statement (2) hold.

c. W [-S ] is a monadic predicate. Then, there are two sub-cases: x If W is situation-independent, then [[W ]][-S1 ] = W = W [-S ] , which is in F ODL ; and, [ - S0 ] [ -S ] x (R[W ]) =W =W , which is in F ODL. Again, it is trivial to see that Statement (1) and Statement (2) hold. Otherwise, W = F (x, S ) for some fluent F . Assume that fluent F (x, s) has an SSA of the form Eq. (4), whose context conditions (with situation terms suppressed) are all in F ODL. Depending on y x whether the context conditions are in F ODL (e.g., cases (1-12) in Table 11) or in F ODL (e.g., cases (1'-12') in Table 11), what variables appear in action functions and/or in the conditions (none, x only, y only, x and y ), and whether or not the variables are quantified, the SSA of F is
m+ m-

F (x, do(a, s)) 
i=1

+ i (x, a, s)  F (x, s) ¬(
j =1

- j (x, a, s)),

(9)

42

- where each + i (x, a, s) (j (x, a, s), respectively) is a formula that has the syntactic form of one of the following cases listed in Table 11 and the cases we described in Note 1. Recall that we prove this lemma for those SSAs which have ALCO(U )-restricted context formulas only. Notice that in y x Table 11,  (x) ( (y ), respectively) is a formula in F ODL (F ODL , respectively) with at most one free variable x (y , respectively). In cases (1) and (1'), A represents some constant action function. In cases (2-6) and (2'-6'), A represents some unary action function name. And, in cases (7-12) and (7'-12'), A represents some binary action function name. Moreover, in Table 11, [y.] represents that y. only appears when  (y ) has a free variable y . To show that we have exhausted all the possibilities, the cases we listed include some duplications. For example, case (6) in fact is the same as case (4) by renaming; case (1') is in fact the same as case (1), because [y.] (y ) is a formula in x x FDL (according to the definition of FDL ).

1 2 3 4 5 6 7 8 9 10 11 12

a = A   (x)[s] a = A(x)   (x)[s] x.a = A(x)   (x)[s] x(a = A(x))   (x)[s] y.a = A(y )   (x)[s] y (a = A(y ))   (x)[s] y.a = A(x, y )   (x)[s] y (a = A(x, y ))   (x)[s] x.y.a = A(x, y )   (x)[s] x.y (a = A(x, y ))   (x)[s] y.x(a = A(x, y ))   (x)[s] y (x(a = A(x, y )))   (x)[s]

1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12'

a = A  [y.] (y )[s] a = A(x)  [y.] (y )[s] x.a = A(x)  [y.] (y )[s] x(a = A(x))  [y.] (y )[s] y.a = A(y )   (y )[s] y (a = A(y ))  [y.] (y )[s] y.a = A(x, y )   (y )[s] y (a = A(x, y ))  [y.] (y )[s] x.y.a = A(x, y )   (y )[s] x.y (a = A(x, y ))  [y.] (y )[s] y.x(a = A(x, y ))   (y )[s] y (x(a = A(x, y )))  [y.] (y )[s]

- Figure 11: Some possible syntactic forms for + i (x, a, s) or j (x, a, s) in Eq. (9)

Note 1 Let O , O1 and O2 be some constant objects. There are also cases for a = A(O ) (or a = - A(O1 , O2), respectively) in + i and/or j in the SSA of F , which can be proved similarly to the cases in Table 11 where a = A; there are also cases for a = A(O1 , x) (or a = (x, O1 ), respectively) - in + i and/or j in the SSA of F , which can be proved similarly to the cases in Table 11 where - a = A(x); there are also cases for a = A(O1 , y ) (or a = (y, O1), respectively) in + i and/or j in the SSA of F , which can be proved similarly to the cases in Table 11 where a = A(y ); there are also - cases for a = A(y, x) in + i and/or j in the SSA of F , which can be proved similarly to the cases in Table 11 where a = A(x, y ). Notice that using the unique name axioms for object constants, we can replace all (in)equalities between object constants with either true or f alse in the resulting 2 formula that is equivalent to [[W ]] for any LC sc regressable formula W . Moreover, such deduction takes at most a constant number of steps wrt the size of the resulting formula.
- We first prove case by case for all possible syntactic forms of + i (x, , S1 ) (j (x, , S1 ), respec- x tively), that there exists some i+ (or j , respectively) in F ODL for any i (j , respectively) such + - + that i [S1 ] (j [S1 ], respectively) is logically equivalent to [i (x, , S1 )] ([- j (x, , S1 )], respectively). Moreover, finding the equivalent formula takes a fixed number of steps of deduction w.r.t. - to the size of [+ i (x, , S1 )] ([j (x, , S1 )], respectively).

43

Here is one trivial sub-case: if the function name of  is not A, then in each of the aforementioned - x cases (1-12), (1'-12') and Note 1,  of each formula (+ i or j ) equals f alse, which is still in F ODL . Hence, below we only discuss the condition that  has the same function name (with the same number of arguments) as the given action function name in each case, and we let O , O1 and O2 be x some constants. Notice that in case (1), since the context condition  (x) is in F ODL ,  (x)[S1 ] does not contain any equality between action terms, hence [ (x)[S1 ]] =  (x)[S1 ]. The same reasoning will be used in other cases, and detailed explanations are omitted to avoid repetition. [ = A   (x)[S1 ]] = [ = A]  [ (x)[S1 ]]] = true   (x)[S1 ]   (x)[S1 ]. x Clearly,  (x) is in F ODL , which takes at most one step of logical deduction to find the equivalent formula. (1') a = A  [y.] (y )[s] x Because [y.] (y ) is in fact in F ODL , the proof for (1') is the same as for (1). (2) a = A(x)   (x)[s] Assume that  = A(O ), then [ = A(x)   (x)[S1 ]] = [A(O ) = A(x)]   (x)[S1 ] = (x = O )   (x)[S1] = (x = O   (x))[S1 ]. y x Clearly, given that  (x) is in F ODL , we have that x = O   (x) is in F ODL , and this takes no steps of logical deduction. (2') a = A(x)  [y.] (y )[s] x Because [y.] (y ) is in fact in F ODL , the proof for (2') is the same as for (2). (3) x.a = A(x)   (x)[s] Assume that  = A(O ), then [x. = A(x)   (x)[S1 ]] = x.[A(O ) = A(x)   (x)[S1 ]] = (x.x = O   (x))[S1 ]. x x Clearly, the closed formula (x.x = O   (x)) is in F ODL . Because x = O   (x) is in F ODL , x x then by definition, (y.y = O (y )) (denoted as ) is in F ODL. Again by the definition of F ODL, x [y.] (i.e., (x.x = O   (x))) is in F ODL . It takes no steps of logical deduction. (3') x.a = A(x)  [y.] (y )[s] Note that [y.] (y ) has no free variable x, hence x is in fact only quantified over a = A(x), hence case (3') is equivalent to case (4') below. (4) x(a = A(x))   (x)[s] Assume that  = A(O ), then [x( = A(x))   (x)[S1 ]] = [x(A(O ) = A(x))   (x)[S1 ]] = (x(x = O )   (x))[S1 ]. x x Because x(x = O ) and  (x) are in F ODL , x(x = O )   (x) is in F ODL . It takes no steps of logical deduction. (4') x(a = A(x))  [y.] (y )[s] x Because [y.] (y ) is in fact in F ODL , case (4') is a special case of case (2). (5) y.a = A(y )   (x)[s] 44 (1) a = A   (x)[s] Assume that  = A, then

[y. = A(y )   (x)[S1]]  [y (A(O ) = A(y ))   (x)[S1]] = y (y = O )   (x)[S1 ] = (y (y = O )   (x))[S1 ]. x Clearly, the closed formula y (y = O )   (x) is in F ODL . It takes one step of logical deduction to minimize the quantification scope of y . (5') y.a = A(y )   (y )[s] Assume that  = A(O ), then [y. = A(y )   (y )[S1]] = [y.A(O ) = A(y )   (y )[S1]] = y.[A(O ) = A(y )   (y )[S1]] = y.y = O   (y )[S1] = (y.y = O   (y ))[S1]. y y x  (y ) is in F ODL, hence y = O   (y ) is in F ODL and y.y = O   (y ) is in F ODL . It takes no steps of logical deduction. (6) y (a = A(y ))   (x)[s] Case (6) is equivalent to case (5), because in case (5) the quantification range of y is in fact only x over a = A(y ). Hence, the statement is true for case (6) by the definition of F ODL . x (6') y (a = A(y ))  [y.] (y )[s] Because [y.] (y ) is in F ODL , case (6') is a special case of (6). (7) y.a = A(x, y )   (x)[s] Assume that  = A(O1 , O2 ), then [y. = A(x, y )   (x)[S1 ]] = [y.A(O1 , O2 ) = A(x, y )   (x)[S1 ]] = (y.x = O1  y = O2   (x))[S1 ]  (x = O1 y (y = O2 )   (x))[S1 ]. x x Clearly, given that  (x) is in F ODL , we have that x = O1 y (y = O2 )   (x) is in F ODL by the x definition of F ODL . It takes one step of deduction to minimize the quantification scope of y . (7') y.a = A(x, y )   (y )[s] Assume that  = A(O1 , O2 ), then [y. = A(x, y )   (y )[S1]] = [y.A(O1 , O2 ) = A(x, y )   (y )[S1]] = (y.x = O1  y = O2   (y ))[S1]  (x = O1  (y.y = O2   (y )))[S1 ]. y x Clearly, given that  (y ) is in F ODL , we have that x = O1 (y.y = O2  (y )) is in F ODL by the x definition of F ODL . It takes one step of deduction to minimize the quantification scope of y . (8) y (a = A(x, y ))   (x)[s] Case (8) is equivalent to case (7), because in case (7) the quantification range of y is in fact only over a = A(x, y ). (8') y (a = A(x, y ))  [y.] (y )[s] x Because [y.] (y ) is in F ODL , case (8') is a special case of case (8). (9) x.y.a = A(x, y )   (x)[s] Case (9) is equivalent to case (10), because in case (9) the quantification range of y is in fact only over a = A(x, y ). (9') x.y.a = A(x, y )   (y )[s] Case (9') is equivalent to case (11'), because in case (9') the quantification range of x is in fact only over a = A(x, y ). Assume that  = A(O ), then 45

[x.y ( = A(x, y ))   (x)[S1]] = [x.y ( = A(x, y ))   (x)[S1]] = [x.y (A(O1 , O2 ) = A(x, y ))   (x)[S1]] = (x.y (x = O1  y = O2 )   (x))[S1 ]  (x.x = O1 y (y = O2 )   (x))[S1 ]. x It is easy to see that x.x = O1 y (y = O2 )   (x) is in F ODL , and it takes one step of logical deduction. (10') x.y (a = A(x, y ))  [y.] (y )[s] x Because [y.] (y ) is in F ODL , case (10') is a special case of case (10). (11) y.x(a = A(x, y ))   (x)[s] Case (11) is equivalent to case (12), because in case (11) the quantification range of y is in fact only over a = A(x, y ). (11') y.x(a = A(x, y ))   (y )[s] Assume that  = A(O1 , O2 ), then [y.x( = A(x, y ))   (y )[S1]] = [y.x(A(O1 , O2 ) = A(x, y ))   (y )[S1]] = y.x(x = O1  y = O2 )   (y )[S1]  (y.x(x = O1 )  y = O2   (y ))[S1 ]. x It is easy to see that y.x(x = O1 )  y = O2   (y ) is in F ODL , and it takes one step of logical deduction to minimize the scope of x. (12) y (x(a = A(x, y )))   (x)[s] Assume that  = A(O1 , O2 ), then [y (x( = A(x, y )))   (x)[S1]] = [y (x(A(O1 , O2) = A(x, y ))   (x)[S1]] = y (x(x = O1  y = O2 ))   (x)[S1 ]  (y (x(x = O1 )  y = O2 )   (x))[S1 ]. x It is easy to see that y (x(x = O1 )  y = O2)   (x) is in F ODL , and it takes one step of logical deduction to minimize the scope of x. (12') y (x(a = A(x, y )))  [y.] (y )[s] x Because [y.] (y ) is in F ODL , case (12') is a special case of case (12). When a is substituted by a ground action  and s is substituted by a ground situation S1 , by the definition

(10) x.y (a = A(x, y ))   (x)[s] Assume that  = A(O1 , O2 ), then

46

of regression,  and ,
[[F (x, S )]] = [[F (x, do(, S1 ))]] 
m+ i=1 m- j =1

= 
m+

+ i (x, , S1 )  F (x, S1 ) ¬( (by the definition of ),
m-

 - j (x, , S1 ))



=
i=1

[+ i (x, , S1 )]  F (x, S1 ) ¬(
j =1

[- j (x, , S1 ))]

(by the definition of ),
m+ m- + i (x)[S1 ]  F (x, S1 ) ¬( i=1 j =1 - j (x)[S1 ]



(according to the proof of cases (1-12,1'-12')), 
m- - + j (x))[S1 ], ( i (x)  F (x) ¬( j =1 i=1 m+

(10)

- x where each i+ (x) (j (x), respectively) is a formula in F ODL that has at most one free variable x, and + - [ - S1 ] [ - S1 ] it is logically equivalent to [i (x, , S1 )] ([j (x, , S1 )] , respectively). Clearly, the formula x on the RHS of Eq. (10) is regressable, uniform in S1 , and in F ODL (with S1 suppressed) according to x the definition of the set F ODL . Moreover, it takes only a constant number of steps wrt the size of the resulting formula to find the equivalent formula. Then, using the induction hypothesis for situation S1 and Corollary 2 (i.e., R[F (x, S )] = R[[[F (x, S )]]]), we have (R[F (x, do(, S1 ))])[-S0 ] will still be x equivalent to some formula in F ODL . y Similarly, we can prove Statements (1) and (2) for W [-S ] that is in F ODL and is atomic. [ -S ] Inductive step of the induction on the structure of W : Now, we complete our remaining cases when W (hence, W [-S ] ) is not atomic. There are in total four cases (a-d) as follows. x a. W [-S ] is of the form ¬W1 , where W1  F ODL . Then, it is obvious that W = ¬W1 [S ], and [[W ]] = ¬[[W1 [S ]]]. Moreover, by the induction x hypothesis on the structure of W , there is a formula 1  F ODL such that [[W1 [S ]]]  1 [S1 ], which is regressable, uniform in S1 , has no appearance of P oss and can be found c · size(1 ) for some integer c. Hence, [[W ]]  ¬1 [S1 ], and Statement (2) is true for W . Then, according to Corollary 2, R[W ] = R[[[W ]]]  R[¬1 [S1 ]]. Next, by the induction hypothesis on S1 , x R[W ][-S0 ] is equivalent to some formula in F ODL , and it is easy to see that Statement (1) is true for W that is uniform in situation S . x b. W [-S ] is of the form W1  W2 or of the form W1  W2 , where W1 , W2  F ODL . [ -S ] Then, if W is of the form W1  W2 , it is obvious that W = (W1  W2 )[S ], so [[W ]] = [[W1 [S ]]]  [[W2 [S ]]]. By the induction hypothesis on the structure of W , there are formulas x 1 , 2  F ODL such that [[W1 [S ]]]  1 [S1 ] and [[W2 [S ]]]  2 [S1 ], which are regressable, uniform in S1 , has no appearance of P oss and can be found in c · (size(1 ) + size(2 ) + 1) steps for some integer c. Hence, [[W ]]  (1  2 )[S1 ], and Statement (2) is true for W . Then, according to Corollary 2, R[W ] = R[[[W ]]]  R[(1  2 )[S1 ]]. Next, by the induction hypothesis on S1 , x R[W ][-S0 ] is equivalent to some formula in F ODL , and it is easy to see that Statement (1) is true for

47

W that is uniform in S . It is very similar to prove that Statements (1) and (2) are true when W [-S ] is of the form W1  W2 , and details are omitted here.
y c. W [-S ] is of the form [y.]W1 (y ) or [y.]W1 (y ), where W1 (y ) is in F ODL . [ -S ] Then, if W is of the form [y.]W1 (y ), [[W ]] = [y.][[W1 (y )[S ]]]. By the induction hypothy esis on the structure of W , there is a formula 1 (y )  F ODL such that [[W1 (y )[S ]]]  1 (y )[S1 ], which is regressable, uniform in S1 , has no appearance of P oss and can be found in c · size(1 (y )) steps for some integer c. Hence, [[W ]]  ([y.]1 (y ))[S1 ], and Statement (2) is true for W . Then, according to Corollary 2, R[W ] = R[[[W ]]]  R[([y.]1 (y ))[S1 ]]. Next, by the induction x hypothesis on S1 , R[W ][-S0 ] is equivalent to some formula in F ODL , and it is easy to see that Statement (1) is true for W that is uniform in situation S . It is very similar to prove that Statements (1) and (2) are true when W [-S ] is of the form [y.]W1 (y ), and details are omitted here.

d. W [-S ] is of the form y.R(x, y )  W1(y ) or y.R(x, y )  W1 (y ), where R(x, y ) is a dynamic predicate y and W1 (y ) is in F ODL . We first consider the case when W [-S ] is of the form y.R(x, y )W1 (y ). Then, W = y.R(x, y )[S ] W1 (y )[S ], and there are two sub-cases. (d.1) If R is a situation-independent predicate, then [[W ]] = [y.]R(x, y )  [[W1 (y )[S ]]]. By y the induction hypothesis on the structure of W , there is a formula 1 (y )  F ODL such that [[W1 (y )[S ]]]  1 (y )[S1 ], which is regressable, uniform in S1 , has no appearance of P oss and can be found in c · size(1 (y )) steps for some integer c. Hence, [[W ]]  ([y.]R(x, y )  1 (y ))[S1], and Statement (2) is true for W . Then, according to Corollary 2, R[W ] = R[[[W ]]]  R[([y.]R(x, y )  1 (y ))[S1 ]]. Next, by the induction hypothesis on S1 , R[W ][-S0 ] is equivalent to x some formula in F ODL , and it is easy to see that Statement (1) is true for W that is uniform in situation S . (d.2) Otherwise, if R is a fluent, then then [[W ]] = [y.][[R(x, y, s)]][[W1 (y )[S ]]]. Moreover, we need to consider different sub-cases for the SSA of R. Notice that according to the definition of a Dss that is ALCO (U )-restricted, all dynamic roles are both ALCO(U )-restricted and context-free. So, y x depending on whether the context conditions are in F ODL (e.g., cases (1-16) in Table 12) or F ODL (e.g., cases (1'-16') in Table 12), what variables appear in action functions and/or in the conditions (none, x only, y only, x and y ), and whether or not the variables are quantified, the SSA of R is
m+ m-

R(x, y, do(a, s)) 
i=1

+ i (x, y, a)  R(x, y, s) ¬(
j =1

- j (x, y, a)),

(11)

- where each + i (x, y, a) (j (x, y, a), respectively) is a situation-independent formula whose syntactic form is one of the following cases listed in Table 12 and the cases we described in Note 2. Recall that we prove the lemma for those SSAs which have ALCO(U )-restricted context formulas only. y x Notice that in Table 12,  (x) ( (y ), respectively) is a formula in F ODL (F ODL , respectively) with at most one free variable x (y , respectively). In cases (1) and (1'), A represents some constant action function. In cases (2-7) and (2'-7') , A represents some unary action function name. And, in cases (8-16) and (8'-16'), A represents some binary action function name. Again, to show that we have exhausted all the possibilities, the cases we listed in Table 12 still include some other duplications. For example, case (6) in fact is the same as case (3) by renaming.

48

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16

a = A   (x) a = A(x)   (x) x(a = A(x))   (x) x.a = A(x)   (x) a = A(y )   (x) y (a = A(y ))   (x) y.a = A(y )   (x) a = A(x, y )   (x) x(a = A(x, y ))   (x) x.a = A(x, y )   (x) y (a = A(x, y ))   (x) y.a = A(x, y )   (x) y (x(a = A(x, y )))   (x) y.x(a = A(x, y ))   (x) x.y (a = A(x, y ))   (x) x.y.a = A(x, y )   (x)

1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12' 13' 14' 15' 16'

a = A   (y ) a = A(x)   (y ) x(a = A(x))   (y ) x.a = A(x)   (y ) a = A(y )   (y ) y (a = A(y ))   (y ) y.a = A(y )   (y ) a = A(x, y )   (y ) x(a = A(x, y ))   (y ) x.a = A(x, y )   (y ) y (a = A(x, y ))   (y ) y.a = A(x, y )   (y ) y (x(a = A(x, y )))   (y ) y.x(a = A(x, y ))   (y ) x.y (a = A(x, y ))   (y ) x.y.a = A(x, y )   (y )

- Figure 12: Some possible syntactic forms for + i (x, y, a) or j (x, y, a) in Eq. (11)

y x Note 2 For any formula 1 (x) (1 (y ), respectively) in F ODL (F ODL , respectively), there are also cases where the context conditions are either of the form [x.]1 (x) or of the form [y.]1 (y ). y x However, [x.]1 (x) (or [y.]1 (y ), respectively) is a formula in both F ODL and F ODL , which can y x be considered as a special case of the form  (x)  F ODL or  (y )  F ODL . Hence the proof of such cases where the context conditions are either of the form [x.]1 (x) or [y.]1 (y ) are the same as as the cases where the context conditions are of the form  (x) (or  (y ), either one is fine) in Table 12. Moreover, let O , O1 and O2 be some constants. There are also cases for a = A(O ) (or - a = A(O1 , O2 ), respectively) in + i and/or j in the SSA of R, which can be proved similarly to the cases in Table 12 where a = A; there are also cases for a = A(O1 , x) (or a = (x, O1 ), respectively) - in + i and/or j in the SSA of R, which can be proved similarly to the cases in Table 12 where - a = A(x); there are also cases for a = A(O1 , y ) (or a = (y, O1), respectively) in + i and/or j in the SSA of R, which can be proved similarly to the cases in Table 12 where a = A(y ); there are also - cases for a = A(y, x) in + i and/or j in the SSA of R, which can be proved similarly to the cases in Table 12 where a = A(x, y ). Notice that using unique name axioms for object constants, we can replace all (in)equalities between object constants with either true or f alse in the resulting formula 2 that is equivalent to [[W ]] for any LC sc regressable formula W . Moreover, such deduction takes at most linear number of steps in the size of the resulting formula. - We first show that for any case in Table 12, [+ i (x, y, )] ([j (x, y, )], respectively) results in a x formula that is equivalent to some formula of the form ( (x)   (y )) for some  (x)  F ODL and y  (y ))  F ODL. In particular, we will see in the proof below for all cases in Table 12, the resulting formulas are in one of the four specific forms of  (x)   (y ):  (x) (let eta(y ) be true),  (y ) (let nu(x)) be true),  (x)  y = O for some constant O , or x = O   (y ) for some constant O .

From now on, without particular emphasis, all the cases we discuss below are the cases in Table 12. 49

Moreover, for similar proofs, some detailed steps are skipped. Here is one trivial sub-case: if the function name of  is not A, then in each of the aforementioned - cases (1-16), (1'-16') and in Note 2,  of each formula (+ i or j ) equals f alse, which is still in x F ODL . Hence, below we only discuss the condition that  has the same function name (with the same number of arguments) as the given action function name in each case, and we let O , O1 and O2 be some constants. (1) a = A   (x) Assume that  = A, then [ = A   (x)] = true   (x). Clearly, true   (x) is of the form  (x)   (y ) (let  (x) be  (y ) and let  (y ) be true). (1') a = A   (y ) Assume that  = A, then

[ = A   (y )] = true   (y ). Clearly, true   (y ) is of the form  (x)   (y ) (let  (x) be true and let  (y ) be  (y )). (2) a = A(x)   (x) Assume that  = A(O ), then [ = A(x)   (x)] = [A(O ) = A(x)]   (x) = (x = O )   (x). x Clearly, x = O  (x) is in F ODL and is of the form  (x)  (y ) (let  (x) be x = O  (x) and let  (y ) be true). (2') a = A(x)   (y ) Assume that  = A(O ), then [ = A(x)   (y )] = [A(O ) = A(x)]   (y ) = (x = O )   (y ). Clearly, x = O   (y ) is of the form  (x)   (y ) (let  (x) be x = O and let  (y ) be  (y )). (3) x(a = A(x))   (x) Assume that  = A(O ), then [x( = A(x))   (x)] = [x(A(O ) = A(x))]  [ (x)] = x(x = O )   (x). Clearly, x(x = O ) (x) is of the form  (x) (y ) (let  (x) be  (x) and let  (y ) be x(x = O )). (3') x(a = A(x))   (y ) Assume that  = A(O ), then [x( = A(x))   (y )] = [x(A(O ) = A(x))]  [ (y )] = x(x = O )   (y ). Clearly, x(x = O )   (y ) is of the form  (x)   (y ) (let  (x) be true and let  (y ) be x(x = O )   (y )). (4) x.a = A(x)   (x) Assume that  = A(O ), then [x. = A(x)   (x)] = x.[A(O ) = A(x)]  [ (x)] = x.x = O   (x). Clearly, x.x = O   (x) is of the form  (x)   (y ) (let  (x) be true and let  (y ) be x.x = O   (x)). 50

(4') x.a = A(x)   (y ) Case (4') is equivalent to case (3'), because in case (4') the quantification range of x is in fact only over a = A(x). (5) a = A(y )   (x) (The proof is similar to that of case (2') above.) Assume that  = A(O ), then [ = A(y )   (x)] = y = O   (x). Clearly, y = O   (x) is of the form  (x)   (y ) (let  (x) be  (x) and let  (y ) be y = O ). (5') a = A(y )   (y ) (The proof is similar to that of case (2) above.) Assume that  = A(O ), then [ = A(y )   (y )] = y = O   (y ). y Clearly, y = O   (y ) is in F ODL and is of the form  (x)   (y ) (let  (y ) be y = O   (y ) and let  (x) be true). (6) y (a = A(y ))   (x) (The proof is similar to that of case (3') above.) Assume that  = A(O ), then [y ( = A(y ))   (x)] = y (y = O )   (x). Clearly, y (y = O )   (x) is of the form  (x)   (y ) (let  (y ) be true and let  (x) be y (y = O )   (x)). (6') y (a = A(y ))   (y ) (The proof is similar to that of case (3) above.) Assume that  = A(O ), then [y ( = A(y ))   (y )] = y (y = O )   (y ). Clearly, y (y = O ) (y ) is of the form  (x) (y ) (let  (y ) be  (y ) and let  (x) be y (y = O )). (7) y.a = A(y )   (x) (The proof is similar to that of case (3) above.) Case (7) is equivalent to case (6), because in case (7) the quantification range of y is in fact only over a = A(y ). (7') y.a = A(y )   (y ) (The proof is similar to that of case (4) above.) Assume that  = A(O ), then [y. = A(y )   (y )] = y.y = O   (y ). Clearly, y.y = O (y ) is of the form  (x) (y ) (let  (y ) be true and let  (x) be y.y = O (y )). (8) a = A(x, y )   (x) Assume that  = A(O1 , O2 ), then [ = A(x, y )   (x)] = [A(O1 , O2 ) = A(x, y )   (x)] = y = O2  x = O1   (x). Clearly, y = O2  x = O1   (x) is of the form  (x)   (y ) (let  (y ) be y = O2 and let  (x) be x = O1   (x)). (8') a = A(x, y )   (y ) Assume that  = A(O1 , O2 ), then [ = A(x, y )   (y )] = [A(O1 , O2 ) = A(x, y )   (y )] = x = O 1  y = O 2   (y ). Clearly, x = O1  y = O2   (y ) is of the form  (x)   (y ) (let  (y ) be y = O2   (y ) and let  (x) be x = O1 ). (9) x(a = A(x, y ))   (x)

51

[x( = A(x, y ))   (x)] = [x(A(O1 , O2 ) = A(x, y ))   (x)] = x(x = O1  y = O2 )   (x)  y = O2 x(x = O1 )   (x). Clearly, y = O2 x(x = O1 )   (x) is of the form  (x)   (y ) (let  (y ) be y = O2 and let  (x) be x(x = O1 )   (x)). (9') x(a = A(x, y ))   (y ) Assume that  = A(O1 , O2 ), then [x( = A(x, y ))   (y )] = (x(x = O1  y = O2 )   (y ))  x(x = O1 )  y = O2   (y ). Clearly, x(x = O1 )  y = O2   (y ) is of the form  (x)   (y ) (let  (y ) be y = O2   (y ) and let  (x) be x(x = O1 )). (10) x.a = A(x, y )   (x) Assume that  = A(O1 , O2 ), then [x. = A(x, y )   (x)] = (x.x = O1  y = O2   (x))  y = O2 x.x = O1   (x). Clearly, y = O2 x.x = O1   (x) is of the form  (x)   (y ) (let  (x) be true and let  (y ) be y = O2 x.x = O1   (x)). (10') x.a = A(x, y )   (y ) Case (10') is equivalent to case (9'), because in case (10') the quantification range of x is in fact only over a = A(x, y ). (11) y (a = A(x, y ))   (x) Assume that  = A(O1 , O2 ), then [y ( = A(x, y ))   (x)] = (y (x = O1  y = O2 )   (x))  y (y = O2 )  x = O1   (x). Clearly, y (y = O2 )  x = O1   (x) is of the form  (x)   (y ) (let  (y ) be true and let  (x) be y (y = O2 )  x = O1   (x)). (11') y (a = A(x, y ))   (y ) Assume that  = A(O1 , O2 ), then [y ( = A(x, y ))   (y )] = (y (x = O1  y = O2 )   (y ))  y (y = O2 )  x = O1   (y ). Clearly, y (y = O2 )  x = O1   (y ) is of the form  (x)   (y ) (let  (y ) be  (y ) and let  (x) be y (y = O2 )  x = O1 ). (12) y.a = A(x, y )   (x) Case (12) is equivalent to case (11), because in case (12) the quantification range of y is in fact only over a = A(x, y ). (12') y.a = A(x, y )   (y ) Assume that  = A(O1 , O2 ), then [y. = A(x, y )   (y )] = (y.x = O1  y = O2   (y ))  x = O1 y.y = O2   (y ). Clearly, x = O1 y.y = O2   (y ) is of the form  (x)   (y ) (let  (x) be x = O1 and let  (y ) be y.y = O2  (y )). (13) y (x(a = A(x, y )))   (x) Assume that  = A(O1 , O2 ), then

52

[y (x( = A(x, y )))   (x)] = y (x(x = O1  y = O2 ))   (x) = y (x(x = O1  y = O2 ))   (x)  x(x = O1 ) y (y = O2 )   (x). Clearly, x(x = O1 )y (y = O2 ) (x) is of the form  (x) (y ) (let  (x) be y (y = O2 ) (x) and let  (y ) be x(x = O1 )). (13') y (x(a = A(x, y )))   (y ) Assume that  = A(O1 , O2 ), then [y (x( = A(x, y )))   (y )] = y (x(x = O1  y = O2 ))   (y ) = y (x(x = O1  y = O2 ))   (y ). Clearly, y (x(x = O1  y = O2 ))   (y ) is of the form  (x)   (y ) (let  (x) be true and let  (y ) be y (x(x = O1  y = O2 ))   (y )). (14) y.x(a = A(x, y ))   (x) Case (14) is equivalent to case (13), because in case (14) the quantification range of y is in fact only over a = A(x, y ). (14') y.x(a = A(x, y ))   (y ) Assume that  = A(O1 , O2 ), then [y.x( = A(x, y ))   (y )] = y.x(x = O1  y = O2 )   (y )  x(x = O1 ) y.y = O2   (y ). Clearly, x(x = O1 ) y.y = O2   (y ) is of the form  (x)   (y ) (let  (x) be y.y = O2   (y ) and let  (y ) be x(x = O1 )). (15) x.y (a = A(x, y ))   (x) Assume that  = A(O1 , O2 ), then [x.y ( = A(x, y ))   (x)] = x.y (x = O1  y = O2 )   (x)  y (y = O2 ) x.x = O1   (x). Clearly, y (y = O2 )x.x = O1  (x) is of the form  (x) (y ) (let  (x) be y (y = O2 ) and let  (y ) be x.x = O1   (x)). (15') x.y (a = A(x, y ))   (y ) Case (15') is equivalent to case (13), because in case (15') the quantification range of x is in fact only over a = A(x, y ). (16) x.y.a = A(x, y )   (x) Case (16) is equivalent to case (14'), because in case (16) the quantification range of y is in fact only over a = A(x, y ). (16') x.y.a = A(x, y )   (y ) Case (16') is equivalent to case (13), because in case (16') the quantification range of x is in fact only over a = A(x, y ). Assume that  = A(O1 , O2 ), then Notice that for each of the cases above, it takes no more than one step of deduction to find the y x equivalent formula of the form  (x)   (y ) such that  (x)  F ODL and  (y )  F ODL , which is

53

constant to the size of the resulting formula. Now, we prove that Statement (2) is true for case (d.2).
[[W ]] = [[y.R(x, y, S )  W1 (y )[S ]]] = y.[[R(x, y, S )]]  [[W1 (y )[S ]]]
 = y.[[R(x, y, S )]]  W1 (y )[S1 ]  (by the induction hypothesis on W1 (y )[S1 ], let [[W1 (y )[S ]]]  W1 (y )[S1 ] y   be a formula uniform in S1 and W1 (y ) is in F ODL ; moreover, W1 (y )  can be found in no more than c · size(W1 (y ))) steps m+ m-

= y.[(
i=1 m+

+ i (x, y, )  R(x, y, S1 ) ¬( [+ i (x, y, )]  R(x, y, S1 ) ¬(

 - j (x, y, ))]  W1 (y )[S1 ]

j =1 m-  [- j (x, y, )])  W1 (y )[S1 ] j =1 m-

= y.(
i=1 m+

 y.(
i=1

+ + (i (x)  i (y ))  R(x, y, S1 )  j =1

- -  ¬(j (x)  j (y )))  W1 (y )[S1 ]

+ + (according the proof above, for each i, let [+ i (x, y, )]  (i (x)  i (y )) y + + x be a formula uniform in S1 for some i (x)  F ODL and i (y )  F ODL ; - - for each j, let [- j (x, y, )]  (j (x)  j (y )) be a formula uniform y - - x ) in S1 for some j (x)  F ODL and j (y )  F ODL m+ m- + +   (i (x)  i (y )  W1 (y ))  R(x, y )  W1 (y )  j =1 m- + +  i (x) y (i (y )  W1 (y ))) y. i=1 m+ j =1 m- + +  i (x) y (i (y )  W1 (y ))) y. i=1 m+ j =1 + +  i (x) y (i (y )  W1 (y ))  i=1 2m- -  ¬j (x) y (R(x, y )  W1 (y ) k=1 j Nk l N k - ¬l (y ))}[S1 ] - -  (¬j (x) ¬j (y ))  R(x, y )  W1 (y )}[S1 ] - -  (¬j (x) ¬j (y ))  R(x, y )  W1 (y )}[S1 ] - - ¬(j (x)  j (y )))[S1 ]

 y.(
i=1 m+

 {

 {

 {

(12)

= W  [S1 ],

where each Nk (1  k  2m- ) enumerates a subset of {1, 2, · · · , m- }, and Nk = {1, 2, · · · , m- }- Nk , i.e., Nk is the complement set of Nk . It is clear the formula on the RHS of Eq. (12) (denoted as 2 x W  [S1 ] above) is equivalent to [[W ]], is LC sc regressable, and is in F ODL when S1 is suppressed, and has no appearance of P oss. It is easy to see that to find it, it takes no more than c · size(W  ) for some integer c. Hence, Statement (2) is true for W . Moreover, according to Corollary 2, we have that R[W ] = R[[[W ]]]  R[W  [S1 ]]. Then, by the induction hypothesis on formulas uniform in x S1 , we have R[W ][-S0 ] will be equivalent to some formula in F ODL . It is very similar to prove that Statements (1) and (2) are true when W [-S ] is of the form y.R(x, y )  W1 (y ), and details are omitted here.
y Similarly, we can show that Statements (1) and (2) are true when W [-S ] is in F ODL and is not atomic.

54

And overall, we proved for Statement (1). 2 [ -S ] Now, consider any LC is in sc regressable W that is uniform in a ground situation S . When W x x F ODL, assume that we have found some W that is in F ODL, such that R[W ]  W [S0 ]. Below we estimate the upper bound on the size of W . Let n = sitLength(S ) (n  N and n  0), i.e., the number of action terms involved in S . Let m = size(W ) (m  N and m  1). Let function f (m, n) be the size of W , which is a non-decreasing function. Firstly, it is straightforward that f (1, 0) = 1. Secondly, when m = 1, W is atomic, which is either true, or f alse, or x = b for some constant b, or a situation-independent predicate, or a primitive dynamic concept. We now consider n  1. Assume that S = do(n , S1 ), and sitLength(S1 ) = n - 1. According to the discussion above of "the base case of the induction on the structure of W [-S ] " (i.e., cases (a-c)), for any n  N and n  1, f (1, n)  f (3h, n - 1), where h = max(2, sizeSSA(D )) (h is a constant number for the given D ). By Corollary 2, we have R[W ] = R[[[W ]]], where [[W ]] is uniform in S1 (no matter whether it is situation-independent or x not), and is equivalent to some 1  F ODL , whose size is no more than 3h (including all cases when W is atomic). Moreover, the equivalent formula W [S0 ] that we are looking for can be obtained by looking for the equivalent formula of R[1 [S1 ]], whose size is no more than f (3h, n - 1). Thirdly, we consider any m  2 and n  N. In fact, when m  2, W is not atomic. According to the x definition of F ODL , there are three sub-cases. y [ -S ] x 1. W is of the form ¬W1 , or y.W1 (y ), or y.W1 (y ) where W1 is in F ODL , or W1 (y ) is in F ODL . It is easy to see that f (m, n) = f (m - 1, n) + 1 according to the definition of the regression operator x R and the way F ODL constructed. For example, R[¬W1 [S ]] = ¬R[W1 [S ]], if we find a formula x 1 in F ODL that is equivalent to R[W1 [S ]][-S0 ] , then W = ¬1 is the formula that we are looking for.
x 2. W [-S ] is of the form W1  W2 , or W1  W2 where W1 and W2 are in F ODL . It is easy to see that f (m, n) = f (size(W1 ), n)+ f (size(W2 ), n)+1, which is no more than 2f (m - 1, n)+1, according x to the definition of the regression operator R and the way F ODL constructed. x 3. W [-S ] is of the form y.R(x, y )W1(y ), or y.R(x, y )  W1 (y ), where W1 (y ) is in F ODL and R is a dynamic predicate name. According to the definition of size in Section 5.2, we have size(W1 (y )) = m - 3. For instance, we consider the case when W [-S ] is of the form y.R(x, y )  W1 (y ), and it is similar for the case when W [-S ] is of the form y.R(x, y )  W1 (y ). According to the definition of R, we have

R[W ] = R[y.R(x, y )[S ]  W1(y )[S ]] = y.R[R(x, y )[S ]] R[W1(y )[S ]] y.R[R(x, y, S )] R[W1(y )[S ]] if R is a fluent, = y.R(x, y ) R[W1(y )[S ]] otherwise.

(13)

y Assume that R[W1 (y )[S ]][-S0] is equivalent to some 1 (y )  F ODL . When R is situation-independent, y.R(x, y )  1 (y ) is the formula that we are looking for, whose size is f (m - 3, n) + 3. When R is a dynamic role, we assume that its SSA is of the form Eq. (11) and S = do([1 , 2 , · · · , n ], S0 ).

55

Let Si = do([1 , · · · , n-i ], S0 ) for any 1  i  n - 1, then
R[W ] = y.R[R(x, y, S )] R[W1 (y )[S ]]   y.R[R(x, y, S )]  1 (y )[S0 ]
m+ m-

(14)

y.{
i=1 m+

R[+ i (x, y, n )] R[R(x, y, S1 )] ¬(
j =1

R[- j (x, y, n )])} 1 (y )[S0 ]
m-



y.{
i=1

R[[[+ i (x, y, n )]]] R[R(x, y, S1 )] ¬(
j =1

R[[[- j (x, y, n )]]])}

 1 (y )[S0 ]
m+



y.{

+ + (i,n (x)  i,n (y )) R[R(x, y, S1 )]  i=1 m-

(
j =1 m+

- - (¬j,n (x) ¬j,n (y )))} 1 (y )[S0 ] m+



y.{

+ + (i,n (x)  i,n (y ))  ( i=1 m- i=1

R[+ i (x, y, n-1 )] R[R(x, y, S2 )] 





m- - - - (x) ¬j,n (y )))} 1 (y )[S0 ] R[j (x, y, n-1 )]))  ( (¬j,n ¬( j =1 j =1 m+ m+ + + + + (x)  i,n (y ))  ( (i,n y.{ (i,n -1 (x)  i,n-1 (y )) R[R(x, y, S2 )]  i=1 i=1 m- m- - - - - (x) ¬j,n (y )))} 1 (y )[S0 ] (x) ¬j,n (y ))))  ( (¬j,n ( (¬j,n j =1 j =1 m+ + + + (i,l (x)  i,l (y )) · · · · · · (for each 1  l  n, let l = i=1 m- - - (¬j,l (x) ¬j,l (y ))) and let l- = j =1 + + - - + - y.{n  (n -1  (· · · (1  R(x, y, S0 )  1 ) · · · )  n-1 )  n }



 1 (y )[S0 ]
n n - i  R(x, y )  i=2 i=1 - i )  1 (y )}[S0 ]

(15) (16)

  

+ + + - {y.(n  n -1  n · · · 1 

· · · · · · (use distributive law to obtain a sort of DNF format)
u

{y.(
i=1

S,i (x, y ))  1 (y )}[S0 ]

for some index u

(17)

(each S,i (x, y ) is a conjuction of some of the sub-formulas in the set + + - - {R(x, y )}  {i,l (x), i,l (x), j,l (y ), j,l (u) | i = 1..m+ , j = 1..m- , l = 1..n})
u

 

{ {

(y.S,i (x, y )  1 (y ))}[S0 ]
i=1 u

(18) (19)

S,i (x)}[S0 ]
i=1

+ + - - where each i,l (x)  i,l (y ) (j,l (x)  j,l (y ), respectively) is equivalent to R[[[+ i (x, y, k )]]]

56

+ - x (R[[[- j (x, y, k )]]], respectively). Here, each i,l (x) (j,l (x), respectively) is in F ODL with at y + - most one free variable x, and each i,l (y ) (j,l (y ), respectively) is in F ODL with at most one free variable y , according to the proof for cases (1-16,1'-16') in Table 12. Notice that in order to obtain x an equivalent formula of R[W ][-S0 ] in F ODL , we need to perform the following steps of deductions. First, we transform R[R(x, y, S )] in Step (14) into a sort of disjunctive normal form (DNF) (from + + - - Step (14) to Step (17)) based on the assumption that each i,l , (i,l (y ), j,l (x), j,l (y ), respectively) is "atomic", i.e., when each of these sub-formulas is considered as an atom, after using the distributive law, the resulting sub-formula u i=1 S,i (x, y ) in Step 17 is a DNF formula. Since the resulting formula is too long, we omit the details and only provide one example of a sub-formula in Step (16) + - . For instance, we perform the distributive law over n -1  n , and obtain + + i,n -1 (x)  i,n-1 (y )  i=1..m+ ,k =1..2m- j Nk m- - ¬j,n (x)  lNk - ¬l,n (y ),

where Nk  {1, 2, · · · , m- } (1  k  2 ) enumerates all sub-sets of {1, 2, · · · , m- }, and Nk = {1, 2, · · · , m- } - Nk , i.e., is the complement set of Nk . Next, we distribute 1 (y )[S0] into the resulting DNF formula (from Step (17) to Step (18)). Finally, we push y inside into each conjunctive clause and minimize the scope of each quantifier y (from Step(17) to Step (19)). In Step (17), after using the commutative law of conjunctions, each S,i (x, y ) is either of the form x S,i(x)S,i (y ) or of the form S,i(x)R(x, y )S,i (y ) for some S,i (x)  F ODL and some S,i (y )  y F ODL . From Step (18) to Step (19), there are two cases for each index i: if S,i (x, y ) is of the form S,i(x)  S,i (y ), then S,i(x) is S,i (x)  (y.S,i (y )  1 (y )); if S,i (x, y ) is of the form S,i (x)  R(x, y )S,i (y ), then S,i (x) is S,i (x)(y.R(x, y )S,i (y )1 (y )). Hence, the resulting formula x in Step (19), with S0 suppressed, is in F ODL , and we denote the formula (with S0 suppressed) as W . Now we estimate the size of W when R is a fluent according to the way it is constructed above. First, for any n  0 and any situation S where sitLength(S ) = n, we denote the size of the DNF formula that is equivalent to R[R(x, y, S )], constructed specifically according to the above steps + (14-17), as g (n). Note that for each 1  i  m+ , 1  j  m- and 1  l  n, size(i,l (x)), + - - (size(i,l (y )), size(j,l (x)) size(j,l (y )), respectively) is no more than h + 2 according to the above for cases (1-16,1'-16') in Table 12. Moreover, according to the definition of function size() in Section 5.2, the logical constructors should also be counted. Also, for any m- and m+ for any role R, we always have m- < h and m+ < h (recall that constant number h = max(2, sizeSSA(D ))). According to Step 19, f (m, n)  (f (m - 3, n) + 3)g (n), where f (m - 3, n) = size(1 (y )). Below, we show that g (n)  c1 2nh , where c1 = (2(h + 3) + (h + 4)h2 + 2)22h . Moreover, we can perform

57

a similar estimation for the case when W [-S ] is of the form y.R(x, y )  W1 (y ).
g (n)  2(h + 3)m+ + (2m- )m+ (2(h + 3) + m- (h + 4)) + (2m- )2 m+ (2(h + 3) + 2m- (h + 4)) + ... + (2m- )n-1 m+ (2(h + 3) + (n - 1)m- (h + 4)) + (2m- )n (2 + nm- (h + 4))
n-1 n

= =

2(h + 3)m+
i=0 n-1

(2m- )i + (h + 4)m-
i=1

i(2m- )i + 2(2m- )n
n

2(h + 3)m+
i=0 n-1

(2m- )i + (h + 4)m+ m-
i=1 n

i(2m- )i + 2(2m- )n

<    

2(h + 3)h

(2h )i + (h + 4)h2
i=0 h n 2

i(2h )i + 2(2h )n
i=1 h n+1

2(h + 3)h(2 ) + (h + 4)h n(2 ) + 2(2h )n 2(h + 3)h(2h )n + (h + 4)h2 (2h )n+2 + 2(2h )n (2(h + 3) + (h + 4)h2 + 2)(2h )n+2 c1 2nh (let constant number c1 = (2(h + 3) + (h + 4)h2 + 2)22h ).

y We can perform a similar estimation for the case when W [-S ] is in F ODL . Overall, under any case, we have

f (m, n)  max(f (m - 1, n) + 1, 2f (m - 1, n) + 1, f (m - 3, n) + 3, c1 (2h )n (f (m - 3, n) + 3))  c1 2hn (f (m - 1, n) + 3)  c1 2hn (c1 2hn (f (m - 2, n) + 3) + 3)  ···  c1 2hn (c1 2hn (· · · (2hn (f (1, n) + 3)) + · · · + 3) + 3)
m- 2

= (c1 2hn )m-1 f (1, n) + 3
i=0 hn m-1

(c1 2hn )i

 (c1 2 ) (f (1, n) + 3) -1 hn(m-1)  cm 2 (f (3h, n - 1) + 3) 1
-1 hn(m-1) 3h-1 hn(3h-1)  cm 2 (c1 2 (f (1, n - 1) + 3) + 3) 1 -1 hn(m-1) 3h-1 hn(3h-1)  cm 2 (c1 2 (f (3h, n - 2) + 3) + 3) 1  ··· n

   =

-1 hn(m-1) 3h-1 hn(3h-1) n cm 2 ((c1 2 ) f (1, 0) 1

+3

3h-1 hn(3h-1) i (c1 2 ))

= 2

i=0 m-1 hn(m-1) 3h-1 hn(3h-1) n 3h-1 hn(3h-1) n+1 c1 2 ((c1 2 ) + 3(c1 2 ) ) m-1 hn(m-1) 3h-1 hn(3h-1) n+1 4 c1 2 (c1 2 ) (n+1)(3h-1)+(m-1) hn(m-1)+h(3h-1)n(n+1) 4 c1 2 c2 ((n+1)(3h-1)+(m-1))+hn(m-1)+h(3h-1)n(n+1)+2

where constant numbers c2 = log2 c1 and c1 = (2(h + 3) + (h + 4)h2 + 2)22h . Hence, we finally have f (m, n)  O (2hmn+3h
2 n2

), where constant h = max(2, sizeSSA(D )).

That is, the size of the equivalent formula of R[W ] that we are looking for is no more than exponential in the size of the given formula W . 58

References
[1] Artale A, Franconi E (2001) A survey of temporal extensions of description logics. Annals of Mathematics and Artificial Intelligence 30(1-4) [2] Baader F, Lutz C, Mili^ ci´ c M, Sattler U, Wolter F (2005) Integrating description logics and action formalisms: First results. In: Proceedings of the Twentieth National Conference on Artificial Intelligence (AAAI-05), Pittsburgh, PA, USA, pp 572­577, extended version is available as LTCS-Report05-02 at http://lat.inf.tu-dresden.de/research/reports.html [3] Baader F, Milicic M, Lutz C, Sattler U, Wolter F (2005) Integrating description logics and action formalisms for reasoning about web services. LTCS-Report LTCS-05-02, Chair for Automata Theory, Institute for Theoretical Computer Science, Dresden University of Technology, Germany [4] Baader F, Calvanese D, McGuinness D, Nardi D, Patel-Schneider PF (eds) (2007) The Description Logic Handbook: Theory, Implementation, and Applications. Second edition, Cambridge University Press [5] van Benthem J (1976) Modal Correspondence Theory, PhD thesis. Mathematisch Instituut & Instituut voor Grondslagenonderzoek, University of Amsterdam [6] van Benthem J (1983) Modal logic and and classical logic. Bibliopolis [7] Berardi D, Calvanese D, Giacomo GD, Lenzerini M, Mecella M (2003) e-service composition by description logics based reasoning. In: Calvanese D, Giacomo GD, Franconi E (eds) Proceedings of the 2003 International Workshop in Description Logics (DL-2003), Rome, Italy [8] Blackburn P, van Benthem J (2007) Modal logic: a semantic perspective. In: Blackburn P, van Benthem J, Wolter F (eds) Handbook of Modal Logic, Elsevier Science, pp 1­84 [9] Borgida A (1996) On the relative expressiveness of description logics and predicate logics. Artificial Intelligence 82(1-2):353­367 [10] Calvanese D, Franconi E, Haarslev V, (2007) Proceedings of the 2007 International Workshop on Description Logics (DL2007), Brixen-Bressanone, near Bozen-Bolzano, Italy, 8-10 June, 2007, CEUR Workshop Proceedings, vol 250, CEUR-WS.org [11] Calvanese D, Giacomo GD, Lenzerini M, Rosati R (2007) Actions and programs over description logic ontologies. In: [10] [12] Castilho MA, Herzig A, Varzinczak IJ (2002) It depends on the context! a decidable logic of actions and plans based on a ternary dependence relation. In: Benferhat S, Giunchiglia E (eds) NMR, pp 343­348 [13] Chang L, Lin F, Shi Z (2007) A dynamic description logic for representation and reasoning about actions. In: Zhang Z, Siekmann JH (eds) KSEM, Springer, Lecture Notes in Computer Science, vol 4798, pp 115­127 [14] Chang L, Shi Z, Qiu L, Lin F (2007) Dynamic description logic: Embracing actions into description logic. In: [10] 59

[15] Demolombe R (2003) Belief change: from situation calculus to modal logic. Journal of Applied Non-Classical Logics 13(2):187­198 [16] Demolombe R, Herzig A, Varzinczak IJ (2003) Regression in modal logic. Journal of Applied NonClassical Logics 13(2):165­185 [17] Drescher C, Thielscher M (2007) Integrating action calculi and description logics. In: Hertzberg J, Beetz M, Englert R (eds) KI-2007, Springer, Lecture Notes in Computer Science, vol 4667, pp 68­83 [18] Finzi A, Pirri F, Reiter R (2000) Open world planning in the situation calculus. In: AAAI/IAAI, AAAI Press / The MIT Press, pp 754­760 [19] Fischer MJ, Ladner RE (1979) Propositional dynamic logic of regular programs. Journal of Computer and System Sciences 18(2):194­211 [20] Gabbay D (1981) Expressive functional completeness in tense logic. In: M¨ onnich U (ed) Aspects of Philosophical Logic: Some Logical Forays into Central Notions of Linguistics and Philosophy, "Synthese Library", Vol. 147, Reidel, pp 91­117 [21] Gabbay DM, Shehtman VB (1998) Products of modal logics, part 1. Logic Journal of the IGPL 6(1):73­146 [22] Gabbay DM, Shehtman VB (2000) Products of modal logics. part 2: Relativised quantifiers in classical logic. Logic Journal of the IGPL 8(2) [23] Gabbay DM, Shehtman VB (2002) Products of modal logics. part 3: Products of modal and temporal logics. Studia Logica 72(2):157­183 [24] Giacomo GD, Lenzerini M (1995) PDL-based framework for reasoning about actions. In: Gori M, Soda G (eds) AI*IA, Springer, Lecture Notes in Computer Science, vol 992, pp 103­114 [25] Giacomo GD, Iocchi L, Nardi D, Rosati R (1999) A theory and implementation of cognitive mobile robots. Journal of Logic and Computation 9(5):759­785 [26] Giacomo GD, Lenzerini M, Poggi A, Posati R (2006) On the update of description logic ontologies at the instance level. In: Proceedings of the 21st National Conference on Artificial Intelligence and the Eighteenth Innovative Applications of Artificial Intelligence Conference (AAAI-06), AAAI Press, Buston, US, pp 1271­1276 [27] Gil Y (2005) Description logics and planning. AI Magazine 26(2):73­84 [28] Gr¨ adel E, Kolaitis PG, Vardi MY (1997) On the decision problem for two-variable first-order logic. Bulletin of Symbolic Logic 3:53­69 [29] Gr¨ adel E, Otto M, Rosen E (1997) Two-variable logic with counting is decidable. In: Proceedings of the 12th Annual IEEE Symposium on Logic in Computer Science (LICS'97), Warsaw, Poland, pp 306­317 [30] Gr¨ uninger M (2004) Ontology of the process specification language. In: Staab S, Studer R (eds) Handbook on Ontologies, Springer, pp 575­592 60

[31] Gr¨ uninger M, Menzel C (2003) The process specification language (PSL): Theory and applications. AI Magazine 24(3):63­74 [32] Gu Y, Soutchanski M (2007) Decidable reasoning in a modified situation calculus. In: Proceedings of the Twentieth International Joint Conference on Artificial Intelligence (IJCAI-07), Hyderabad, India, pp 1891­1897, http://www.cs.ryerson.ca/ mes/publications/DecidableSitcalc ijcai07.pdf [33] Harel D, Kozen D, Tiuryn J (2000) Dynamic Logic. THe MIT Press [34] Hemaspaandra E (1996) The price of universality. Notre Dame Journal of Formal Logic 37(2):174­ 203 [35] Horrocks I, Sattler U (2001) Ontology reasoning in the SHOQ(D) description logic. In: In Proc. of the 17th Int. Joint Conf. on Artificial Intelligence (IJCAI 2001, Morgan Kaufmann, pp 199­204 [36] Horrocks I, Patel-Schneider P, van Harmelen F (2003) From SHIQ and RDF to OWL: The making of a web ontology language. Journal of Web Semantics 1(1):7­26 [37] Hustadt U, de Nivelle H, Schmidt RA (2000) Resolution-based methods for modal logics. Logic Journal of the IGPL 8(3) [38] Hustadt U, Schmidt RA, Georgieva L (2004) A survey of decidable first-order fragments and description logics. Journal on Relational Methods in Computer Science 1:251­276 [39] Kemke C (2003) A formal theory for describing action concepts in terminological knowledge bases. In: Xiang Y, Chaib-draa B (eds) Advances in Artificial Intelligence: 16th Conference of the Canadian Society for Computational Studies of Intelligence, Springer, Lecture Notes in Computer Science, Volume 2671, June 11-13, Halifax, Canada, pp 458­465 [40] Kurucz A (2007) Combining modal logics. In: Blackburn P, van Benthem J, Wolter F (eds) Handbook of Modal Logic, Elsevier Science, pp 869­924 [41] Levesque H, Reiter R, Lesp´ erance Y, Lin F, Scherl R (1997) GOLOG: A logic programming language for dynamic domains. Journal of Logic Programming 31:59­84 [42] Lin F (2004) Discovering state invariants. In: Dubois D, Welty CA, Williams MA (eds) KR, AAAI Press, pp 536­544 [43] Lin F, Reiter R (1994) State constraints revisited. J Log Comput 4(5):655­678 [44] Lin F, Reiter R (1997) How to progress a database. Artificial Intelligence 92:131­167 [45] Liu H, Lutz C, Milicic M, Wolter F (2006) Reasoning about actions using description logics with general tboxes. In: Fisher M, van der Hoek W, Konev B, Lisitsa A (eds) JELIA, Springer, Lecture Notes in Computer Science, vol 4160, pp 266­279 [46] Liu H, Lutz C, Milicic M, Wolter F (2006) Updating description logic ABoxes. In: Doherty P, Mylopoulos J, Welty C (eds) Proceedings of the 10th International Conference on Principles of Knowledge Representation and Reasoning (KR-06), AAAI Press, pp 46­56 61

[47] Liu Y, Levesque HJ (2005) Tractable reasoning with incomplete first-order knowledge in dynamic systems with context-dependent actions. In: Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence (IJCAI-05), Edinburgh, Scotland, pp 522­527 [48] Lutz C, Sattler U (2000) The complexity of reasoning with boolean modal logics. In: Wolter F, Wansing H, de Rijke M, Zakharyaschev M (eds) Advances in Modal Logic, World Scientific, pp 329­348 [49] Lutz C, Sattler U, Wolter F (2001) Description logics and the two-variable fragment. In: McGuiness D, Pater-Schneider P, Goble C, M¨ oller R (eds) Proceedings of the 2001 International Workshop in Description Logics (DL-2001), Stanford, California, USA, pp 66­75 [50] McCarthy J (1959) Programs with common sense. In: Mechanisation of Thought Processes, Proceedings of the Symposium of the National Physics Laboratory, Her Majesty's Stationery Office. Reprinted in [53], London, U.K., pp 77­84 [51] McCarthy J (1963) Situations, actions and causal laws. Tech. rep., Stanford University [52] McCarthy J (1986) Applications of circumscription to formalizing common sense knowledge. Artifficial Intelligence 28:89­116 [53] McCarthy J (1990) Formalization of common sense: papers by John McCarthy edited by V. Lifschitz. Ablex, Norwood, N.J. [54] McCarthy J (2002) Actions and other events in situation calculus. In: Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, available at http://www-formal.stanford.edu/jmc/sitcalc.html [55] McCarthy J, Hayes P (1969) Some philosophical problems from the standpoint of artificial intelligence. In: Meltzer B, Michie D (eds) Machine Intelligence, vol 4, Edinburgh University Press, Reprinted in [53], pp 463­502 [56] McIlraith S, Son T (2002) Adapting Golog for composition of semantic web services. In: Fensel D, Giunchiglia F, McGuinness D, Williams MA (eds) Proceedings of the Eighth International Conference on Knowledge Representation and Reasoning (KR2002), Morgan Kaufmann, April 22-25, Toulouse, France, pp 482­493 [57] McIlraith SA (2000) Integrating actions and state constraints: A closed-form solution to the ramification problem (sometimes). Artif Intell 116(1-2):87­121 [58] Milicic M (2007) Complexity of planning in action formalisms based on description logics. In: Dershowitz N, Voronkov A (eds) LPAR, Springer, Lecture Notes in Computer Science, vol 4790, pp 408­422 [59] Milicic M (2007) Planning in action formalisms based on DLs: First results. In: [10] [60] Morgenstern L, Riecken D (2005) SNAP: An action-based ontology for e-commerce reasoning. In: Formal Ontologies Mett Industry, Proceedings of the 1st International Workshop FOMI 2005, June 9-10, Verona, Italy 62

[61] Narayanan S, McIlraith S (2003) Analysis and simulation of web services. Computer Networks 42:675­693 [62] de Nivelle H, Pratt-Hartmann I (2001) A resolution-based decision procedure for the two-variable fragment with equality. In: R Gor´ e AL, Nipkow T (eds) IJCAR'01: Proceedings of the First International Joint Conference on Automated Reasoning, Springer-Verlag, LNAI, V. 2083, London, UK, pp 211­225 [63] Ohlbach HJ, Nonnengart A, de Rijke M, Gabbay DM (2001) Encoding two-valued nonclassical logics in classical logic pp 1403­1486 [64] Pacholski L, Szwast W, Tendera L (1997) Complexity of two-variable logic with counting. In: Proceedings of the 12th Annual IEEE Symposium on Logic in Computer Science (LICS-97), A journal version: SIAM Journal on Computing, v 29(4), 1999, p. 1083­1117, Warsaw, Poland, pp 318­327 [65] Pacholski L, Szwast W, Tendera L (2000) Complexity results for first-order two-variable logic with counting. SIAM Journal on Computing 29(4):1083­1117 [66] Pirri F, Reiter R (1999) Some contributions to the metatheory of the situation calculus. Journal of the ACM 46(3):325­364 [67] Pratt VR (1978) A practical decision method for propositional dynamic logic: Preliminary report. In: STOC, ACM, pp 326­337 [68] Pratt-Hartmann I (2005) Complexity of the two-variable fragment with counting quantifiers. Journal of Logic, Lang and Inf 14(3):369­395, DOI http://dx.doi.org/10.1007/s10849-005-5791-1 [69] Prendinger H, Schurz G (1996) Reasoning about action and change: A dynamic logic approach. Journal of Logic, Language and Information 5(2):209­245 [70] Reiter R (2001) Knowledge in Action: Logical Foundations for Describing and Implementing Dynamical Systems. The MIT Press [71] Schiffel S, Thielscher M (2006) Reconciling situation calculus and fluent calculus. In: AAAI, AAAI Press [72] Schild K (1991) A correspondence theory for terminological logics: Preliminary report. In: In Proc. of IJCAI-91, pp 466­471 [73] Schmidt RA, Tishkovsky D (2007) Deciding albo with tableau. In: [10] [74] Schmidt RA, Tishkovsky D (2008) A general tableau method for deciding description logics, modal logics and related first-order fragments. In: Armando A, Baumgartner P, Dowek G (eds) IJCAR, Springer, Lecture Notes in Computer Science, vol 5195, pp 194­209 [75] Schmidt-SchaubßM, Smolka G (1991) Attributive concept descriptions with complements. Artif Intell 48(1):1­26, DOI http://dx.doi.org/10.1016/0004-3702(91)90078-X [76] Shanahan M (1997) Solving the Frame Problem: A Mathematical Investigation of the Common Sense Law of Inertia. The MIT Press 63

[77] Shirazi A, Amir E (2005) First-order logical filtering. In: Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence (IJCAI-05), pp 589­595 [78] Spaan E (1993) Complexity of modal logics. PhD thesis, Department of Mathematics and Computer Science, University of Amsterdam [79] Tobies S (1999) A nexptime-complete description logic strictly contained in C2 . In: Flum J, Rodr´ iguez-Artalejo M (eds) CSL, Springer, Lecture Notes in Computer Science, vol 1683, pp 292­ 306 [80] Tobies S (2000) The complexity of reasoning with cardinality restrictions and nominals in expressive description logics. J of Artificial Intelligence Research 12:2000 [81] Tobies S (2001) Complexity results and practical algorithms for logics in knowledge representation. PhD Thesis, LuFG Theoretical Computer Science, RWTH-Aachen, Germany [82] Vassos S, Lakemeyer G, Levesque HJ (2008) First-order strong progression for local-effect basic action theories. In: Proceedings of 11th International Conference on Principles of Knowledge Representation and Reasoning (KR-08), Sydney, Australia [83] Winslett MS (1990) Updating logical databases. The Academic Press [84] Wolter F, Zakharyaschev M (2000) Dynamic description logics. In: Advances in Modal Logic, 2nd workshop held in Uppsala, Sweden, 1998, CSLI Publications, pp 431­446 [85] Zolin E (2007) Description logic HTTP:http://www.cs.man.ac.uk/ ezolin/dl/ complexity navigator. Available at

64

