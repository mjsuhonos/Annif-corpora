Ryerson University

Digital Commons @ Ryerson
Theses and dissertations

1-1-2009

RFID Security : Tiny Encryption Algorithm And Authentication Protocols
Shirley. Gilbert
Ryerson University

Follow this and additional works at: http://digitalcommons.ryerson.ca/dissertations Part of the Electrical and Computer Engineering Commons Recommended Citation
Gilbert, Shirley., "RFID Security : Tiny Encryption Algorithm And Authentication Protocols" (2009). Theses and dissertations. Paper 1093.

This Thesis is brought to you for free and open access by Digital Commons @ Ryerson. It has been accepted for inclusion in Theses and dissertations by an authorized administrator of Digital Commons @ Ryerson. For more information, please contact bcameron@ryerson.ca.

RFID SECURITY: TINY ENCRYPTION ALGORITHM AND AUTHENTICATION PROTOCOLS

By

Shirley Gilbert

A project presented to Ryerson University in partial fulfillment of the requirement for the degree of Masters in Engineering in the program of Electrical and Computer Engineering

Toronto, Ontario, Canada, 2009
© Shirley Gilbert 2009

PROPERTY OF

RYERSON UNIVERSITY LIBRARY

I hereby declare that I am the sole author of this project.

I authorize Ryerson University to lend this project to other institutions or individuals for the purpose of scholarly research.

I further authorize Ryerson University to reproduce this project by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research.

Shirley Gilbert

11

RFID Security: Tiny Encryption Algorithm and Authentication Protocols

Shirley Gilbert, Masters in Electrical Engineering, 2009, Electrical and Computer Engineering, Ryerson University

Abstract
With recent advancement in Radio Frequency Identification (RFID) technology, in addition to reduction in cost of each unit, security has emerged as a major concern. Since an RFID tag has limited resources like memory, power and processing capabilities, authentication must be provided by encryption and decryption procedures that are lightweight consuming minimal resources. This report investigates some relevant RFID encryption algorithms and their possible implementations with respect to security, cost and performance. A survey and brief comparison of the algorithms are performed and the Tiny Encryption Algorithm (I'EA) is selected as a feasible solution for encryption and decryption with an acceptable level of security. TEA is implemented on an FPGA (Field Programmable Gate Array) platform. After investigating several state-of-the-art authentication approaches, two protocols are designed incorporating TEA and implemented using VHDL. Simulations corroborate the functionality of the protocols and the two techniques are compared in terms of timing, cost, security and performance. Potential improvements to enhance the security and strengthen RF communication during authentication are explored.

111

Acknowledgements

The author would like to thank the supervising professor Dr. Gul Khan for providing guidance and support for the successful completion of the project. The author would also like to thank the review committee members for their suggestions and valued opinions.

lV

Dedication

I would like to dedicate this work to my parents for their constant love, support and encouragement without which I would not be where I am today.

v

Table of Contents
1. Introduction ........................................................................................... 1
1.1 Background ........................................................................................ 1 1.2 Motivation for Research ....................................................................... 2 1.3 Original Contributions .......................................................................... 3 1.4 Organization of Thesis ......................................................................... 3

2. RFID Security and Encryption Algorithms .......................................... 4
2.1 Encryption Preliminaries ...................................................................... 4 2.2 Advanced Encryption Standard (AES) .................................................... 5 2.3 Scalable Encryption Algorithm (SEA) .................................................... 6 2.4 International Data Encryption Algorithm (IDEA) ..................................... 8 2.5 Tiny Encryption Algorithm (TEA) ......................................................... 9 2.6 Extended Tiny Encryption Algorithm (XTEA) ....................................... 12

3. RFID Authentication Protocols ........................................................... 15
3.1 Introduction ...................................................................................... 15 3.2 Attacks to RFID System ..................................................................... 16 3.3 Fundamental Approaches in Authentication ........................................... 17 3.4 Authentication for Location Privacy and Forward-Security ...................... 19 3.5 Authentication for Low-cost Tags ........................................................ 21

4. Implementation of Tiny Encryption Algorithm (TEA) ....................... 24
4.1 Overview ......................................................................................... 24 4.2 Functional Requirements of TEA ......................................................... 24 4.3 Input/Output Requirements of TEA ...................................................... 25

Vl

4.4 Design of Encryption/Decryption Modules ............................................ 26 4.5 Testing and Verification Results ........................................................... 29 4.6 Integrating Hardware Encryption and Software Decryption modules ......... 31 4.7 Variable Rounds of Tiny Encryption Algorithm ..................................... 33

5. Improvements in RFID Security ......................................................... 35
5.1 Introduction ...................................................................................... 35 5.2 Variable Key Scheme (Modified TEA) ................................................. 36 5.3 Variable Round Scheme (Modified TEA) .............................................. 38 5.4 HDL Implementation of Variable Key Scheme ...................................... 40 5.5 HDL Implementation of Variable Round Scheme ................................... 43 5.6 Comparison of Variable Key and Variable Round Authentication Techniques ....................................................................................... 45

6. Conclusion and Future Work .............................................................. 48

REFERENCES ......................................................................................... 50 APPENDIX A- TEA (VHDL, C Code) ................................................. 54 APPENDIX B- Variable Key Scheme (VHDL) .................................... 62 APPENDIX C- Variable Round Scheme (VHDL) ................................ 83

Vll

List of Figures
Figure 2.1 Structure of the AES Algorithm Figure 2.2 Encrypt/Decrypt Rounds in SEA Figure 2.3 Encryption Round of IDEA Figure 2.4 Two Feistel rounds (One round of TEA) Figure 2.5 Feistel Structure for XTEA for two rounds Figure 3.1 Basic Hash-Locking based Scheme [ 15] Figure 3.2 Pseudo-Random Function (PRF) Block Figure 3.3 Randomized Hash locking Scheme [15] Figure 4.1 Block Diagram for TEA algorithm Figure 4.2 TEA Flowchart Figure 4.3 State Diagram for TEA Implementation Figure 4.4 TEA Simulation waveform illustrating transition of states Figure 4.5 TEA Simulation- First 9 rounds of encryption cycle Figure 4.6 TEA Simulation Waveform- Output after 32 rounds Figure 4.7 TEA Simulation Waveform- Output after 32 rounds of Decryption Figure 4.8 System generated by So PC (System on a Programmable Chip) Builder Figure 4.9 TEA Top-Level Module Design Figure 4.10 Waveform- New Delta Value Calculation for Decryption Figure 4.11 Waveform- Output of Encryption after 50 rounds Figure 4.12 Waveform- Output of Decryption after 50 rounds Figure 5.1 Proposed Authentication Scheme for Variable Keys Figure 5.2 Proposed Authentication Scheme for Variable Rounds Figure 5.3 General Setup for Hardware/Software Implementation of Variable Key and Variable Rounds approaches Figure 5.4 Components and their Interface for Variable Keys Authentication Figure 5.5 Simulation of the Variable Key Authentication protocol Figure 5.6 Components and their Interface for Variable Round Authentication Figure 5. 7 Simulation of the Variable Round Authentication protocol

Vlll

List of Tables
Table 2.1 Comparison of Implementation Results of TEA and XTEA Table 5.1 Comparison of Variable Key and Variable Round Authentication

lX

Glossary of Acronyms
AES - Advanced Standard Encryption ANSI- American National Standards Institute CLB - Configurable Logic Block CMOS -Complementary Metal Oxide Semiconductor CRC - Cyclic Redundancy Check DB- Database DES- Data Encryption Standard DOS - Denial of Service DSP- Digital Signal Processor EPC - Electronic Product Code FPGA - Field Programmable Gate Array FSM - Finite State Machine HDL- Hardware Description Language 110- Input/Output ID - Identification IDE - Integrated Development Environment IEEE - Institute of Electrical and Electronics Engineers IP Core - Intellectual Property Core ISO - International Organization for Standardization JTAG- Joint Test Action Group LSB - Least Significant Bit MSB - Most Significant Bit NIST- U.S National Institute of Standards and Technology p-box - Permutation Box PID - Pseudo-ID PRF - Pseudo Random Function PRNG- Pseudo Random Number Generator RISC - Reduced Instruction Set Computer RFID - Radio Frequency Identification

X

RNG -Random Number Generator RAM - Random Access Memory s-box- Substitution Box SEA - Scalable Encryption Algorithm SoPC - System on a Programmable Chip TEA - Tiny Encryption Algorithm UART - Universal Asynchronous Receiver-Transmitter UHF - Ultra High Frequency VHDL- Very High Speed Integrated Circuit Hardware Description Language XTEA - Extended Tiny Encryption Algorithm

Xl

Chapter 1 Introduction

1.1 Background

Radio Frequency Identification (RFID) is a rapidly developing field and technology that emerged in the last decade. This technology is employed by using implantable microchip devices also known as RFID tags (transponders); these tags communicate with a central unit/general purpose computer often called a Reader or an interrogator for exchange of information. With a plethora of applications ranging from supply chain management, retailing, theft prevention, access control and people tagging as a few examples, the need to explore factors of cost, security, performance and efficiency become imperative. Moreover, since this technology is implemented on an embedded platform, it must be accomplished by optimizing features like hardware, area, cost and latency which need to be satisfied by the available resources. It is estimated that the cost of an RFID tag is few cents and occupies an area of less than 1mm2 (approx 0.4 mm2) [16], which will significantly contribute to the rise of its use in the coming years. An RFID tag has limited features which include minimal memory resources and power capabilities. Transponders are attached to a small antenna to transmit and receive radio waves and are equipped to operate in a wide range of frequencies from low frequency (120KHz) to ultra high frequency (960 MHz). They are usually classified as active and passive tags, depending on their available resources. Active tags possess a battery and higher processing abilities as opposed to passive tags which have very limited resources and no battery. A passive tag derives its power from the radio waves generated by the reader during interrogation. Due to their restricted capabilities passive tags warrant encryption algorithms with minimal computational complexity. In addition to the tag and the reader, the entire system comprises a backend server that is employed to store all vital information including details of all tags being used. Several algorithms have been investigated, developed and compared for performance [ 1]. Most of these are adopted by standardizing organizations like the IEEE, the American National Standards Institute (ANSI),

1

(International Organization for Standardization) ISO and the U.S National Institute of Standards and Technology (NIST). Currently, it is proposed to eliminate electronic bar code systems and replaced with passive RFID tags of EPC (Electronic Product Code). These are passive UHF tags that are equipped with certain functions like anti-collision, a 10-bit pseudo random number generator (PRNG) and cyclic redundancy check (CRC). The current research is focussed on how to optimize the available resources on a tag to achieve a good balance of cost and security.

1.2 Motivation for Research Most of the RFID applications are sensitive to protecting the information being exchanged, issues of security and privacy must be carefully planned. Moreover, the weakest link in communication is the wireless channel link between the reader and the tag. Security is assured by ensuring that the information exchange between the tag and the reader is not revealed to an unauthorized entity or eavesdropper. Several authentication protocols have been researched and put forth in literature in addition to encryption and decryption algorithms.

Once algorithms and circuits are tested for functionality, hardware area consumption and latency of the design is deemed suitable, a CMOS (semiconductor-chip) implementation of the design is adopted for mass production. Although a plethora of platforms for implementation exist to choose from, there are two ways to implement an encryption algorithm - either in hardware or software. Both realms have different characteristics and performance measurement metrics. Software implementations are compared based on their memory consumption and clock cycles whereas hardware implementations are evaluated based on the gate-count (area) and clock cycles for computation [1]. In order to be adopted as a standard, a particular algorithm is thoroughly analyzed by using fewer rounds or invocations to find a short-cut attack and then extended to the full version of the algorithm [3]. In addition, safety, performance and availability of the algorithm are considered. Availability signifies whether or not the algorithm is accessible in public domain or patented by the algorithm's designer. Safety of an algorithm is typically cited by the designer in terms of number of rounds for which the algorithm is guaranteed to

2

withstand any attack. Performance comparisons are also made on different platforms such as Pentium processors, RISC processors, microcontrollers, Digital Signal Processors (DSPs) and Field Programmable Gate Arrays (FPGAs) since this metric can greatly vary on the platform selected for implementation. It is clear that establishment of security and privacy in conjunction with minimal consumption of hardware to resources are requirements crucial to a secure RFID system. In order to satisfy the requirement of security and privacy, it is imperative to study and explore authentication protocols in RFID systems, and to meet the requirement of low consumption of resources use of lightweight encryption algorithms is essential.

1.3 Original Contributions
This report presents detailed implementation of the Tiny Encryption Algorithm (TEA) using an FPGA platform. Investigation of authentication protocols leads to the development of two authentication protocols with slight modifications to TEA in order to increase security and enhance resistance to attacks in an RFID system. Comparison of these two protocols is made in terms of cost and security. Furthermore, results of the implementation of these authentication protocols are presented to verify functionality of the proposed schemes.

1.4 Organization of Thesis
Chapter 2 provides a brief survey of the most widely used and researched cryptographic encryption algorithms with their advantages and disadvantages. Chapter 3 discusses the various significant authentication protocols recently researched with respect to RFID systems. Chapter 4 presents details on the implementation of the Tiny Encryption Algorithm (TEA) on a hardware platform (FPGA). Chapter 5 includes possible improvisations to strengthen security in communication between a transponder and the reader and Chapter 6 draws conclusion to the research and provides suggestions for future work. The Appendix includes source code (C, VHDL) for implementation of TEA (as discussed in Chapter 5).

3

Chapter 2 RFID Security and Encryption Algorithms

The following sections outline various algorithms and encryption methods recently put forth in literature. Encryption methods are briefly classified as symmetric and asymmetric algorithms; where the former uses the same key for encryption and decryption as opposed to the latter approach. Moreover symmetric algorithms are further classified as stream and block ciphers. Stream ciphers operate on certain data to produce an encrypted bit at a time at the output whereas block ciphers operate on a block of data to produce an encrypted block of the cipher text. Symmetric methods are far less demanding in terms of hardware and software resources and hence draw focus in the context of this research.

2.1 Encryption Preliminaries
In cryptography, the basic elements of logic that are used to develop an algorithm are the XOR function, hash function and substitution/permutation boxes. XOR function is very critical in cryptography; if R is a randomly generated string, C is cipher-text and P is a plain string, we can generate C = (P XOR R) and recover P = (C XOR R). Hash functions can be either cryptographic or plain; cryptographic hash functions produce an output called 'message digest' or simply 'digest' based on plaintext input where each block of data produces a particular string of bits based on a complex function (e.g. checksums or CRC). A plain hash function on the other hand maps the possible blocks of input data to a hash-table. A substitution box (s-box) is an element that accepts an input of 'n' bits and generates an m-bit output based on a carefully designed look-up table to resist cryptanalysis. A permutation box (p-box) is a technique used to shuffle bits across an sbox in order to produce an obscure relation between the input and output. The use of sboxes and p-boxes are necessitated to follow the two most important criteria in cryptography. Shannon's property of confusion and diffusion is defined as the complexity between the key and hash value (in context of hashing) and complexity between plaintext

4

and cipher-text (in the context of encryption) respectively [4]. Another common concept is that of a Feistel structure, which is a symmetric structure used in encryption and decryption and it consists of a series of rounds of either bit-shuffling, use of s-boxes or XOR operations. The following section briefly analyzes the various implementations and indicates the most feasible preference for a lightweight encryption algorithm that satisfies the requirements of a small embedded platform then different comparable encryption algorithms and their advantages and disadvantages are surveyed.

2.2 Advanced Encryption Standard (AES)
Advanced Encryption Standard (AES) is an encryption algorithm that is widely selected to replace its predecessor Data Encryption Standard (DES) in the U.S by the National Institute of Standards and Technology (NIST) [3]. AES proved itself as a strong symmetric key algorithm with a block size of 128 bits and keys of sizes 128, 192 and 256 respectively. AES is available world-wide and it is royalty free. Although this might seem surprising to be adopted by the U.S government; in order to be adopted commercially the algorithm must be available freely. Moreover, security of AES depends on how secret the key is kept. AES uses both s-boxes and p-boxes in its implementation and a normal round is composed of four different transformations: SubByte, ShiflRow, MixColumn and AddRoundKey. The final round is equal to the normal round except that MixColumn is eliminated. As depicted in Figure 2.1, 'Sub Byte' is a non-linear substitution step where each byte is replaced with another according to a lookup table. 'ShiftRows ' is a transposition step where each row of the state is shifted cyclically for a certain number of steps. 'MixColumns' performs mixing operation which operates on the columns of the state, combining the four bytes in each column. 'AddRoundKey' is a state where each byte of the state is combined with the round key where each round key is derived from the cipher key using a key schedule. Different approaches for implementation based on required design criteria are explained in [10] classified as pipelining and sub-pipelining. Pipelining increases the speed of execution by processing multiple blocks of data simultaneously. Sub-pipelining inserts registers between a set of subsequent computations to obtain higher speed proportional to sets of stages; however there is control and area overhead associated with the use of extra registers and the

5

increase in speed depends on the number of stages chosen. Since there are a lot of resources consumed in the AES, it is not suitable for a light weight application in RFID tags.

I

Plaintext

I
I

A1aster key

Add Round Key
....

'

Key Expansion!
J~

Nikey Round SubByte
ShiftR.o\v
Round key

,,

Ni+l key

Round

l~Nr-1

Key Register

:MixColumn
jAddRoundKeyj

Final Round SubByte
ShiftR.o\v

Final Round Key
....

jAddRonndKeyj

I

Cipher

I

Figure 2.1 Structure of the AES Algorithm [9]

2.3 Scalable Encryption Algorithm (SEA)
Scalable Encryption Algorithm was mainly designed to target microcontroller embedded applications [2]. As its name indicates, its most important feature is its scalability; SEA is an encryption algorithm designed to be parameterized according to processor size and plaintext and key-size. Parameterization is based on the assumption that key and text block sizes are the same and in multiples of six word lengths. Although this was originally tested and developed for platforms in embedded software applications using

6

microcontrollers, recent investigation in hardware implementation has been accomplished [2]. Its performance has been compared to AES and it is based on Feistel structure with variable number of rounds. A SEA algorithm is denoted by SEAn,b where n is the plaintext size and key size and b is the processor and word size. The operations involved in SEA are bit-wise XOR, word rotation, inverse word rotation and substitution (s-box) box and addition mod 2b. The main advantage of SEA algorithm is its parameterization for different platforms. SEA is proven to withstand linear and differential cryptanalysis provided that the number of rounds is greater than or equal to 3n/4. The suggested number of rounds for optimum security is a minimum of (3n/4 + 2), where the second term ensures complete diffusion. A typical evaluation of consumed resources is, SEAn,b occupies 4nb words in RAM, nb + 3 registers and (nr- 1) x (22nb + 29) + 20nb + 18 operations for encryption and decryption which is based on its implementation for Atmel's microcontroller platform (nrrefers to the number of rounds). Although proven robust to a series of attacks, the trade-off is the consumption of resources in hardware. It is estimated that execution of SEA, for example on a RISC processor with 128-bit key, can take upto a few milliseconds and it requires a few hundred bytes of memory.
Ll
Ri

KL.. t

KRi

Ci

Figure 2.2 Encrypt/Decrypt Rounds in SEA

Figure 2.2 illustrates encrypt, decrypt and key round functions where: Encrypt round performs Ri+I = R(Li)
EB

r(S(Ri83Ki)); Li+I = Ri

7

Decrypt round performs Ri+1 = R- 1(Li Key round consists ofKRi+1 = KLi
EB

EB

r(S(RiEE3Ki)); Li+1 = Ri.

R(r(S(KRiEE3Ci))); KLi+1 = KRi

C refers to ciphertext, K is the key, R is the word rotation and r is the bit rotation function respectively.

Implementation results in hardware (Xilinx FPGA) corroborate that as long as the processor size is not a limiting factor for the frequency of operation, increasing the word size leads to the most efficient implementation for both area and throughput [2]. A disadvantage of this approach is the use of s-box that consumes considerable amount of memory and is not desirable for lightweight encryption algorithm applications. SEA employs a 3-bit substitution box; its use is not a major disadvantage and can be accommodated if the tag possesses sufficient memory. Flexibility of SEA is its most important characteristic, which can be an advantage due to the variety of implementation options (code size is different in each case). However, it can also be a disadvantage in some cases where a processor or platform prefers to use fixed size algorithms in order to consume fixed number of clock cycles. Due to the restrictions in hardware for RFID tags, the above mentioned reasons present limitations in hardware implementation.

2.4 International Data Encryption Algorithm (IDEA)
International Data Encryption Algorithm was developed by Xuejia Lai and James Massey in 1991 [26]. The algorithm was intended as a replacement for the DES. It uses elementary operations like bit-wise XOR, addition modulo 2 16 (square symbol) and multiplication modulo 2 16 + 1 (denoted by a dot in circle symbol) as shown in Figure 2.3. IDEA operates on 64-bit plaintext block data and produces cipher text of 64 bits using a 128-bit key. The group of 64-bit data input is divided into four 16-bit sub-groups X1, X2, X3 and X4 , which are fed to the first round, and there are a total of eight rounds. The four sub-groups are XORed, added, and multiplied with one another and with six 16-bit subkeys in each round. Between the rounds, the second and the third sub-blocks are swapped. Finally, the four sub-blocks after the eighth round are collected and combined with four sub-keys in an output transformation. Fifty two sub-keys are needed in eight

8

rounds and output transformation, which are generated by the sub-key generator. One of the advantages of this technique is the lack of need for s-boxes and its robustness. IDEA is a patented and universally applicable block algorithm which permits effective protection of transmitted and stored data against unauthorized access by third parties. It is widely adopted in various fields like financial sectors, broadcasting, etc.

Kl

Figure 2.3 Encryption Round of IDEA

2.5 Tiny Encryption Algorithm (TEA) Tiny Encryption Algorithm is a cryptographic algorithm developed by David Wheeler and Roger Needham in 1994 [27], in an attempt to establish lightweight encryption and decryption. TEA uses symmetric encryption; more specifically block ciphers where it encrypts a block of data (64 bits) at a time using a 128-bit key as shown in Figure 2.4. The basic operations that constitute the algorithm are bit-wise shifts and rotations, exclusive or and modulo 2
32

addition operations. The thirty-two bit addition is an

inexpensive operation and is done by chaining four 8-bit additions in the order of least significant byte to the most significant byte. These operations satisfy the Shannon's two properties of diffusion and confusion without the explicit need of complex substitution boxes (s-boxes) and permutation boxes (p-boxes). Feistel ciphers are employed in TEA,

9

which is a special class of iterated block ciphers. The cipher text is calculated from the plain text by repeated application of the same transformation or round function. In a Feistel cipher, the text being encrypted is split into two halves. The round function, F is applied to one half using a sub key and the output ofF is XORed with the other half. The two halves are then swapped. Each round follows the same pattern except for the last round where there is no swap. This is illustrated in detail in Figure 2.4. The value of delta in the algorithm is derived from the golden number, delta= (

J5 -1) 231 that is

represented as Ox9E3 779B9 (Hex). It is known that TEA has certain weaknesses which are accounted for by the designers of this algorithm in an extension to the TEA algorithm called XTEA [6]. One of TEA's major weaknesses is that it suffers from equivalent keys. Each key is equivalent to three others, and this reduces the effective key size to only 126 bits. The related key attacks are possible even though the construction of 2 32 texts under two related keys seems impractical.
Left(i) Right (i)

Left (i+ 1)

Right (i+l)

Figure 2.4 Two Feistel rounds (One round of TEA)

10

TEA is highly resistant to differential cryptanalysis and claims to provide optimum security. Differential cryptanalysis is a means of studying different methods of obtaining the hidden meaning behind the encrypted information (without access to the secret key). This is done by studying how differences in input can affect the resultant difference in the output. The pseudo code of the algorithm is shown below. Encode Routine
void code(long* v, long* k) { unsigned long y=v[O],z=v[1], sum=O, /*set up*/ delta=Ox9e3779b9, n=32; while (n-->0) { /* basic cycle start */ /* a key schedule constant */

sum += delta; y z += ( ( z < < 4 ) + k [ 0 ] ) " ( z + s urn) " ( ( z > > 5 ) + k [ 1 ] ) ; += ( ( y<<4) + k [ 2] ) " ( y+sum) " ( ( y>>5) + k [ 3] ) ; /* end cycle */ v[O]=y; v[1]=z ;}

It is seen from the source code, that decryption is essentially the same as the encryption

procedure with a reversal of steps. Decode Routine
void code(long* v, long* k) { unsigned long n=32, sum, y=v[O],z=v[1], delta=Ox9e3779b9, sum=delta<<5; /*start cycle */ while (n-->0) z y {

( (y<<4) +k[2]) " (y+sum) " ( (y>>5) +k[3]); ( ( z < < 4 ) + k [ 0 ] ) " ( z + s urn) " ( ( z > > 5 ) + k [ 1 ] ) ;

sum-=delta;
/* end cycle */

v[O]=y

v[1]=z ; }

TEA is arguably neither the fastest nor the shortest algorithm however it provides a perfect balance between ease of implementation, consumption of minimal resources and

11

compromise between safety and size of implementation. Due to which it is an ideal choice for deployment in RFID systems.

2.6 Extended Tiny Encryption Algorithm (XTEA) As pointed out earlier, TEA presented certain weaknesses which were taken care of by introducing certain changes in the original algorithm resulting in its extended version called XTEA [6]. A block diagram ofXTEA is depicted in Figure 2.5. Whilst maintaining the simplicity of the algorithm two tasks are performed: · · Adjust the key schedule To introduce the key material more slowly

left(i)

right(i)

left(i+ 1)

right(i+ 1)

Figure 2.5 Feistel Structure for XTEA for two rounds There is a re-arrangement of add, XOR and shift operations in order to induce a more complex key schedule. This is illustrated in the source code given below. 12

XTEA Encode Routine (Pseudo code)
vo id e n c ipher(uns i gned l o ng * v , unsigned l o n g* k ) { unsigned l ong vO =v [ O], v l=v [l], i;

unsigned l ong s um=O , de l t a =Ox9e37 7 9b9 ; for(i=O ; i < 32 ; i + +) vO += ( (v l << 4 A vl >> 5 ) + vl ) A ( s um+ k [ sum & 3 ] ) ;

sum+=delt a; v l += ( (vO << 4 AvO > > 5 ) + vO ) A (sum + k [sum>>ll & 3 ] ) ;

v [ O] = vO ; v [l] =v l;

The changes due to XTEA bring about the following advantages:
· It corrects the mixing proportion of TEA

·

Eliminates the key-related attacks due to key equivalence classes

A hardware implementation of XTEA was performed using multiplexors and registers to perform the 32-bit operations [7]. The sequence of operations is controlled by a finite state machine, which generates the required control signals to drive the datapath. A comparison of TEA and XTEA is made to compare the area consumption of different units like the adder, shifter, controller, etc. as shown in Table 2. [7]. The results clearly show that the area consumption of both approaches are nearly the same. XTEA on the other hand consumes more clock cycles (e.g. 705 clock cycles for XTEA and 289 for TEA) compared with TEA and also consumes more power (3.86f.lA compared with 3.79f.lA) [7].

Table 2.1 Comparison of Implementation Results of TEA and XTEA
~1odule/component

Chip area (GE}

(%)

Eight 32-bit . register Arithm.etic-logk unit (ALU) Constant Shifter
~1ultiplexer

Controller (FS~I) Otbers

1592 347 5 179 180 258 75
2,636 2;633

60.4 13.2 0.2 6,8 6.8 9.8 2.8
100 99.9

XTEA.total
TEA total

XTEA thus resolves the weaknesses of TEA; however both algorithms claim to provide

13

extremely lightweight application and acceptable (medium) security for use in the industry.

14

Chapter 3 RFID Authentication Protocols

3.1 Introduction Development of robust authentication protocols is imperative in today's applications; a common example is "key-less entry" in cars where the RFID tag in the key is activated as the driver approaches to open doors and control the ignition system. Other critical examples include potential applications in RFID enabled passports and human implantation for health monitoring. An authentication protocol is a safe way to identify if a particular RFID tag is genuine and belongs to the system. This is very crucial in order to avoid common problems such as replay attack, eavesdropping, cloning, counterfeiting, spoofing, jamming attack, etc. Moreover, it is important to ensure confidentiality, message integrity and availability of the system [12]. The major challenge in designing an authentication protocol is to find a compromise between security and cost. The classification of authentication protocols can be based on three points as given below · · · Underlying algorithm used in the protocols. Procedure of message exchange. Secure combination of above two.

The first point has been discussed in detail in the second chapter. Chapter 5 will present possible approaches to accomplish the last goal with respect to a light-weight symmetric encryption algorithm such as TEA. Design of an optimum authentication protocol forms the crux of security and privacy of an RFID system. An authentication protocol precisely deals with the second point; specifically, the message exchange has to be performed securely or in a 'secret' manner over a wireless medium. Primitive forms of authentication include a challenge-response method between a reader and a tag. An RFID reader initializes a challenge request and a tag responds with a secret value (computed from the key - typically symmetric) and sends this result to the reader as a response. The reader verifies this result from its database to verify the authenticity of the tag.

15

There have been several approaches put forward recently by researchers addressing issues mentioned beforehand, and techniques to overcome them; specifically where a reader must authenticate a tag before exchange of data and also methods where a tag needs to authenticate a reader to ensure privacy [20],[28]. Moreover, mutual authentication protocols also exist, where the tag authenticates validity of a reader in addition to tag-reader authentication. The following sub sections explain various proposals and evolution of authentication protocols as of today in light of requirements such as cost and security and also resistance to various attacks.

3.2 Attacks to RFID System An authentication protocol is mainly judged by its ability to provide resistance against common attacks encountered by the system. Several attacks are possible and are taken into consideration while designing an authentication procedure. Eavesdropping is a familiar attack where an adversary intercepts a response from the tag during wireless communication between a tag and the reader, and tries to extract critical information like the tag's ID or the secret key used for secure communication [19]. This is mainly established through cryptanalysis. Replay attack is another form whereby an adversary intercepts response from the tag and relays it to the reader; response from the reader can be later used in another session by the impersonated tag [ 14]. Location tracking is an issue where if the information of a tag (such as its ID) is leaked and becomes available to the adversary, further responses from the tag can be easily tracked thereby revealing the location of the tag. Denial ofService (DOS) is a type of attack caused by an adversary to disrupt handshake between reader and a tag by intercepting or blocking the wireless transmission [ 19]. This leads to de-synchronization in the communication between a tag and the reader. It is thus important to keep track if a session has been terminated correctly or not. Cloning attack is a common form and can be accomplished in different possible ways. For example, physically cloning the contents of the tag or impersonating the original tag from its responses. Other forms of attack (counterfeiting, spoofing, etc.) more or less arise from or are closely related to the above mentioned attacks.

16

Other metrics include Forward Security where the contents of communication prior to being attacked should be safe; i.e. by finding key information from a transaction, the adversary can recalculate the key value and verify contents of the previous session. Moreover in case of a compromise, further transactions must be ensured security. This is normally established by varying the key value. In the design and analysis of any protocol (current or new) security and privacy analysis is executed by keeping these measures under consideration. The more types of attacks a particular protocol can prohibit or at least provide high resistance to, the more secure is the protocol's design.

3.3 Fundamental Approaches in Authentication This section briefly describes the primitive approaches to establish authentication in a system. A hashed value of key is stored in the tag's memory called metaiD, either wirelessly or over a secure channel and this process is termed 'locking' [15]. Once locked the tag remains in this state until it is queried by a legitimate reader to unlock it, and gain access to its contents. The reader queries the tag and gets the metaiD as a response. The reader now acquires the correct ID from its back-end database and sends it wirelessly to the tag. It is clear from this simple protocol shown in Figure 3.1 that the key could be easily intercepted by an eavesdropper and the tag could be spoofed.
Query metan> metall)

(keyJD)

Reader

key

Tag

ID

Figure 3.1 Basic Hash-Locking based Scheme [15]

Another approach that follows as an improvement to this method is the randomized access control [15]. In this method, the tag is equipped with a pseudo-random number generator. A random number 'R' is generated by the tag in response to a query and the value (R, h(ID II R)) is transmitted to the reader as shown in Figure 3.3. Here, 'h' is a hash function and II refers to concatenation operation. The reader uses the 'R' value to

17

perform calculation ofh(ID

II R) in a brute-force manner till it finds a match. To further

improve the algorithm and provide a strong mode of secrecy a provision can be made where keys are only stored at the back-end database. In this case, the tags are equipped with a Pseudo-Random Function (PRF). A PRF is essentially a deterministic function or a module that accepts a variable number x and a constant seed (hidden value) k to produce a function f(x, k) or fk(x). In terms of implementation, a PRF block can be designed as a look-up table as shown in Figure 3.2.
X

k
Figure 3.2 Pseudo-Random Function (PRF) Block

There is significant amount of research and probabilistic study to ensure that the PRF generates all values to be randomized and to gauge if a particular PRF is a 'good' or a 'bad' function. The tag is equipped to generate fk(x) and now responds with (R, (ID h(ID))
Ef1

II

fk(R)). As mentioned in section 1.3, if A
Ef1

Ef1 Ef1

B = C then knowing C and A, B can B =A (if C and B are known). Now

be recovered using the operation C

A= B or C

the reader calculates fk(r) and XORs it with (ID

II h(ID)) Ef1 fk(R) to get (ID II h(ID)). This

value is searched among a list to find a match. This method is useful because an eavesdropper getting any information from the transaction will not be able to acquire the tag's actual ID without the PRF generated key.

Query

Get aiiDs
Reader

R.h(IDk II R)

Tag
IDk

Figure 3.3 Randomized Hash locking Scheme [15]

18

In order to reduce computational complexity at the back-end database due to brute force search method, a slight modification was proposed by Li et al. [ 18]. The tag sends (R, h(ID II R), h(Px II R) where Px is some product information (for example, product category code) where instead of the tag replying to a query with only (R, h(ID

II R)). This enables

the database to decode the value of Px so that instead of searching the entire system of records, it can search for the ID within the product code category. This is a significant improvement for applications in retail management and stock inventory.

It is thus apparent how authentication procedures have evolved to suffice some of the

basic requirements of RFID system by providing tag authentication to the reader without the exchange of the actual key. Based on research, simulations for authentication protocols in software hardly exist to the best of our knowledge, although real simulation of an RFID environment using hardware is executed in few research spaces around the world and is a far more expensive approach.

3.4 Authentication for Location Privacy and Forward-Security
Although the above mentioned techniques are developed such that the key remains unexposed during wireless transmission, there are other possible attacks that may arise leading to a compromise in authentication. For example Kim et al. and others analyze the importance of protecting the tag identifier (ID) [13]. This value is typically encoded by a manufacturer and it is embedded in the tag's memory. Since it is unchanged throughout the tag's lifetime, location tracking may occur if information is leaked thus leading to a compromise in security. A method to update the key during each transaction has been put forth recently [ 13]. The main assumptions of this work are that the tag possesses an ID that is unique, a secret key (key) and has an encryption function (E). Moreover, the encryption scheme used here is a stream cipher. The reader is equipped with a pseudorandom number generator (PRNG), E and the back-end database stores details of all pairs ofiD, key and E' 10 , R'; where E' 10 refers to the encrypted tag ID using the current key by an operation done in the database and R' refers to random bit streams generated in the database.

19

The reader generates a random number S and sends it to the tag. The tag now generates j{ID II key) which is generated in the form of streams R 1, R2, R3 and~; from this the unique ID in the tag is XORed with R2 which gives E 10 . Tflag is a flag kept to know whether the last authentication transaction is successful or not. If T flag is 0 it means the authentication is successful and if this is a non-zero number it means otherwise. In the latter case, R 1 and R2 are re-generated fromj{ID
EB

key)

II key EB S) while R3 and~ remain

the same. The tag now sends Rt, Em, Tflag and S to the reader which recognizes Sand therefore the validity of the tag. Also, these values are passed on by the reader to the database for verification. Meanwhile, the tag changes the value ofTflag to a non-zero random number to indicate that a response from the database is awaited. The database checks the value ofTflag in its records; if this is zero, then the following procedure for updating the key value is performed.

Procedure Challenge Responded (Pseudo Code) [13]
Input: R1, EID, Tflag, S EID If Tflag == 0 Then Search E'ID If E'ID.count > 0 Repeat i
~

i + 1

If R'1 == R1
Lkey ~ Ckey Ckey ~ R' 3

LR2

~

R' 2

Until i <= E'ID.count Return 0

In case T flag has a random value, it is implied that the authentication in the previous transaction is not completed successfully leading to a loss of synchronization between the tag and the database. A new procedure is executed to establish a temporary value of Rtemp and EtempiD till it finds the original ID.

Procedure Challenge Incomplete (Pseudo Code) [13]
Input: R1, EID, Tflag, S If Tflag != 0 Then Generate Rternp,EternpiD Search EternpiD == EID If EternpiD.count >0 Repeat i
~

i + 1

20

If Rtemp == Rl Return EtempiD Until i <= EtempiD.count Return 0

This protocol contends to provide security against replay attack (man-in-the-middle attack). Since the value of ID characterizes the response as being from the tag, the database rejects any replay of the message sent by the tag. Moreover, since the ID is encrypted an adversary cannot gain this value through cryptanalysis. As put forth by Kim et al., a symmetric algorithm is employed for location privacy and forward security, however it adds a huge computation load on the back-end server in case of large number of tags. It is also contented that in addition to excessive calculations, replay attack may be possible through counting statistics [14].

3.5 Authentication for Low-cost tags This section analyzes a protocol put forth very recently by Li, with a goal of lowering the cost ofRFID tag production [17]. Since the area and power consumption of the circuit are directly affected by the number of gates in the system, the protocol is designed to keep computational complexity to a minimum. This is accomplished by eliminating encryption and hash functions and utilizing simple operations such as XOR and modulo 2 additions. This system assumes that a tag is equipped with a pseudo-ID (PID) which is subject to frequent changes (updates) and a permanent ID stored in its memory. Moreover, it possesses two keys K1 and K2 (which will also be updated). The database stores PID, ID, K1 and K2 for all tags in the system. Initially, the reader sends a hello message to the tag which is responded by PID from the tag. The reader finds (K1

II K2) corresponding to this

PID value from the database and generates a random number r and computes A and B and sends them to the tag. The tag decodes the random number value from A and Busing the secret keys K1 and K2. If both the random number values from A and Bare the same (which they should be), the tag computes C and sends it back to the reader. The reader checks if there is a valid ID from the message C it just received. If it is not, then the operation is aborted otherwise it continues to the next phase of updating the keys and PID. A snapshot of the protocol's pseudo code is illustrated below.

Tag identification:
21

Reader
Tag~

~

Tag: hello

Reader: PID(n)tag(i)

SLMAP mutual authentication:
Reader Tag
~

~

Tag: AI I B

Reader: C (C')

where: A B C PID(n)tag(i)
ffi

Kl(n)tag(i) + r
ffi

PID(n)tag(i) + K2 (n)tag(i) (PID(n)tag(i) + IDtag(i)
ffi

r
ffi

r

(Kl(n)tag(i)

+ K2(n)tag(i) + r)

After authentication of reader and tag, the keys are updated as follows,
PID(n+l)tag(i) K2 (n)tag(i))
ffi

(PID(n)tag(i) + Kl(n)tag(i)) r
ffi

ffi

r + (IDtag(i) +

Kl(n+l)tag(i) = Kl(n)tag(i) IDtag(i)) K2(n+l)tag(i) IDtag(i)) K2(n)tag(i)

r + (PID(n+l)tag(i)

+ K2(n)tag(i) +

ffi

r + (PID(n+l)tag(i) + Kl(n)tag(i) +

In case of a synchronization loss due to an attack, status information of previous protocol run is stored in a flag. It also establishes confidentiality since a nearby eavesdropper may capture the message but would not get any information without the actual key values as well as tag/reader authenticity (reader-to-tag and tag-to-reader due to exchange of messages A, Band C). Moreover, this algorithm may not provide the highest possible level of security. It establishes a light-weight authentication protocol with minimal number of gates (less than 300) as opposed to a few thousand gates as required by techniques employing encryption algorithms by using bit-wise operations.

The techniques for authentication studied here present a design to overcome a single or a combination of attacks in a system. The most commonly used components are hashfunction generators and XOR gates as they consume very little hardware. Complex components can be integrated in the system depending on the level of security desired. Liu presents an eleven-step protocol that employs a stream cipher to overcome replay attack, loss of synchronization, wiretapping and provide security measures like forward

22

security, indistinguishability and synchronization between the database and the tag [ 19].
It is always aimed to design a protocol that provides a compromise between the cost and

security.

23

Chapter 4 Implementation of Tiny Encryption Algorithm

4.1 Overview TEA was originally implemented in software (comparable to the performance of DES) however, it has conveniently migrated to hardware platforms mainly due to the ease of implementation despite restricted resources in hardware. A hardware implementation of TEA could be designed as an intellectual property (IP) core. Requirements of the design can be specified and classified as functional requirements which entail the width of input data, latency of encryption, number of gates consumed by the design, power consumption, etc.

The design is developed using a hardware description language specific to a platform (e.g. Xilinx, Altera FPGA) and tested using waveform simulations. There are several CAD tools available to establish and test the design including Active HDL, Altera Quartus and Xilinx ISE for (Hardware Description Language) HDL simulations to verify functionality of the system. There are different methods in which the system can be designed e.g. either by separating the control path and data path or using a finite state machine (FSM) to control the flow of both. Hardware implementation of TEA has been accomplished in the past using HDL leading to CMOS implementation ([6], [8]) and using a microcontroller [30]. Tiny encryption algorithm is one of the simplest algorithms to be implemented in hardware. It can be employed, where time is a constraint, i.e. a trade-off can be made between the levels of security desired and the time to encrypt or decrypt, in terms of number of cycles.

4.2 Functional Requirements of TEA The functionality of TEA must be verified using a simulator to validate the operation of both the encryption and decryption schemes using waveforms. We have used Active HDL 7.1 simulator which is chosen due to its simplicity and ease of generating and 24

applying test vectors. It must occupy minimum number of gates or configurable logic blocks (CLBs). Plaintext must be successfully converted to encrypted cipher text in accordance with the algorithm after 64 rounds or 32 clock cycles. The encrypted output when fed back to the decryptor must successfully retrieve the original plaintext.

4.3 Input/Output Requirements of TEA
The input signals of TEA are specified as following: · · · · · 64-bit input data (plaintext) 128-bit key (symmetric) Reset signal Clock signal (for synchronization) Input data rate (3 2 kbps or 64 kbps)

The outputs must include the following: · · · 64-bit Encrypted data (cipher text) Ready signal Output data rate (3 2 kbps or 64 kbps)

The block diagram of Figure 4.1 illustrates various I/0 signals required for TEA implementation. Clock is necessary for synchronization between encryption and decryption modules. Ready is needed to specify validity of the output at the end of enr,ryption/decryption. The input vector data refers to plaintext, key is 128 bit long and the output ' Data' refers to the cipher text. We have opted for the encryption implementation in hardware using VHDL and decryption in software using C language in Altera Nios II IDE. Details of the block diagram are explained in the following section.

Data
Key Reset

.. :::>
;;:.

... ..
...

TEA Encryp tio nfD ecrypti on

... >

Data Ready

Clock

..

Figure 4.1 Block Diagram for TEA algorithm

25

4.4 Design of Encryption/Decryption Modules

TEA can be represented as a flowchart as illustrated in Figure 4.2, where v[O] and v[l] are 32-bit plaintext inputs and 'n' represents the number of rounds. The cipher text result is available after 32 rounds are completed.

Plaintext

v[O]:v[l]

Initialization

l

y =v[O], z=v[l] delta= Ox9e3 779b9 n= 32, sum.= 0

J,
N<l

Encoding y += ((z<<4)+k[O]) $ (z+sum) $ ((z>>5)+k[l]); z += {(y<<4)+k[2]) $ (y+sum) $ ((y>>5)+k[3])~

Yes

Final Round

v[O] = y, v[l] =z

!
Ciphertext

v[O],v[l]

Figure 4.2 TEA Flowchart

26

The input data of 64 bits is split into two halves Y and Z of 32 bits each, where Y is the most significant bit (MSB) and Z is the least significant bit (LSB). The 128-bit key is also divided into four blocks of32 bits each; k[O], k[1], k[2] and k[3] for internal calculations. The encryption module is designed as a finite state machine (FSM) having 18 states as illustrated in Figure 4.3. All the states are synchronized using the clock signal and the entire process contains clock and reset signals in its sensitivity list of inputs.

32 rounds complete

1

Z>>5 + k[l}

L

= Z <<4 + k[O] + Z +sum + Z >> 5 + k[1]

R = Y << 4 + k£2] + Y +sum+ Y>> 5 + k£3]

Figure 4.3 State Diagram for TEA Implementation

The symbol>> is used to indicate right shift and symbol<< is used to indicate left shift respectively. Beginning with the initialization (init state) where all intermediate values are properly initialized, including key and input data values. The next state (updatesum) keeps track of the number of rounds (if less than 32) proceeds to the next state
(fourbitLSZ) else moves to the state done. State fourbitLSZ performs a 4-bit left shift of

the 32-bit LSB (Z). The next state, Lshi.ftZkO calculates ((Z << 4) + k[O]) where k[O] is a 32-bit MSB of the 128 bit key. After this, the statefivebitRSZ performs a 5-bit right shift operation of Z and the state machine transits to the next state Rshi.ftZkl that calculates ((Z 27

>> 5) + k[l]). The next state CaleY computes the term L = ((Z << 4) + k[O]) + (Z +sum)
+ ((Z >> 5) + k[l]), where Lis an intermediate register used as a buffer. Following this calculation the state Update Y evaluates Y += ((Z << 4 + k[O])
EB

(Z +sum)

EB

(Z >> 5 + k[l]))

or Y = Y +L in accordance with the TEA encryption source code. The new Y state updates the newly calculated value ofY to be carried forward in the next round of encryption. This completes the first round.

The second round of the encryption algorithm, begins with the state fourbitLSY which calculates 4-bit left shifted value ofY. State LshiftYk2 computes ((Y << 4) + k[2]). This is followed by fivebitRSY which performs a 5-bit right shift operation on Y. State

RshiftYk3 determines ((Y >> 5) + k[3]). CalcZ is the next state in sequence that estimates
the value ofR, where R is a temporary register used to store the value ofR = ((Y << 4) + k[2]) + (Y +sum)+ ((Y >> 5) + k[3]). The next state (UpdateZ) assess the value of the following, Z += ((Y << 4) + k[2])
EB

(Y +sum)

EB

(Y >> 5 + k[3])) where Z = Z + R.

newZ is the next state that updates the recently calculated value of Y from the second
round. The next state in sequence checkrounds checks if 32 cycles are completed based on a counter. If so, it moves to the delay state otherwise it transits to the update sum state to begin the next set of rounds in the cycle. The purpose of the delay state is to ensure enough time for the output to stabilize before it can be passed to the decryptor entity and consumes only one extra clock cycle. This completes the encryption cycle.

The decryption is implemented and tested in two ways. The first is the hardware approach using VHDL similar to the encryption implementation. This approach also utilizes 18 states in a finite state machine (FSM) to perform all the operations mentioned earlier, in the reverse order. The reason for so many states between different calculations is to ensure that the all values are updated at the rising edge of the clock cycle. The second implementation that has been accomplished is a software approach using Altera Nios II IDE. This is relatively simple to execute since the source code is readily available [27], [30]. It must be noted that the code is implemented using small C library in order to minimize the memory footprint for the FPGA platform (Altera NIOSII).

28

4.5 Testing and Verification Results
One of the first steps in testing the functionality of the circuit is verification using waveforms. Active HDL 7.1 provides a simple method of applying stimulus to input vectors by using a macro file (source code in Appendix) which basically defines the clock frequency, assertion of reset and duration of the simulation. The clock frequency used is 2 MHz i.e. 500 ns clock period. For example, an input of0x0123456789abcdef(64 bits) is provided and the encrypted value received after 32 rounds
(~1090

clock cycles) is

Ox126CB92C0653A3E. The key value used is Ox00112233445566778899aabbccddeeff (128 bits). The encryption cycle proceeds through an FSM as described in section 4.4 and results shown in Figure 4.4. A zoomed-out version of the process presented is (first 9 rounds) in Figure 4.5. Every signal can be monitored and internal counters (counter and counter 1) are employed for the left and right shift operations.

N am e

1 vatue

1 ~1

I

o ,5

I

·

.:~.:. ~. ~~.. . . . . . . . . . . . . . . . . . . . . . . . . . I. ~~~~~~!.!.. . . ..!.J~~~~~~~.~~.~~. ~.S.~.~. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . ~ . ~~ ~. . . . . . . . . . . . . . . . . . . . . . . . . .. i.~..... .. .... ... .. . ...l. .:LCLCEi=~: .~. ~. ~~!~.~=.~.~.P.~. . . . . . . . . . .... . . . . I. ~~.?. ?.!. ~.~.~. . ...L.~~.:.~ . ~~.~~. . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .... . ... . . . . . ...... . ....... . . . . . . . ... .... . . . . . . . . . . ... . . ... ... . . . . . . . . . . . . . .. [£ kO ............................................... . 1. ~~~. ~ .~~~~ . . . ..1 ... ~~~~~~~~~.~~.~~.~ ..~:.~ ......................................................................................................................................................................................................................................................................
M

'i'ioio··~~· 1 ~

·

?.

I

2,5

I

·

~

·

I

3,5

I

· .

~

·

I

4 ,5

I

·

~

·

I

5 ,5.

I

·

~

·

I

s,5

I

·

?.

I

r5

I

·

?.

:.

L£ M k2 E F M k3
·: Fs ·;~~·~

. . . . . . . . . . . . . . . . . . . . . lCCDDEEFF. . !
T ~~d~~·~·~~~

...............

.l .~~~~~.~. . ...l. J~~~~~~~~.~~.~~.. ~.~~.~. . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . .... . . . . . . . . . . . . . . . . . . . . . . . . . . . .... . . . . . . . . . . . . . . . ... ... . . . .... . . . . . . . . . . . .... . . . ...... ...
Kuuuuuuuuxcc
T l;~·i~

. . . . . . . . . x. . . . . . .

DEEFF

~~~·;~·i·;;~~

... . ...... . .. .... .. .. .... ..... . .....

-x;~~~;

..

·~;~·~~·i·;;·~~

................. ................ . . .. ........

x;-~;·~; ·x;~;·~·;

.

. ;1

E f

M

lshiftedz

!00000000 ! Koooooooo
:UUUUUUUU ! ; uuuuuuuu jUUUUUUUU j Kuuuuuuuu
:
~ ~

X
$ .......

XSACE0123

.......................................................................... ,................................. f .. ·f~ .........

l£ M lshiftedy

rt.J M rshiftedy
[±) M

= . . .= . . .:;.:. . = . . .:.;:. .= . . .= . . :.;.:. = . . .= . . .:;. :. . = . . .= . . .:;.:. .= . .= . . .:.;:. .= . . .= . . :.;.:. :.;.:.= . . .= . . :.;.:. :.;.:.= . . .= . . :.;.:. = . . .= . . .:;. :. .= . . :.;.:. = . . .::: . . ..
.............................................................................................................................................................................................................................................................................

································· · ··· · ··· ··············· ·········· ·· ······i········· ··· ·· ······ ·············1···~· ····· · ·" '''''"······· · ········· · ··

l'~ ; · ;·~·~·~·(~·~

t±: M

.

i00000000 i KOOOOOOOO ; ................................................... ................................. ... ................................................................................................................................................................................................................................................................................................. A . . . . . . . . . . . . . . . . . . . . . .lo ioooooooo . . . . . . . . . . . . . . i K..._(oo=oo=ooo=o=-+--=====----=-------------------. . . . . . . . . . . . . . . . . . . . x;. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
L
T "k~

................................;................................. ~ ... ~ ................................................................................................................................................................................................................................................................................................... .

~.~.!_ . . ___ . _. __ . _ . .__~!~~~~~!.--L~..._~2=~~=~~=~= -. = . -~ ....= - .= -= -.= . -= -= -.= - .= -= - .= -= ...= . . .= -= . -= . . .= -= . . .= -= - .= -= -.~ - .= -~ . . .~ -= ...~ -~ -. ~ . . .~ -~ . _~ _~ . -~ . . ------~ .r~. ~. ~. . . ..................................................J~~·~·~·~·~·~. . .!J~.~~.~:.~:~. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ~. ~. .~~~~~~~::.~.~.~~~~·~·~·~·~:.. . . .i. ~~~~~~~?.. . . ..!.J~.~~.~~.~~.~. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. !...................................... 00000000 ! Koooooooo .(f. . .-() . . . .encrypt_outputLSB_Z . . ... .... . . . . . . . . . . . . . . . . . . . . . . .; '.-.-.= . . .= . . .= . . .= . . .= . . .=t .....= . . .= ...= . . .= . . .= . . .= . . .= . . .= . . .= . . .= ...= . . .= . . .= . . .= . . .-. . .= . . .-. . .= ......= .....= ......= . . .-. . .= ...... ........... ......-..... ................. ....................................................................................... ~~~ ~~~~~~~~~~~~~~~~~~~~ .

Figure 4.4 TEA Simulation waveform illustrating transition of states

29

.

..,..,--.,...,--,---~--,-----c----,-,-~-----,-~------,---,----,---,-,-----,-----·--

Name ... elk

' z_o'

o

I

·

3 ,0 1:

.I

·

4 .0

o

I

o

~.0

·

I

·

6.0 '

I

'

7.0 '

I

~.0

'

I

!

9 ,0

!

I

'

1QO

I

'

110 '

I

'

1.?0

I

'

1~0

I

'

1+0

I

·

11)0

Ltl Ar deka_cop
u

' E377989 fivebitrsz

State

' ' ' ' ' ' ' ' ' ' ' ' '' ' ' ' ' ' ' " " ' ' ' ' ' ' ' ' ' ' " ' ' " ' ' ' ' ' ' .i, , ,;, , ,,,MO ... OOOOoOOOO

ifJM sum

!2E:2AC136.
j10

:~ ar rounds
H 'J u counter1

io
:o
~ l±l ·lsh~t~d~---·---r;·a096sF3 ·--··ra~~~~~;~·;

~i· ;;;·;~hif~~dz ...J~~-~-~~-~!. --··rEJ:48A2C4ES ):4ASA2;;·········~ LtJ AI" lsh~tedJ) !C4529FCB ··r·~~-;;;-~;·;~~-·--·· *10E53A6B *AE8242EB -*~-~~~;~~-· *CA84~~7B ····---~~-3SF274~·.: .· :::· :·*--~~~~:~i.~·- · :::~ r±l Ar rs~ftedy ····rc:-~Ri·c:·8·79.. T K~~~~~~------*~·~;;;~· ·····::·::·. :·::*-§.~~:~i.~~-:·:.:·_-:]~~?.~-~-~~~-------·--i~~-~~;;~--·--····--i~&mss ~04035990 to39092 09 ~ t* lM L !8D6nDF9 ...:::..r:. ~~~-~~~~:?.·::·:··:·::.:::x~~-56557F · --··x294B$8i\S xos090088 Xo181FAOA X300E205F XBASE~~oo . . . . . xo;~;~-~~-········ -~ FH M R ············;·Fso?s2so : Kuwuwuu xs3sFE34s ·······x~ssossc7 x333ss88s XEscEo1c7 . . . . . X 2 FFA74BA XFDirossF xFssoo52 E ···xFs5F7~·;; ......... ~

.

{fj :,.;. y.............................T 638s8F51

I c:=xF682C704

x~~~;1~·~;····~· .. ·mn··x(;;54~8FB

X12£8983

XM10838·~ ..................x~-~~~-~~-~-~ ~·-······..·xFEA057C~'"'"''' ""X~~-5~·~;~; ~·

. ..... ~

:lfi: ·~ ~. :::·:·. : : : · · : ·::. :!·~:o.~·F.·~~~-~....: : rJ~~~~~:~~~:·:·::::-:x~:~~~~;i.~::····:. : ·:~x.~:;~~:~~:o~:. : . : : :::x~-~~~~~-s.:. .. . .J~~F~.S.~.~~- . .·: . :::::~:~~-8-~900

xcoOAAFCC . . ·xc~988~·F·~ ---· · · . .-x;F802 0C

X

Figure 4.5 TEA Simulation - First 9 rounds of encryption cycle

After 32 rounds the output produced can be seen in Figure 4.6 as encrypt_outputMSB_ Y and encrypt_outputLSB_ Z. For the purpose of testing the correctness of the encryption, after the output Ox126CB92C0653A3E is obtained it is passed on to the decryption module. If the output retrieved is the original plaintext, then this confirms the functionality of the encryption module. This is verified as shown in Figure 4. 7. It is observed that after around 1090J.ts the output is the same as the input i.e. Ox123456789abcdef

M

State

!delay
i 447E38AF iAF6063D8

[±] nr lshiftedz i 518 8 92F3 ........ ·····························································································--~~~~~~~~~::::=t===~~~~:::::::::~z;:

iB M rshiftedz

---------------------· ---------~--~ - ~~~~~~~~~~~~~~~~~
f+J M rshiftedy i CD 715258
ft.! III L

±l nr lshiftedy

i D9CC7770
.............................................

f±J111' R

i 884A9332

-~-~-~---------- 1 32
[f.j MY

_____ i126C6892 i

L _b~9~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.... ........ .JC0653A.3E
r±J -o encrypt_outputMSB_Y

!126C6892
j C0653A.3E

l±l -o encrypt_ outputLS 8_z

Figure 4.6 TEA Simulation Waveform- Output after 32 rounds of Encryption

30

Name

rn :::~.=~~~;
lfj
M

- - ~ -!·9E:·;·7·79·9·9··· · ·f
1

. .:r ··································································································································································································································································
····················································· ....................... ........ .

cio11.2233"·····TT·················· ····························

~-~i~==~==~~~=~====]~~~~~~~~~~~ ~~~~~~~~~~=~=~~~~=~ ~~~=~=~=~=~~~=======~= -= - =-= -= -= -= -= -= . ~= -= -= -= -= -= -= -= -= -= -~ -=~=========~~=== -= --= -= -~ -i ii
ft.] M k3
M

k1

............... ....................................................................................................................................................................................................................................... l 44556677 l i

........... ....... ...........

CCDDEEFF

State

·····-r···h: . ······~ ········;;:; ········~·······~ ········F: ········~ ········:;::· ······~ ········~ ·······;:;; ········;;;: ····· :::;:::~~~~;::;::~;::;;;::~:::::::::=== ....................... ..... ~ ...· ! f-J · ~~\....JI~II"\..JI~I\...II~II\...Il~ ··\...1·~''"\..J'al..J''-''~'·"\..JI~I"\..JI-.J.....II"\..J~t"\..JIIII.l.....do_nto __

L ±.' AT lshiftedz

. ..

-~~:. ~. r.~~!~.~~~~. . . . . . . . . . . . . . . .... . . . i. ~~7E~-~-~-~.......! . .~~~-~:.~~-~~. . . ... .~:.~~-~~-~~-~. . . . . . . . ~:.~~.:.:.~~-~. . . . . . .~:.~~-~:.:.:~. . . . . . ..~:.~:.~~:.~~. . ... . ...~:.~.~:.::.:.~.. . . . . . . ~ ~-. !~.~-i_ft·~-~~ ..................................- ... .l.~-~-~-~-~-~-~-~. . . .L.f.~.~~-~~-~~. . . . . . ~.:~.~~.:.~~-~. . .. .... ~~.:.~:.~:.:.~. . . . . . .~~~:~.~~.S.~. . .. . . . . ~~-~:.~~~.:.~. . . . . . *-:..~~.S.~.~~~. ..... .-.. . . . . . . . . -~~. ~. r.~~!~.~~~~. . .. . . . . . . . . . . . . . . . . .JE~.!..~--~-~-~-~. . . J..~~.:.:..:.:.:.~.S. . . . . . . ~~-~~.:.~~-~~. . . . . . .~~-~~-~:~.:.~. . . . . . .~~-~:.~~.:.~.S.. . . . . . . ~~-~~.:.~~.:.~. . . .... .~~~-~~-~~-~~... . . . . . . . . . . . . . . ..
F fJ
M

L

ID9CC7770 I [XFD1106BF
.

X2FFA74BA

XE8CED1C7

X3336888B

X468058C7

X._B3_B_FE_34_B_ __

.0::~::~.: : :.: : : : : : :.: .: : : : : : : :·: : : .: : : : J ~:~:~:~:~:~:~: .: .:r::~~~~:~:~~~~::::: : : : : :g~~~~:~:~~~:: :·: : : : :::x~:~i.~~~~:~:::: : : : : : :x~:~~~~~~:~::: : : :·: : ·x~~:~~~:~~~:: : : : : : :::x~~:~~~:~~~:: : : : : ·: .

.~. ~.:i.··:. · . :.: :· : :::·. . ..: : ·. : : :.: .::::::n:~~~:~:~:~~: : : :r: :~~~~:~~-~~:~: : : ·: : : ·: : ::~::~~~~~:~~:~:~:: : :· : ·::-:x~:~~:~~-~~-~·: : : : : : ::::x~~:~~~:~~:~: : : : : : :x~:~~:~~:~~:~::·: : : · : ·: :
[±] AT

[±] AT rounds

!32

X28

X29

X3o

X31

X~.-32----------

Z

.

...... 26C6892 .l.... t l ;: [£ -~---~~c.rY.~~~-~~-~~~~-~-~-~~~---···· ·: c-~-~-~-~~~---····~---· ~ · . .~ .....~ .....~ ..... ~ .....~ .....~ .....~ .....~ .....~ .....~ .....~ .....~ .....7::: ·...::::: ... :::: ....:::: ..... :::: .....:::: ..... :::: .....:::: .....:::: ..... :::: .....:::: .....:::: .....:::: .....:::: .....:::: .....:::: ...:::: .....:::: .....:::: .. ...:::: .....:::: .....:::: .....:::: .....:::: .....~ .....~ .....~ .·.. :::: ..... :::: .. ---~~-------;;;

~ ~-~~~r~~~~-~-~~~~~-~-~-~.: :~ 1. ~

~===~····=·· ··~· ·= · ·=-· ·=· · = · · ·= · · ·=· · · :::::;:::::;:::::;:::::;~:::::;

Figure 4.7 TEA Simulation Waveform- Output after 32 rounds of Decryption

In this way, the functionality of the algorithm is corroborated using a hardware description language and verified using Active HDL.

4.6 Integrating Hardware Encryption and Software Decryption Modules

As mentioned earlier, there are many ways to implement the decryption module one of which is hardware. This is the first step to verify the functionality of encryption block. The second method can be a software approach. In order to emulate an RFID system consisting of a reader and a tag, where a tag would typically encrypt a certain value and the reader would decrypt it after receiving it over a wireless interface, the encryption block is implemented in hardware while decryption is performed in software. Since HDL code for hardware must be tested, the evaluation tool is migrated to Altera Quartus from Active HDL and a C application is developed in Altera Nios II IDE.

In order to facilitate the interaction between these two modules, the System-on-aProgrammable-Chip (SoPC) Builder is used to generate the system. The system consists of a 32-bit RISC Nios II processor, JTAG DART for downloading the program to SoPC,

31

and inputs for the system. On chip memory (RAM) is also included (~46 KB) to store the results of encryption and decryption. The clock frequency is 50 MHz for the NIOS II CPU system. A snapshot of the system is shown in Figure 4.8. Once the system is generated successfully, the HDL code for the designed system is compiled (encryption logic for TEA). Before analysis and synthesis of the system, appropriate pin assignments are made for system clock, reset, etc. The top-level module in the system integrates the interaction between the 'nios_system' (nios_system.vhd) generated from SoPC and the encryption logic (rfid_tea.vhd). It ensures that data is properly passed from the 'rfid_tea' module to the 'nios_system' CPU module in the system. After completing the analysis and synthesis process, a configuration bit stream is loaded on the FPGA via JTAG. At this stage the SoPC system is configured ready and the Nios II software can be programmed as an application. The software code accepts an input as the encrypted output from the 'rfid_tea' module which is written to a memory location for the NIOS II software module. Afterward, the decrypted output is printed to the screen to be displayed. The output illustrates that both the encryption and decryption algorithm work synchronously and successfully interact with each other, thereby emulating the interaction of a reader in software and a tag in hardware.

juse

Come ... Module Name

Description
t · . t

Clock

Base

End

IRQ

r nstru<mon_master
data_master
jtag_debug~module

Avalon Memory Mapped fi.\18ster
Avalon Memory Mapped Master Avalon Memory Mapped SfBve
JTAGUART Avalon Memory Mapped Slave

elk

m
elk elk elk
i?..f

..........

IRQ 0

IP.Q 31~
OxOOODOfff

El jtag_uart

'--7

avalonjtag_slave

OxOOOOIOOO Ox00000007

El decJYPt:Jnput1 ~ s1 El decryptjnput2
~
s1

.PIO (Pa(Bifell/0)

~

Avalqn MemoryMappe~ ~fil)re
PIO (ParaHeii!O) Avalon Memory Mapped Slave
On-Chip Memqry (RAM or ROM)

0' 0.00000010 OxOIJOOOOH
£

Ox00001020 Ox0000002f Ox00011'000 Ox0001b7ff

l'-J

I ---~

El

o:~hip_mem

Avalon MemoryM2Jpped $1aye

elk

d"

Figure 4.8 System generated by SoPC Builder

32

ClkReset

1
1

:1.--------Tag___,
Hardware

I

I~
Reset :
Reader

Decrypted output (Plain text)

L...--------,>
Plain te..~t

>
v

Software
(nios~system)

"

(did_tea)

encrypte4_MS:)

...____ _ _ ____. encrypted_LSB

Figure 4.9 TEA- Top-Level Module Design

4. 7 Variable Rounds of Tiny Encryption Algorithm

It is contented by the authors of TEA that one of its advantages is the fact that the
algorithm can be modified to provide more security by increasing the number of rounds [27]. To test this, after implementing TEA for 32 rounds, the number of rounds was modified to a random value of 50. However, the value of delta in decryption must be changed in accordance to the change in the number of rounds. So if the number of rounds are 50, the value of delta in decryption (inv _sum) must be (50 x 9E3779B9) or OxE6D5C622. The HDL code is modified to perform this 32-bit n1ultiplication between delta and the newly established number of rounds. This is shown in the timing diagram shown in Figure 4.1 0, where Y_out is the new value of delta to be used in decryption. This operation takes about 32 clock cycles to be completed. The following waveform shows that the encryption process works for 50 rounds. The encrypted value is Ox4B85548CB6A69547 as shown in Figure 4.11.

D-

elk

·iii·· ~· · ~·~·~·~················· ·· ····r4·F-·;··8· 8 ·c o·c·a·.·:·.··l····-r· · ···· ······· ····················· ··········· ······················· · ····· ···· · ················· ·· ············· ···· · ······· ········ ······· ·······························································
······ ·· ·· · ···· ················· · ·········· ··· · ·:-·· ·························· · ······ ··;·· · · ··~············ · ··· ··· ··············· ············· ······································ ······· · · ·························· ······· ·············· ·· ····· ··· ···· ······ · ················· ·· ······ · · ·· ····· ·· ····

l1

.

~~~~~~~=f~~~-~-;-~-;-=-=-=-=-=-=-=-=-~-=-~-=-=-=-~-=-~-=-~-=-~-=-=-=-=-=-=-=-=-~-~-~-~-~-;-~-=-~-;
Figure 4.10 Waveform- New Delta Value Calculation for Decryption

ttl ··· max_ rounds !50

! ;50

33

Name

f± l

At

sum
!0

±l liT counter
(fl
M

counter1

ftl liT rounds

:,

!0

l±l liT tempZ IB M tempZ1 ............................... rB At tempY

!8&6.69547 !8&6.69547 i 8B554BCO !025C26A4 ......... _ _i 91786F43

l± l liT tempY1
IB M lshiftedz

rB AT rshiftedz . ...............: 4C1 E189D

i± l liT lshifted_y
±I JU rshifted_y
ifl liT L

.......................................
· CF36.1 36.3 00000000

! 40EEF378

:oooooooo
L4885548C
!8&6.69547

J.J -<> encr_ypt_outputM .. i 4885548C :+J-<> encr_ypt_outputLS .. i 8&6.69547

Figure 4.11 Waveform- Output of Encryption after 50 rounds

Decryption results in the original input are shown in the following waveform of Figure 4.12
l:~l- ~-~U..rl1 ....
1

d:l nr counter
nr counter1
10

[±]

:.±1 n:r rounds :.±1 n:r tempZ
f.±l n:r tempZ1

!50 ...i.~BCDEFO l 044D5E6F

....................................·

'+ Jnr tempY
i±J M tempY1
±l nor
1

!01234567 !01234567
C){FF9EB303 l(FFF7S7S3 )(noA4AF3 l(3FA1C243 J;:oscc35D3

l~1- ~_r_S.~if_t~9.Z. ................ :.~~2C4E6
!F3C627FB

lshift~-~.Z. ............................:.~.~~-~-~.?~..............
..............

LJ~:5~~~~~~:?.~:~::::::::::::*~:~~:~~:~~~·: :·: :.:· · ::::*~~:~~~~:~~:. :· .: : · :*-~:~~:~~~:~~::·:::::···.:::*~-~~-~~:~~~--· : : ·: · ·::*~~-~~-~~Es
~A84B97B
J;:c9A1E38B J;:AE8242EB ){1DE53ASB l(s92B7FEB ){F3CS27FB

*~9A_c_E_o1_23_ _ __

l+l nr lshiftedy

.i~l- ~ rs~if_t~~.Y
:.±J ML :.±J MR

i

!B3BFE348 !F58F826D

0..~~~~~~~::: : :·: : .: : .:.:.: . . ~.:=~==~-~- · :. :::·:::*~:?.~~:~~:~~:::::::::::::*~~:~~:~:~~:~:·. : : .:::~:~.~~-~~.C:~. . . . . .:.~~~:?.~~.:.=~. . . : .:.::*~~:~~-~~:~~ ..Q~~-~~-~~-~~. . . . . .. . 0.~~~~.:.~~~. . . . . . 0.:.~:.:.~~.:~. . . . ...x~~-~~-~~-~~ x~~-~~-~~.:~ ~~-~~.~.:.~~-~

. .. . . .

. : · · · · · · · . .... . . . . . ... . . . . . . . .

~-----

!89A8CDEF
······························································
[±] -o

!+l -il encrypl_oulpu ... !01234567

en:r~~~~-~.U..~~~~-~-~..:.:.1.~~-~-~DEF

..........·....· ~ . ====== ....:::: ....:::: ....:::: ....:::: .... :::: .... :::: ....:::: .... :::: ...:::: ....:::: ....:::: ....:::: ....=.======== ....:::: ....:::: ....:::" ....:::: ....:::: .... :::: ....:::: ....====""~'====fL--

Figure 4.12 Waveform- Output of Decryption after 50 rounds Thus it is corroborated that TEA can be modified for a variable number of rounds and it is successfully implemented and illustrated through waveforms.

34

Chapter 5 Improvement in RFID Security

5.1 Introduction Evolution of security is imperative to prevent threats of anti-counterfeiting in several applications such as retail and supply-chain management. To supplement this cause, authentication is necessary in order to distinguish a genuine product from a fake one [30]. The structure employed in TEA has the advantage that encryption and decryption operations are very similar, requiring only a reversal of the key-scheduling. This results in the size of the code or circuitry required to implement such a cipher is nearly halved. It has been widely established that TEA is the fastest and most efficient cryptographic algorithms [5, 8]. Moreover, TEA has security comparable to IDEA and performance comparable to AES in addition to having small code size compared to other algorithms [ 1, 26, 31]. The algorithm can be employed using various authentication procedures like Hash based and Randomized access control. Several measures are adopted to strengthen the RFID system by providing unauthorized readers to access tag information or fake tags to replace authentic tags. The major assumptions in designing an authentication protocol are that the reader has a secure connection (possibly wired) to a back-end database as eavesdropper may only monitor the forward channel (i.e. reader to tag) and a tag is equipped with a ROM to store critical information. The value of key must be kept as secure as possible over a wireless channel. This can be accomplished using hashfunctions (one way hash to verify authenticity of the tag by the reader) and possibly twoway hash functions to authenticate the reader as well. Pseudo random number generation can be used to associate with a certain handshake to associate that the encryption algorithm is modified in a certain way including number of rounds, key size and so on. It is intended to explore different possibilities to establish secure communication between a reader and a tag by exploiting available resources to set up a robust RFID system.

35

As mentioned earlier, the robustness of an authentication protocol is not just based on the encryption algorithm or the procedure of message exchange, but a secure combination of the two. The algorithms discussed so far are all symmetric block encryption algorithms. The Tiny Encryption Algorithm which belongs to this category is chosen for implementation due to its many advantages and lightweight application. On the other hand, there are also stream cipher algorithms where stream ciphers encrypt individual byte or bit of plaintext one by one, using a simple time-dependent encryption transformation (e.g. RC4 [32], A5/1 [33]). Block ciphers simultaneously encrypt groups of characters of a plaintext message using a fixed encryption transformation. Stream ciphers operate faster but can be cracked by cryptanalysis since it provides very low diffusion. A stream cipher algorithm typically performs calculations and produces an output one bit at a time whereas a block encryption algorithm operates on a block of data (64-bit for TEA) by a series of calculations and then generates the final output. It is proposed that a combination of the two techniques could result in merging the advantages of both methods of encryption. There have been very few attempts in this area [21], however, the following proposed methods are attempted to be customized with respect to TEA and derive motivation from this approach. The following sections present a proposal of potentially safer mechanisms adapted to TEA.

5.2 Variable Key Scheme (Modified TEA) The many possible attacks to an RFID system have been considered and presented. This proposition utilizes TEA to provide security against a few attacks. The XOR is already proved as an excellent function to encrypt values with minimal computations. The protocol is illustrated below in Figure 5.1. Certain assumptions are made for the system, as stated below · The connection between the reader and the database is secure. The tag and the reader communicate over the vulnerable wireless medium.
· It is assumed that the tag is equipped to perform encryption/decryption using TEA

and the XOR operation.

36

r
PID
· ;>'

Database

Reader

T(PID ror)
Tag

T(PID ro

rttM7_k}~

.

... ,.

Figure 5.1 Proposed Authentication Scheme for Variable Keys

·

ID refers to the unique ID assigned to each tag which may be part of the product code. This value remains fixed and is stored in the back-end database (for each tag) for verification and also in the ROM of the tag. PID (pseudo-ID) is an identifier assigned to the tag that is variable and changes with every protocol run. The value of PID can be such that it embeds the value of ID in it to be extracted by the reader.

· ·

The tag also has a re-writable memory to store value of updated keys. The number of rounds of TEA is fixed in this scheme. T() stands for 32-round encryption performed using TEA.

·

The reader is also equipped to perform 32 round encryption and decryption.

The protocol operates as following: i) Initially, the reader generates a random number rand sends it to the tag. The tag encrypts this value as T(PID@ r) and sends it to reader. ii) Decryption is performed by the reader, and PID is obtained by {(PID@ r)
EB

r} = PID.

The database checks the PID value and if it finds a match, the tag is authenticated. iii) The DB is capable of randomly generating the new key value. One way of doing so is performing hash function to generate a new_key. Where new_key= h(PID updated in its records. iv) The reader encrypts (using the old key) the PID, XORs it with the new key and sends it to the tag.
EB

old key) or can be defined as any other value which is

37

v) The tag receives this and performs decryption to get PID by XORing with the new key. Now, {(PID
ED

new_key)

EB

PID} = new_key and this value is stored as the updated

key value by the tag.

In this way, the reader authenticates the tag. Any query or transaction that follows after this session will be encrypted by this new key value and subsequent transactions will use key values updated in their previous sessions. The values of old and new keys can be saved in the tag and the memory until synchronization is completed. This can be ensured by keeping a flag (sync) on either side that indicates completion of the session. Old keys can be discarded after synchronization is successful.

Since the value of key is updated in every session, the response from the tag is different in every session. Even if an eavesdropper taps into the tag's response, it cannot relay the same response to the reader in the next session. In this way, this scheme provides security against replay attack. Moreover, decrypting the tag's response without the key value is difficult. Presence of a flag maintains synchronization between the entities of the system there by preventing Denial of Service attack. Other attacks like jamming attack and location tracking are also counteracted as a result of this design. Since the value of PID changes in every session, the ID value is hidden making the protocol more secure. Most applications prefer the use of one-way hash functions due to their low computational complexity. Common examples are MD5 [34] and SHA-1 [35] that are similar to block encryption algorithms and make use of S and P boxes. However, the use of TEA in this scenario aims to find a compromise between cost and security.

5.3 Variable Rounds Scheme (Modified TEA) The variable key technique assumes fixed number of rounds in an encryption cycle and variable keys. In another scheme we have investigated to keep the value of key fixed and vary the number of rounds (nr) in each session. The protocol assumptions are the same as in the previous method with the following exceptions: · The tag has a pseudo-random number generator (PRNG).

38

·

TrO is an r round encryption/decryption TEA algorithm where r is a random
number The protocol is illustrated in Figure 5.2.

PID
Database

PID,nr

Reader

T(PID)
Tag
T(PID re nr)

Figure 5.2 Proposed Authentication Scheme for Variable Rounds

The protocol operates as following: i) Initially the Reader generates a Query message for the tag. ii) The tag responds with T(PJD) that is an encrypted using 32 rounds (i.e. a default value for the first protocol run) and a fixed symmetric key known to the tag and the reader. iii) The reader decrypts this value to get the PID and sends it to the database (DB). If the DB finds a match, the tag is considered valid and it forwards the PID and nr to the reader. iv) The reader encrypts PID using T = (PJD
$

nr).
$

v) The tag decrypts the received value to get ID value for number of rounds from {(PJD
$

nr. It uses XOR to retrieve the new PID} = nr.

nr)

(f)

This value is stored in the tag's memory. The subsequent session will be performed by

TrO as opposed to the original TO.

This method also uses sync to provide synchronization between the tag, reader and the database in subsequent sessions. Use of sync flag provides resistance against jamming attack - where frequency is blocked by the attacker; in this case the flag will indicate the loss of synchronization and restore old value of keys until a new session is initiated. Replay attack is also counteracted since the number of rounds is variable in each transaction and thus the information leaked from a tag's response cannot be traced since it is different in each session; this avoids Location tracking. It is also secure from eavesdropping since any information received from the tag or reader cannot be easily cracked and requires sophisticated methods of cryptanalysis. The only disadvantage in this approach is that the tag must be equipped with a PRNG that increases the cost of

39

complexity at the tag level; however, changing the number of rounds is far less tedious than changing the value of 128-bit key in every cycle. Therefore both methods have their own trade-offs but attempt to provide high security. The two protocols are implemented using the hardware/software approach similar to TEA's implementation (section 4.6) using NIOS II IDE and VHDL (i.e. tag in hardware and reader using software). The following figure shows the setup of testing the functionality of the system.

Host Computer ~

JTAG
FPGA

(NIOS lliDE)

(VHDL)

Figure 5.3 General Setup for Hardware/Software Implementation of Variable Key and Variable Rounds approaches

5.4 HDL Implementation of Variable Key Scheme
The scheme described in section 5.2 is implemented using VHD L to simulate the interaction between the reader and a tag using the variable keys protocol for authentication. Two separate components are designed i.e. Reader and Tag and encapsulated by a top-level block diagram as shown in Figure 5.4. There are some signals that form the interface between the two modules, which are used to emulate the behaviour of the system in an RF environment. The top-level design instantiates these components and facilitates the behaviour of the entire system with internal signals and feedback. Simulation waveforms illustrate the functionality of the system in addition to the timing behaviour. Two assumptions are made in the design of the system. First, due to the complexity of the system, a random number generator is not used. Random number generators can be implemented as a look-up table in HDL, but for purposes of simulation and testing, a random number is chosen and applied to the system (e.g. the case where a random number is to be generated by tag and the case where a new key is to be computed by the reader as a random number). The new key generated by the reader can be implemented using many widely used techniques such as a hash function, complex

40

random number generating scheme, by using XOR functions or a combination of them depending on the level of security desired.
Rese t - + - - - - - - - - - - - - - - - ,

Clock

Reader

Reset
Ck>ck

1----..._l-+--~
t-----"--~

Reset
Clock

Tag

Rrmdom Nrunber
Lutpnt ·· trvi;)e

t========~"-~ v
1-------~ VA'":::=======!

Random Nu.tnh<"r
Enahlt~
tag_encrypt_outp1fu \1SB_Y tag_encrypt_outputLSB_Z

")

S

,

final_deayptY final_decryptZ

encrypt_outputMSB_Y
encrypt_outputLSB_Z

V
A 'I

New Key Value

Reader Encrypt OutputY

~======~r..~ v Reader Enc.f)'Pt Output Y

Reader:: Encrypt Output Z t========~v~ Reader Encrypt Output Z Reader ·Output Ready t-----~ Readet Output Ready Feedbaclc
M atch ·Fmmd Next Key (send_next_ke;;)
1-E'-------l

"

~------i

OUtput Ready

Next key (send_ne:xt_key)

Figure 5.4 Components and their Interface for Variable Keys Authentication

Since this is ultimately implemented in software on a real RFID system, it can be designed to handle much more computational complexity than the tag and is easier to implement using software. A separate technique to employ this in hardware is not developed here; rather a number is chosen at random to simulate a new key generated from a reader or back-end database. Secondly, for simplicity, it is also assumed that the reader performs functions of the back-end database (such as ID verification and random number generation). To test and verify functionality of the system, it is designed with the following parameters: · · The PID of the tag is defined as a 64-bit value of0x123456789abcdef. The key used for the initial (first) session of the protocol is a 128-bit value defined as Ox00112233445566778899aabbccddeeff. · · The random number used by the reader is a 64-bit value of Ox00000028 or 40. The number of rounds used for all encryption and decryption procedures at the reader and the tag are fixed to Ox00000032 or 50 rounds.

41

·

The new key generated is a value of0x34676398ad9c23ef814574346613712b which is a random number.

The Reader initiates communication with the tag by sending a random number through its output port. It generates a strobe signal as an output along with the random number. Receipt of this becomes known to the tag by the output strobe signal, which serves as an enable input signal to the tag. Once the enable signal goes high, it starts computing the value of T(P ID
63

r) where TO refers to encryption using the TEA algorithm (data 1 in

Figure 5.5). Once this is computed, the tag asserts the Output Ready signal which serves as a feedback signal to the Reader block (see sync signal of Figure 5.5). The reader accepts the encrypted values ('encrypt_ output_MSBY' and ' encrypt_output_MSBZ' in Figure 5.5). The reader performs decryption to retrieve the PID value from {(PJD
63

r)

EE>

r} (data 2 of Figure 5.5). Its validity is verified from the reader (i.e. either corresponding stored PID in the reader or valid ID extracted from the PID). If it is valid, the
'match Jound' signal goes high, and the reader proceeds to random number generation. A

new key is chosen (a 128-bit random value of0x34676398ad9c23ef814574346613712b is chosen for simulation). This new key is encrypted with the PID as T(PID
EE>

new key)

(data 3 of Figure 5.5). This appears at the ' reader_encrypt_outputMSB_Y' and
'reader_encrypt_outputLSBZ' ports of the reader. Another intermediate signal for

synchronization is 'reader_ output_ready' which indicates the completion of this calculation. Once it goes high, the tag receives the newly encrypted information and begins decryption to retrieve the new key value (data 4 of Figure 5.5). In this way, at the tag side a new key, ((PID
EE>

new key)

EE>

PID) is acquired and updated in its internal

memory (data 5 of Figure 5.5). Now for the next transaction the tag will respond with the encrypted tag PID using this new key. The third session will repeat the same procedure with the new key and so on. Thus eavesdropping of any information will not cause any problems in a real RFID environment since the value of number of rounds, key and PID are hidden. Moreover, the tag's response changes in every session making it immune to location tracking.

42

Name
1>1>-

I

·

590 ·

I

·

1090 ·

I

·

1590 ·

I

·

20,00 ·

I

·

2590 ·

I

·

3~0

·

I

·

35.00 ·

I

·

40.00 ·

I

·

45.00 ·

I

·

50.00 ·

I

C lk Reset

. ...... .).~ . . ............................ ~~.O..r_~~,!:::: . . .= .. = ...= . . . .= . . .= ...= . . . .= . . .= . . .= . . .= ...= . . . .= . . .= . . .= . ..= . .= . . .= . . . .= . . .= . ..= . . . .= ...= . . . .= . . .= . . .= ....= . . .= ...= . . . .= . .-= . . . .=---= . . .= . . .. = .= . . . .= . . .= . . .= .... = . . .= ...= . . . .= . . .= . . .= . . .= ...= .. = = = = = = = =

. . . . . ..!.~... . . . . . . . . ... . . . ..!.~~r~l~,................................................................................................................................................................................................................................................................................................................................................................

.............................
1rt

1rt

match_found
~

...................................................

. . ... ................................................................................................ ............... . . . ................................................................................................... . . . 3 .......
; 00000000

tag_response

!o

.......................................

l~!.~r.~~.~~.r~:~r~pt=·~:~tLSB:-~.... J~.~~~~~!............ . . . . . . . : .~.~~~~. . . . ... . . . . . . . . . . ... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ~~' re~·~·e·r:-:~~~.~~~.~.~.~~...................... .).~....................................;...................~...................................................................................................................................................................................
ltJ M final_ decryptY
...................................... .....................................
I±! ~~' ~~'

I± 1r fnal_decryptZ

. . . . . . . .!.EFB8BCC4 . . . . . . . . . . . . . . . . . . . . . . . . . ....'.;::= .oooooooo . . . .:::;;:: . --..====::::.::::::::===="""""=---"= """"'= """""= "· ::::.::::::::======~~·~$==::::.::::::::======:::{·);::::::=:
............
............................................
................................. ..

!80663153

. 00000000

new_key_vakJe send_next_key

· 0000000000000000 !81457 434661 ................................... .................................... ................................................................................................................................................. .. -··-··-····-······
"

34676398AD9C23EF

. . . . . !.1...................................l..................;.............................................. ..................................................................................................................................................................................................................................... . .............................................................................................................

Figure 5.5 Simulation of the Variable Key Authentication protocol

5.5 HDL Implementation of Variable Round Scheme Similarly, methodology described in section 5.3 for the variable round scheme is implemented. This approach will also be compared to the variable keys scheme described of section 5.2. The block diagram for the top level module is illustrated in Figure 5.6. There are some changes in the two protocols which are reflected here. In the variable round scheme case, the reader doesn't have Random number and Output strobe output ports and the send next key input port. However, there is a 'Query' output signal that drives the input of the tag ('Enable' input port). The two assumptions for the design of the system are the same as of variable key scheme. To test and verify the functionality of the system, it is designed with the following parameters: · · Tag PID is defined as a 64-bit value of Ox123456789abcdef. The key used for all the sessions of the protocol is a 128-bit value defined as Ox00112233445566778899aabbccddeeff. · The number of rounds used for the initial session for encryption and decryption procedures at the reader and the tag are Ox00000032 i.e. 50 rounds.

43

·

The new key number of rounds "generated" from the reader is a value of Ox00000045 or 69 rounds which is a randomly chosen number.
Reset-1-----------------,

c~+-------------.j
Reader

Res¢t
Clock
Qu-ery

1--.....___t--~

Reset

Tag

I---.____~
1----~ -

ClOCk
Enable
finat:decryptY

-~
· 1--.,

l-..

encrypt_outputMSB_Y rl'~~=:=:=:~ tag_encrypt_output.\1SB_Y encrypt_outputLSB_Z ~ -'9~======:::j tag_encrypt_outputLSB _Z Reader Encrypt Output y ReaOO- Encrypt Output Z
~====~v~ Reader EriCl)'Pf Output·Y
1-1\

lA

6nal_decryptZ

v
}-,

'A

New Rm.mds V.alue '-- ----t/

v f-::=====~"~-

Reader En.Cl)'Pt Output Z

.

Reader Output ~Ready 1----~ Reader 0utpm: Ready

Feedback
Match Found

f;E-,--------.1 Output Ready

Figure 5.6 Components and their Interface for Variable Round Authentication

The reader generates a 'Query' to initiate communication with the tag. This enables the tag to begin encryption of the PID as T(PID) (data 1 of Figure 5.7). The reader receives a feedback signal from the tag indicating it to start the verification process. Once it decrypts the PID and certifies it as valid (data 2 of Figure 5. 7), the 'match Jound' signal is asserted and the random value for number of rounds is generated. This new value is now embedded in the reader's next response as T (P ID EB nr) and sent to the tag at its 'reader_encrypt_outputMSBY' and 'reader_encrypt_outputLSBZ' ports as shown in the waveform (data 3 of Figure 5.7). The tag decrypts this value (data 4 of Figure 5.7) to decipher the hidden rounds value by XORing the resultant decrypted value as {(P ID <11 nr)
EB

PID} = nr (data 5 of Figure 5.7). The new rounds value is now updated in the tag's

memory and can be used for the subsequent session. The value for new rounds is Ox00000045 or 69 rounds as shown in Figure 5.7.

44

The waveform of Figure 5. 7 for various signals clearly illustrates the message exchange from one entity to the next (to/from the tag and reader) including feedback signals over a time scale. The total time for execution for one session from query to deciphering the new rounds value in this protocol is 3.426 ms i.e . .....,6853 clock cycles for a 2 MHz clock.

Name

Ivalue
!0 l 4B85548C

IStirn~ .. I
! For mula l l

1

0,5

1 ·

)

·

1

1..5

1 ·

?.

1

2,5

1 ·

~

·

1

3,5

1 · '

·

1

4 ,5
I

~> Clk
r±l nr encrypt_outputMSB_Y

······ · ·~ ·· R· ~~·~~ · · ·· · ···· · · · ··············· · ···················· · ········· · ··Ta···················· ·· ················· ················TF·~·;~~i~r ·· ··· · ·· · ···· · ·········· ·· ···· ·····=······ · ··· ··· ·I· ···· ·· · ··· · ···· ·

..····················································································· ....

··· · ···· · ··· · ················ · · · ··· ·· · · ·· ············ · ·· ··· · ···· ·· · · ······ · ············ · ···~·· ············· ·· ········· · · · ···· · ············ ······ ··· ·····~· · ······· · ········· ~ · · ······ · ··· · ··· · · ···· ···· ··· ···.:.o"'········ ··· · ·· ·~

......,................................................................................................................

······ ··········································································· ···· ······~·················································· ········ ··~···················~················· ··········t·· ·····...... ····· ··············__; ····t ..... ··············-··················· -··············-·············· ·····-···················-····· -···················-...... -+-.
························ ················ ······ ·············································?········· · ······································· · ········ ·+···· ···· ····· ·····~ . .... . . .....................~ .....'~ ..~ ~ ................ 7' . ..-........................-.....-.....-........................-.....-..... -............................................+.....

koooooooo J4B85548C

X

:±l nr encrypt_outputLSB_Z
nr query

!86.6.69547

(oooooooo ')(BSAS9547 j

!O l 01234567

l : l l

J
: 00000000

'================"'""
/X01234567 \
~89ABCDEF/

··············· ····················································· ············ ·········· ·~········· ·········· ··································· ····· ·~····· ········· ···· ·~ ······················· ························· ··········1·· · ····· ......-···· ·-·········-· ····-· ···· + .........-.....-..............-.....-..............-.....-.....-..............-.....-....+....

r±l M verified_outputY

i±J nr verified_outputZ
nr match_found
M

ls9.6.BCDEF

koooooooo

·· ··· · ··· ·················· ···· ···· ············· · · ···· ········ · ··· ····· ····· ··············+·· ····· ··························· · ········· ··············+·················+· ···· ················ ···· ··· ·· ····· ···· ········· ···············~··· ···:.:.;.lll'"'· ···· ····· ···· ········ ········· ····· ············· · ··· ····· ········ ········· ·· ·· · ··· ···· ·

· ···································· ······················································~···························· ································~····· ········· ·····~·························································· ····················· ·······································

1 1
l0

tag_ response

l

····· · ······ ·· ····· ···· ·························· ····· ········· ··· ··········· ······· ··· ····~· ··· · ·········· ······ ············· ················ ···· ··· ···~····· ··········· ·· ·~ ·············· · ·· ········ ······ ················ ······· ······ ··· ··· · ········· ············ ···· ,.·························"' ··· ·· ················ ········ ·· ······· ········ ·

! !

I

I

3 . ............................................. .. .,---...L.... ....

i±J nr reader_encrypt_outputMSB_Y l6366EAA3
[±]
M
M

······· · ·········· · ····· · ·········· ······ ··· ··· · ······························· · ···········~ · ······ · ·· ·· ··· · ·· ····· · ·· · · · · · ·· · ··························~················ · ··~····· ···· ··· · · · ··· ··· · · · ···· · ···· · ··· · ···· · ····· · ·· · ··· · ························· · ····· ··}· · · ····················· ·· ·. ·······1············································

!
!

koooooooo

fXS3SSEAA3 '
~04997EC4 /

reader_encrypt_outputLSB_Z reader_output_ready

!04997EC4

·· · ··········· · · · ······ ·· · ···· · ·· · ···· ·· · · ······· ···· · ·· ··· · ··· · ········· · ···· ·········· ···~· · · · · · · ··· ·· ···· · · ········ ·· ·· ···· · ··· · ·· ····· ····· · ···· · ·· · ~····· ·· · ······· ···· ~ ·· ···· · ·· ···· ···· · ··· · ·· · ···· · ····· · ····· ··········· ·············· ······ · ·· · ··· · ···· ·· ···· · · · ··~········· · ·· · ··· ···

: oooooooo

·· · · ·· · ·· ···· · ·· · ····················· ·· ······· ····· ···· ············ ····· ·· ··· · ······ ··· ···~··· · ········· · ·· · ·· ······ ···· · · ···· ······ ·· ··· · ······ ·······~·· ··· · · ·· ······ · · ··~· ··· ····· · · ········· · · · · ·· · · ···· · ·· ··· ·· ·· ·· ··· ····· ··· · ·· ·· · · ·········· ·· ··· · ············· · ············ · ······ ···· ··· · · ·· · ·"""""'' ·· · · · · · · ·· ··· ···"""""'· ····· · ·· · · · ··

!0

!

!

I

4 ························· ····

1

:±1 nr final_decryptY
r±.l nr final_decryptZ

·· · ········ · ······· · · ···· · ···· · ······· · ····· · ···· · ··· · ·· · ········· · ··· · ······ · ··· · ··· · · · · · +······· · ··· · ·· · ···· · ························ · ···· · · · ·· · ····~· · ···· · ············~··· · ··· · ·· · · · ····· ·· ············· · ···· · ··· · ·· · ····· · ············ · ······· ·· ···· ····· · · · · ···· · · · ··· · · · ···· · ·· · ·· · ····· · ········· · ·········· · · ·· · · ··· ·· ······················

!01234567

!

koooooooo Koooooooo Koooooooooooooooo

/ X01234567
~89ABCDAA /

"\

.... ....

! 89.6.8CDAA
10000000000000045

!
1

···· · ·· · ···· ·· · · ·· · ·· ·· ······ · ·· · ········· · ····· · ··· · ·· · ··· · ·· · ······ · ···· · ··· · ··· · · ··· ·· ·· ~· ·· ·· · · · · · ·· · · · ·· ··· · ·· ·· · ·· ·· · · · ·· · · ····· · ··· · ···· · ·· · ·· · · · ~··· · · · · · · · · · ·· · · · ·· ~ ·· · · ·· · ··· · ·· ······· · ·· ·· ··· ·· ·· · ········· · · ········ · ·· · · ··· ············ · ···· · · · ···· ·· · · ·· · ······· · ···: :.::.:.:.::.:.:

ctJ M new_rounds

5 --fXoooooooooooooo45

1

··· ·· · ·· ······ · ·· ········· · ·· ·· · ·· · ···· · ··········· ·· ············· · ·· ·· ··· ·· ···············~ ·· · ···· · ··· ····· · · · · ··· ·· ··· · · ····· ················· ·· ·· · · · ·~ ···· ··· · ····· ··· ·· · ~ · ·· ········ ······ ··· ··········· · ···· ·· · · ··· · · ·· · · ····· · ···· · ··· ···· · ·· ·· ·· ···· ············ ·· ·· · ········ · ····· · ········· ···

Figure 5. 7 Simulation of the Variable Round Authentication protocol

5.6 Comparison of Variable Key and Variable Round Authentication Techniques
Both variable key and round techniques are successfully simulated using the same
I

environment and the same assumptions. Implementation of these protocols is accomplished using a finite state machine approach to ensure that all internal signals are updated synchronously. One of the most crucial differences in the implementation of these protocols is their timing analysis. The variable round scheme clearly takes a shorter time to execute since the new value of the number of rounds is updated in one transaction. It is due to the number of rounds is a 64-bit value that is easily encrypted by TEA. Both systems are simulated with the same 2 MHz clock frequency. The variable round technique consumes about .....,6853 clock cycles or 3.426 ms. On the other hand, the variable key scheme consumes many more clock cycles for execution. This is due to the 45

fact that the key value is 128-bits which cannot be encrypted in one transaction. It takes about 5.145 ms for execution which is about 10,290 clock cycles. This method takes longer to execute since updating the key is more time-consuming; the key is larger than the number of rounds i.e. a 128-bit value and it cannot be updated in one transaction. This is because the TEA algorithm can encrypt only 64-bit values at a time and hence the algorithm has to be used twice in order to encrypt 128 bits. In this way, updating the new key value requires two message exchanges as opposed to one in the variable rounds method.

Parameters

Variable Key Approach

Variable Round Approach
~3.426

Standard Approach
~1.720

Execution Time (for one session of the protocol) Number of Clock Cycles Number of Reader Transmissions for Key/Round Update

5.145 ms

ms

ms

10290

~6853

3440

2

1

No Update

Table 5.1 Comparison of Variable Key and Variable Round Authentication

Moreover, varying the number of rounds will increase or decrease the time of encryption and decryption. For example, if the random number generates 400 as the new number of rounds, then this could drastically affect the performance of the system causing considerable amount of delay. A large delay may be unacceptable due to the tag's computational capabilities. This issue can be overcome by optimal design of the random number generator -the output of this module can be limited to the maximum delay tolerated by the system in encryption and decryption and the tag's storage and computational capabilities. The variable key scheme however uses fixed rounds and therefore, no matter what the key value is, the time period for encryption or decryption would be consistent in every session. It is possible to speed up the execution in either

46

case by using higher clock frequency for the system (i.e. using a high speed CPU). The standard approach entails encryption and decryption using TEA without any modifications e.g. the Reader generates a query to the tag, and the tag encrypts the PID value. This is now sent to the reader and it decrypts this using the same key and fixed number of rounds. This session takes ~ 1. 720 ms for execution and the least number of clock cycles. However, it does not provide any level of security since all responses from the tag are same at all times when queried from the reader. Therefore the standard use of TEA is prone to various kinds of attacks.

Cost of the system is affected by the level of computational complexity and memory requirements. Updating a large key value will consume more space in the memory as opposed to the value of number of rounds, thereby affecting the cost of tag. On the other hand, use of a PRNG for the variable rounds technique will add to the cost of the tag. Therefore, there is a trade-off in both schemes. Another possible difference is the level of security offered by both techniques. It seems more secure to update the key value since it is harder to break a 128-bit key value than a 64-bit value for rounds. Detailed cryptanalysis would be needed to measure the exact levels of security offered in these cases. The main advantages of both protocols is the fact that the information is dynamically updated making the overall system more secure.

47

Chapter 6 Conclusions and Future Work

RFID systems are fast emerging and will soon find new applications in our daily life. Most of the applications are well underway; tested for functionality but are undergoing thorough investigation in terms of security, performance and feasibility to be adopted as an industry standard. In order to find use in credit-card transactions and other such highrisk applications it is essential to strengthen security by developing robust techniques in algorithms and authentication procedures in RFID systems. This report presents some of the most widely researched and commercially adopted protocols and algorithms in the industry today. Although each algorithm differs in terms of performance and requirements, a brief comparison is made to choose a 'light-weight' encryption technique by keeping passive tags in focus. Passive tags have the highest potential to become widespread due to their portable nature and low cost compared to active tags. A survey of these light-weight algorithms is presented out of which the Tiny Encryption Algorithm (TEA) is selected as a suitable candidate for satisfactory implementation results. Moreover study of various authentication protocols is performed and judged based on performance metrics like security and privacy. Common attacks in an RFID environment are also explored.

Implementation of TEA is accomplished and described in detail with results and timing waveforms to corroborate functionality and correctness of the implemented algorithms. Moreover, new schemes with some modification to TEA in combination with an authentication protocol are presented. Security and privacy analysis of these new schemes illustrate that they are secure from common attacks like eavesdropping, replay attack, denial of service and location tracking. A comparison is performed with respect to timing and security. Selection of either of these schemes depends on the timing requirements and level of security desired in the RFID system.

48

Future developments with respect to the work presented here would be to use a method to properly encrypt the value of ID in the PID (e.g. using simple mathematical primitives or light-weight algorithms) such that the reader is able to derive the value of ID from the PID with every session of the protocol. Another development would be to separately design and integrate a random number generating module and possible separation of the flow of control and the data information for optimum minimization of hardware resources. Furthermore, modifications or improvements (based on cryptanalysis) to the authentication protocols can be implemented depending on the requirements. Other features such as power estimation can be made to minimize the power consumption at the tag level.

49

ROPERTY OF RYERSON UNIVERSITY LIBRARY

References
[1] T. Eisenbarth, S. Kumar, C. Paar,, "A Survey of Lightweight-Cryptography Implementations", Special Issue on Secure ICs for Secure Embedded Computing, IEEE Design & Test of Computers, vol. 24, no. 6, Nov. 2007, pp. 522-533. [2] F. Mace, F. Standaert, J.J. Quisquater, "FPGA Implementation(s) of a Scalable Encryption Algorithm", IEEE Transactions on Very Large Scale Integration Systems, San Francisco, CA, USA, vol. 16, no. 2, Feb. 2008, pp. 212-216. [3] W.E. Burr, "Selecting the Advanced Encryption Standard", IEEE Security & Privacy, vol. 1, no. 2, Mar-Apr. 2003, pp. 43-52. [4] B. Koskun, N. Memon, "Confusion/Diffusion Capabilities of some Robust Hash Functions" 401h Annual Conference on Information Sciences and Systems, Princeton, NJ, USA, Mar. 2006, pp. 1188-1193. [5] X. Luo, K. Zheng, Y. Pan, Z. Wu, "Encryption Algorithms Comparisons for wireless networked sensors", IEEE International Conference on System, Man and Cybernetics, The Hague, Netherlands, vol.2, Oct. 2004, pp. 1142-1146. [6] P. Israsena, "On XTEA-based Authentication/Encryption Core for Wireless Pervasive Communication", International Symposium on Communications and Information Technologies, Bangkok, Thailand, Sept. 2006, pp. 59-62. [7] P. Kitsos, Y. Zhang, RFID Security- Techniques, Protocols and System-on-chip Design, Springer, 2008, pp.397-400. [8] P. Israsena, "Design and Implementation of Low Power Hardware Encryption for Low Cost Secure RFID using TEA", Pro c. International Conference on Information and Communication Systems, Bangkok, Thailand, Dec. 2005, pp. 1402-1406. [9] S-S. Wang, W-S. Ni, "An Efficient FPGA implementation of Advanced Encryption Standard", IEEE International Symposium on Circuits and Systems, Vancouver, British Columbia, Canada, May 2004, vol. 2, pp. 597-600. [ 10] X. Zhang, K.K Parhi, "Implementation approaches for the Advanced Encryption Standard algorithm" IEEE Circuits and Systems Magazine, 2002, vol. 2, no. 4, pp. 24-46.

50

[11] D. Park, C. Boyd, E. Dawson, "Classification of Authentication Protocols: A Practical Approach", Proceedings of Information Security Workshop, Springer, Jan. 2000, LNCS vo/.1975, pp.194-208. [12] I. Syamsuddin, T. Dillon, E. Chang, S. Han, "A Survey ofRFID Authentication Protocols based on Hash-Chain Method" Third Int. Conf. on Convergence and Hybrid Information Technology, Busan, South Korea, Nov. 2008, vol. 2, pp. 599-564. [13] H. Kim, S. Lim and H. Lee, "Symmetric Encryption in RFID Authentication Protocol for Strong Location Privacy and Forward-Security", International Conference on Hybrid Information Technology, Cheju Island, Korea, Nov. 2006, vol. 2, pp. 718-723. [14] L. Xuefeng, B. B. Enjian and X. Yinghua, "A Novel Authentication Protocol with Soundness and High Efficiency for Security Problems",

lh Int. Conf on Wireless

Communications, Networking and Mobile Computing, Dalian, China, Oct. 2008, pp. 1-3. [15] S. Weis, S. Sarma, R. Rivest and D. Engels, "Security and Privacy Aspects of LowCost Radio Frequency Identification Systems", ls1 International Conference on Security in Pervasive Computing, Springer, Berlin, Germany, Mar. 2003, LNCS vol. 2802, pp. 201- 212. [16] A. Juels, "RFID Security and Privacy: A Research Survey", IEEE Journal on Selected Areas in Communications, Feb. 2006, vol.24, no.2, pp. 381-394. [17] T. Li, "Employing Lightweight Primitives on Low-Cost RFID Tags for Authentication", IEEE 681h Vehicular Technology Conference, Calgary, Canada, Sept. 2008, pp. 1-5. [18] H. Li, F. Yu, Y. Hu, "A Solution to Privacy Issues in RFID Item-Level Applications", Proceedings IEEE International Conference on Integration Technology, Shenzhen, China, Mar. 2007, pp. 459-464. [19] Y. Liu, "An Efficient RFID Authentication Protocol for Low-Cost Tags", IEEE International Conference on Embedded and Ubiquitous Computing, Shanghai, China, Dec. 2008, vol.2, pp. 180-185. [20] Y.C Lee, Y.C Hsieh, P.S You, T.C Chen, "An Improvement on RFID Authentication Protocol with Privacy Protection", Third Int. Conf on Convergence and Hybrid Information Technology, Busan, South Korea, Nov. 2008, vol. 2, pp. 569-573.

51

[21] L. Luo, Z. Qin, S. Zhou, S. Jiang, J. Wang, "A Middleware Design for Block Cipher Seamless connected into Stream Cipher Mode" International Conference on Intelligent

Information Hiding and Multimedia Signal Processing, Harbin, China, Aug. 2008, pp.
64-67. [22] G. Yong, H. Lie, X. Kun, L. Shu-ru, Q. De-pei, "An Improved Authentication Protocol with Dynamic Update in RFID System",

lh International Conference on

Wireless Communications, Networking and Mobile Computing, Dalian, China, Oct. 2008,
pp. 1-4. [23] Z. Zhang, S. Zhou, Z. Luo, "Design and Analysis for RFID Authentication Protocol", IEEE International Conference one-Business Engineering, Xi'an, China, Oct. 2008, pp. 574-577. [24] G. Godor, M. Antal, S. Imre, "Mutual Authentication Protocol for Low Computational Capacity RFID Systems", IEEE Global Telecommunications Conference, New Orleans, Louisiana, USA, Dec. 2008, pp. 1-5. [25] Xiang Zhang; Baciu, G, "Low Cost Minimal Mutual Authentication Protocol for RFID", IEEE International Conference on Networking, Sensing and Control, Sanya, China, Apr. 2008, pp. 620-624. [26] X. Lai, J. Massey, "A Proposal for a New Block Encryption Standard", Advances in

Cryptology, LNCS, vo/.473, Jan. 1995, pp.389-404.
[27] D.J. Wheeler, R. M. Needham, "TEA, a tiny encryption algorithm", in the Proc.

Fast Software Encryption: Second International Workshop, Lecture Notes in Computer
Science, vol. 1008, Leuven, Belgium, Dec. 1994, pp. 363-366. [28] Y. Choi, S. Han, S. Shin, "A design of e-ID authentication protocol in Gen2 environment" 101h International Conference on Advanced Communication Technology, Phoenix Park, Korea, Feb. 2008, vol. 1, pp. 246- 251. [29] E. Suwartadi, C. Gunawan, A. Setijadi, C. Machbub, "First step toward Internet based embedded control system", 51h Asian Control Conference, Melbourne, Australia, Jul. 2004, vol. 2, pp. 1226- 1231. [30] J. Kim, D. Choi, I. Kim, H. Kim, "Product Authentication Service of Consumer's mobile RFID Device" Tenth Int. Symposium on Consumer Electronics, St. Petersburg, Russia, Jul. 2006, pp. 1-6.

52

[31] P. Israsena, "Securing ubiquitous and low-cost RFID using tiny encryption algorithm", 2006, pp. 4. [32] L. Jun-Dian, F, Chih-Peng, "Efficient low-latency RC4 architecture designs for IEEE 802.11 i WEP/TKIP, Int. Symposium on Intelligent Signal Processing and
Communication Systems, Xiamen, China, Dec. 2007, pp. 56-59.
1st

Int. Symposium on Wireless Pervasive Computing, Phuket, Thailand, Jan.

[33] P. Ekdahl, T. Johansson, "Another attack on A511 [GSM stream cipher]", IEEE Int.
Symposium on Information Theory, Washington, D.C., USA, Jun. 2001, pp. 160.

[34] K. Jarvinen, M. Tommiska, J. Skytta, "Hardware Implementation Analysis of the MD5 Hash Algorithm", Proceedings of the 38th Int. Conference on System Sciences, Hawaii, USA, Jan. 2005, pp. 298a. [35] National Institute of Standards and Technology (NIST). (1995, Apr.) SHA- 1 standard. [Online]. Available: http://www.itl.nist.gov/fipspubs/fip1801.htm

53

APPENDIX A
TINY ENCRYPTION ALGORITHM (VHDL)
library IEEE; use IEEE.STD LOGIC 1164.ALL; use IEEE.STD_LOGIC_ARITH.ALL; use IEEE.STD_LOGIC_UNSIGNED.ALL; use IEEE.MATH_REAL.all; use IEEE.NUMERIC STD.ALL; package subtype subtype subtype subtype subtype types is bit t is std_logic; round t i s std_logic vector (4 word_t is std_logic_vector (31 text t i s std_logic_vector (63 key_t is std_logic vector (127 .- x"9e3779b9";

downto downto downto downto

0); 0); 0); 0);

constant delta: word t end types;

library IEEE; use IEEE.STD LOGIC 1164.ALL; use IEEE.STD_LOGIC_ARITH.ALL; use IEEE.STD_LOGIC_UNSIGNED.ALL; use IEEE.NUMERIC STD.ALL; use IEEE.MATH REAL.all; use work.types.all; entity tea is generic( zero
) ;

Integer .- 0

(key in key_t; Reset: in bit t; Ready: in bit_t; encrypt_outputMSB_Y encrypt outputLSB_Z enable : in bit_t; elk : in bitt); end tea;

Port

out std_logic_vector(31 downto 0); out std_logic vector(31 downto 0);

architecture Behavioral of tea is type Statetype is (INIT delta,State1,State3,delta done,INIT,updatesum,fourbitLSZ,Term1,fi vebitRSZ,Term2,Term3,part1,newY,fourbitLSY,Term4,fivebitRSY,TermS,Term6 ,part2,newZ,checkrounds,delay,decode_init,updatesum_decode,fourbitLSY_d ,Term7,fivebitRSY_d,Term8,Term9,part3,newZ_d,fourbitLSZ d,Term10,fivebi tRSZ d,Term11,Term12,part4,newY_d,checkrounds d,done); signal State : Statetype; signal sum,inv_sum signal counter,counter1 std_logic vector(31 downto 0); std_logic vector(3 downto 0);

54

signal · signal signal signal signal signal signal signal signal signal signal signal signal signal signal signal signal signal begin

delay_counter std_logic_vector(7 downto 0); rounds std_logic_vector(7 downto 0); kO,k1,k2,k3 std_logic_vector(31 downto 0); Y,Z std_logic_vector(31 downto 0); tempZ,tempZ1 std_logic_vector(31 downto 0); tempY,tempY1 std_logic_vector(31 downto 0); lshiftedz, rshiftedz std_logic_vector(31 downto 0); lshiftedy,rshiftedy std_logic_vector(31 downto 0); key_temp key_t := x"00112233445566778899aabbccddeeff"; delta copy std_logic_vector(31 downto 0); L,R std_logic_vector(31 downto 0); max rounds std_logic_vector(31 downto 0); random number std_logic_vector(31 downto 0); std_logic_vector(15 downto 0) delta counter integer range 0 to 31; cnt std logic_vector (63 downto 0) .- x"OOOOOOOOOOOOOOOO"; temp std_logic_vector(63 downto 0) x"OOOOOOOOOOOOOOOO"; result Y out std_logic vector(31 downto 0) .- x"OOOOOOOO";

PO: process(clk,Reset) begin
if (Reset
I 1 I) then <= sum <= counter <= counter1 <= rounds <= tempZ <= tempZ1 <= lshiftedz <= 1 R <= <= rshiftedz <= lshiftedy <= tempY <= tempY1 <= random number <= rshiftedy encrypt - outputMSB- y <= encrypt outputLSB z <= y <= z <= <= max rounds <= random number <= State

(others => I Q I ) ; (others => I Q I ) ; (others => I 0 I ) ; (others => I 0 I ) ; (others => I 0 I ) ; (others => I Q I ) ; (others => I Q I ) ; (others => I 0 I ) ; (others => I Q I ) ; (others => I 0 I ) ; (others => I 0 I ) ; (others => I 0 I ) ; (others => I 0 I ) ; (others => I 0 I ) ; (others => I 0 I ) ; (others => I 0 I ) ; (others => I 0 I ) ; x"01234567"; x"89abcdef"; x"00000032"; -- 50 rounds x"00000028"; INIT delta;
1

elsif(clk 1 event and elk case (State) is when INIT delta =>

1

1

1

and enable=

1

1

)

then

cnt <= conv integer(delta_counter); temp <= "00000000000000000000000000000000" & delta; State <= State1;

55

when State1 => if(delta_counter < 31) then temp<= temp(62 downto 0) & '0'; if(max_rounds(conv_integer(delta_counter)) result <= result + temp; end if; delta counter<= delta counter+ '1'; State <= State1; else State <= State3; end if; when State3 => Y out<= result(31 downto 0); State <= delta done; when delta done => State <= INIT; when INIT => delta copy kO k1 k2 k3
y

'1') then

z
tempZ tempZ1 tempY tempY1 State

<= <= <= <= <= <= <= <= <= <= <= <=

delta; key _temp(127 down to 96) ; key_temp(95 down to 64) ; key_temp(63 down to 32) ; key- temp(31 down to 0) ; x"01234567"; x"89abcdef"; Z; Z; Y; Y; updatesum;

------ Encode Routine ----------- Y <= Y + ( (lshiftedz+kO) xor (z+sum) xor (rshiftedz+k1) ); -when updatesum => if (rounds < max_rounds) then sum <= sum + delta_copy; rounds <= rounds + 1; State <= fourbitLSZ; else State <= done; end if; when fourbitLSZ => z << 4 if (counter < "0100") then tempZ <= tempZ(30 downto 0) & '0';-- 4 bit left shift counter <= counter + 1; State <= fourbitLSZ; else lshiftedz <= tempZ; counter<= conv std logic vector(conv_unsigned(zero,4),4); State <= Term1; end if; when Term1 => lshiftedz <= lshiftedz + kO;

56

State <= fivebitRSZ; when fivebitRSZ => z >> 5 if (counter1 < "0101") then tempZ1 <= '0' & tempZ1(31 downto 1); -- 5 bit right shift counter1 <= counter1 + 1; State <= fivebitRSZ; else rshiftedz <= tempZ1; counter1 <= conv std logic vector(conv_unsigned(zero,4),4); State <= · Term2; end if; when Term2 => rshiftedz <= rshiftedz + k1; <= Term3; State when Term3 => L <= lshiftedz xor (z + sum) xor rshiftedz; State <= part1; when part1 => y <= y + L; State <= newY; when newY tempY tempY1 State => <= Y; <= Y; <= fourbitLSY;

when fourbitLSY => -- Y << 4 if (counter < "0100") then tempY <= tempY(30 downto 0) & '0'; counter <= counter + 1; State <= fourbitLSY; else lshiftedy <= tempY; counter<= conv std logic vector(conv_unsigned(zero,4),4); State <= Term4; end if; when Term4 => lshiftedy <= lshiftedy + k2; State <= fivebitRSY;
-- y >> 5 when fivebitRSY => if (counter1 < "0101") then tempY1 <= '0' & tempY1(31 downto 1); counter1 <= counter1 + 1; State <= fivebitRSY; else rshiftedy <= tempY1; counter1 <= conv_std_logic_vector(conv_unsigned(zero,4),4); -- Reset counter1 State <= TermS; end if;

57

when TermS => rshiftedy <= rshiftedy + k3; State <= Term6; when Term6 => R <= lshiftedy xor (y + sum) xor rshiftedy; State <= part2; when part2 => Z <= Z + R; State <= newZ; when newZ => tempZ <= Z; tempZ1<= Z; State <= checkrounds; when checkrounds => if (rounds < max rounds) then State <= updatesum; else encrypt outputMSB_Y <= Y; encrypt_outputLSB Z <= Z; State <= delay; end if; when delay => if (delay_counter < max rounds) then -- count to 32 delay_counter <= delay_counter + 1; else State <= decode init; end if; -------------Decode Routine -------------------when decode init => -- Reset value of rounds, L and R <= conv std_logic_vector(conv_unsigned(zero,8),8); rounds <= conv_std_logic_vector(conv_unsigned(zero,31),32); L <= conv_std_logic vector(conv_unsigned(zero,31),32); R <= Z; tempZ <= Z; tempZ1 <= Y; tempY <= Y; tempY1 inv sum <= Y_out; <= updatesum_decode; State when updatesum_decode => if (rounds < max rounds) then rounds <= rounds + 1; State <= fourbitLSY_d; else State <= done; end if; when fourbitLSY d = > if (counter < "0100") then tempY <= tempY(30 downto 0)

& '0';

58

counter <= counter + 1; State <= fourbitLSY_d; else lshiftedy <= tempY; counter<= conv_std_logic_vector(conv_unsigned(zero,4),4); State <= Term7; end if; when Term7 => lshiftedy <= lshiftedy + k2; State <= fivebitRSY_d; when fivebitRSY d => if (counter1 < "0101") then tempY1 <= '0' & tempY1(31 downto 1); counter1 <= counter1 + 1; State <= fivebitRSY_d; else rshiftedy <= tempY1; counter1 <= conv std logic vector(conv_unsigned(zero,4),4); State <= TermS; end if; when TermS => rshiftedy <= rshiftedy + k3; State <= Term9; when Term9 => L <= lshiftedy xor (y + inv sum) xor rshiftedy; State <= part3; when part3 => Z <= Z - L; State <= newZ d; when newZ d => tempZ <= Z; tempZ1<= Z; State <= fourbitLSZ d; when fourbitLSZ d => if (counter < "0100") then tempZ <= tempZ(30 downto 0) & '0'; -- 4 bit left shift counter <= counter + 1; State <= fourbitLSZ d; else lshiftedz <= tempZ; counter<= conv_std_logic_vector(conv_unsigned(zero,4),4); State <= Term10; end if; when Term10 => lshiftedz <= lshiftedz + kO; State <= fivebitRSZ_d; when fivebitRSZ d =>

59

if (counter1 < "0101") then tempZ1 <= '0' & tempZ1(31 downto 1); -- 5 bit right shift counter1 <= counter1 + 1; State <= fivebitRSZ d; else rshiftedz <= tempZ1; counter1 <= conv std logic vector(conv_unsigned(zero,4),4); State <= Term11; end if; when Term11 => rshiftedz <= rshiftedz + k1; State <= Term12; when Term12 => R <= lshiftedz xor (z + inv sum) xor rshiftedz; State <= part4; when part4 => y <= y - R; State <= newY d; when newY d => tempY <= Y; tempY1 <= Y; State <= checkrounds d; when checkrounds d => if (rounds < max rounds) then inv_sum <= inv_sum - delta_copy; State <= updatesum_decode; else encrypt_outputMSB_ Y <= Y; encrypt_outputLSB Z <= Z; State <= done; end if; when done => null; when others => State <= INIT; end case; end if; end process PO; end Behavioral;

TINY ENCRYPTION ALGORITHM (C Language - Hardware/Software Approach: Reader Implementation)
#include <stdio.h> #include <altera avalon jtag uart regs.h> #include <system.h> long* decode(long* v1,long* v2,long* k);

60

int main ()
{

unsigned unsigned unsigned unsigned

long long long long

k[4]={0x00112233,0x44556677,0x8899aabb,Oxccddeeff}; * decrypt_inputl; * decrypt input2; * final;

final= (unsigned long *) OxOOOOOBOOO; //stores the decrypted result decrypt inputl =(unsigned long *)OxOOOOOOlO; //input encrypted MSB decrypt_input2 =(unsigned long *)Ox00000020; //input encrypted LSB final= decode(decrypt inputl,decrypt input2,k); printf(" %.6lx(hex)\n", *final); //displays the final output return 0;

long* decode(long* vl,long* v2,long* k) { unsigned long n=32, sum, y=*vl, z=*v2, *result, delta=Ox9e3779b9 surn=delta<<S ; while (n-- > 0) { z- = ( ( y< < 4 ) + k [ 2 ] ) /\ ( y+ s urn) /\ ( ( y > > 5 ) + k [ 3 ] ) y-= ((z<<4)+k[O]) /\ (z+surn) /\ ((z>>S)+k[l]) surn-=delta ; } // end cycle result = &y; return result;}

61

APPENDIXB
VARIABLE KEY SCHEME (VHDL)
TOP LEVEL

library IEEE; use IEEE.std_logic_1164.all; use IEEE.std_logic_arith.all; use IEEE.std_logic signed.all; entity toplevel is port( Reset,Clk
) ;

IN

std_logic

end entity toplevel; architecture struct of toplevel is signal signal signal signal signal signal signal signal signal signal signal signal signal signal signal signal connecting- strobe tag- response match found sync reader - output ready send- next key verified- outputY verified_outputz random number encrypt - outputMSB y encrypt outputLSB z new- key - value reader encrypt outputMSB- y reader - encrypt outputLSB z final - decryptY final decryptZ std- logic; std_logic; std_logic; std- logic; std- logic; std- logic; std- logic - vector(31 std- logic - vector(31 std_logic_vector(31 std- logic - vector(31 std- logic - vector(31 std_logic_vector(63 std- logic - vector(31 std_logic_vector(31 std- logic - vector(31 std- logic vector(31

down to down to down to down to down to down to down to down to down to down to

0) 0) 0) 0) 0) 0) 0) 0) 0) 0)

; ; ; ; ; ; ; ; ; ;

component reader is generic( zero
) ;

Integer := 0

Port

Reset in std_logic; output strobe out std_logic; reader_output ready out std_logic; feedback in std_logic; sync in std_logic; send_next key in std_logic; match found out std_logic; random number out std_logic_vector(31 downto 0); encrypt outputMSB_Y in std_logic_vector(31 downto 0); encrypt_outputLSB Z in std_logic vector(31 downto 0); verified_outputY out std_logic vector(31 downto 0); reader_encrypt_outputMSB Y out std_logic_vector(31 downto 0); reader_encrypt_outputLSB_Z : out std_logic vector(31 downto 0);

62

verified_outputZ elk end component reader; component tag is generic( zero
) ;

out std_logic_vector(31 downto 0); in std_logic);

Integer := 0

random number in std_logic vector(31 downto 0); enable in std_logic; Reset in std_logic; send next key out std_logic; new_key_value out std_logic_vector(63 downto 0); tag_encrypt outputMSB Y: out std_logic_vector(31 downto 0); tag_encrypt_outputLSB Z : out std_logic_vector(31 downto 0); final_decryptY out std_logic_vector(31 downto 0); final_decryptZ out std_logic vector(31 downto 0); reader_output_ready: in std_logic; reader_encrypt_outputMSB_Y : in std_logic_vector(31 downto 0); reader_encrypt outputLSB_Z : in std_logic vector(31 downto 0); output ready out std logic; sync out std_logic; elk in std_logic); end component tag; Port begin Ul: reader generic map( zero => 0 port map Clk Reset output strobe feedback sync send next key reader_encrypt outputMSB_Y reader_encrypt_outputLSB_Z reader_output ready match found encrypt_outputMSB_Y encrypt_outputLSB Z verified_outputY verified_outputZ random number
) ;

=> => => => => => => => => => => => => => =>

Clk, Reset, connecting strobe, tag_response, sync, send_next_key, reader_encrypt outputMSB_Y, reader encrypt outputLSB Z, reader output ready, match_found, encrypt outputMSB_Y, encrypt_outputLSB Z, verified_outputY, verified_outputz, random number

U2: tag generic map( zero

=> 0

port map ( elk Reset random number

=> Clk, => Reset, => random number,

63

enable output ready sync send_next_key new key value reader_;utput ready reader_encrypt_outputMSB Y reader_encrypt outputLSB Z final_decryptY final_decryptZ tag encrypt outputMSB Y tag_encrypt outputLSB_Z
) ;

=> => => => => => => => => => => =>

connecting strobe, tag_response, sync, send_next key, new_key_value, reader_output_ready, reader_encrypt_outputMSB Y, reader encrypt_outputLSB Z, final_decryptY, final decryptZ, encrypt outputMSB Y, encrypt outputLSB_Z

end architecture;

READER (Reader.vhd)

library IEEE; use IEEE.STD LOGIC 1164.ALL; use IEEE.STD_LOGIC_ARITH.ALL; use IEEE.STD_LOGIC_UNSIGNED.ALL; use IEEE.NUMERIC_STD.ALL; use IEEE.MATH REAL.all; entity reader is generic( zero
) ;

Integer .- 0

Port

Reset output strobe reader_output ready feedback sync match found send_next key random number encrypt outputMSB Y encrypt_outputLSB_Z reader_encrypt_outputMSB_Y reader encrypt outputLSB Z verified_outputY verified_outputZ elk end reader;

in std_logic; out std_logic; out std_logic; in std_logic; in std_logic; out std_logic; in std_logic; out std_logic_vector(31 downto 0); in std_logic_vector(31 downto 0); in std_logic_vector(31 downto 0); out std_logic_vector(31 downto 0); out std_logic_vector(31 downto 0); out std_logic_vector(31 downto 0); out std_logic vector(31 downto 0); in std_logic);

architecture Behavioral of reader is type Statetype is (INIT,INIT_delta,Statel,State3,random,initialize_Y_Z,new_state,check_fe edback,wait state,delay,decode init,updatesum,updatesum_decode,fourbitL SY_d,Term7,fivebitRSY_d,Term8,Term9,part3,newZ_d,fourbitLSZ_d,TermlO,fi vebitRSZ_d,Termll,Term12,part4,newY_d,checkrounds_d,fourbitLSZ,Terml,fi vebitRSZ,Term2,Terrn3,partl,newY,fourbitLSY,Terrn4,fivebitRSY,Term5,Terrn6 ,part2,newZ,checkrounds,gen_new_key,final,done,do_nothing);

64

signal State : Statetype; signal rdelta,delta std_logic vector(31 downto 0) := x"9e3779b9"; signal rounds,rrounds std_logic vector(7 downto 0); signal tempZ,tempZ1,rtempZ,rtempZ1: std_logic_vector(31 downto 0); signal tempY,tempY1,rtempY,rtempY1: std_logic_vector(31 downto 0); signal L,R,rL,rR std_logic_vector(31 downto 0); signal sum,rsum std_logic vector(31 downto 0); signal inv_sum,rinv_sum: std_logic_vector(31 downto 0); signal rdelta copy std_logic_vector(31 downto 0) := x"9e3779b9"; signal Y,rY,Z,rZ std_logic vector(31 downto 0); signal lshiftedz,rlshiftedz std_logic_vector(31 downto 0); signal rshiftedz,rrshiftedz std_logic_vector(31 downto 0); signal lshiftedy,rlshiftedy std_logic_vector(31 downto 0); signal rshiftedy,rrshiftedy std_logic_vector(31 downto 0); signal max rounds,rmax rounds : std_logic_vector(31 downto 0); signal counter,counter1,rcounter : std_logic_vector(3 downto 0); signal rand_counter : std_logic_vector(15 downto 0); signal delay_counter,rdelay_counter: std_logic_vector(7 downto 0); signal rcounter1 : std_logic vector(3 downto 0); signal rkO,rk1,rk2,rk3,kO,k1,k2,k3 : std_logic_vector(31 downto 0); signal rkey_temp : std_logic_vector(127 downto 0) .x "00112233445566778899aabbccddeeff"; signal storediD Y std_logic_vector(31 downto 0) x"01234567"; signal storediD Z : std_logic_vector(31 downto 0) .- x"89abcdef"; signal wait_cntr : std_logic_vector(15 downto 0); signal delta_counter,rdelta counter : std_logic vector(15 down to 0) "0000000000000000"; signal delta copy std_logic_vector(31 downto 0); signal cnt,rcnt integer range 0 to 31; signal temp,rtemp std_logic vector(63 downto 0) .x"OOOOOOOOOOOOOOOO"; signal result,rresult std_logic vector(63 downto 0) .x "OOOOOOOOOOOOOOOO"; signal Y_out,rY_out std_logic_vector(31 downto 0) .- x"OOOOOOOO"; signal new_key std_logic_vector(127 downto 0); signal saved copy random_number : std_logic_vector(31 downto 0); signal t_verifiedY,t_verifiedZ: std_logic vector(31 downto 0); signal match_found_reg std_logic; signal key_cntr std_logic; signal readers_copyiDY std_logic_vector(31 downto 0) .- x"01234567"; signal readers copyiDZ std_logic vector(31 downto 0) .- x"89abcdef"; begin process(clk,Reset) variable int rand integer; variable seed1, seed2: positive .- 12; variable rand : real; begin if (Reset = '1') then random number rsum sum rcounter rcounter1

<= <= <= <= <=

(others (others (others (others (others

=> => => => =>

'0' '0' '0' '0' '0'

); ); ); ); );

65

<= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= I 0 I; <= IQI; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= I 0 I ; <= x"00000032"; -- 50 rounds <= x"00000032"; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; y <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; z <= (others=> 1 0 1 ) ; tempZ <= (others=> 1 0 1 ) ; tempZ1 <= (others=> 1 0 1 ) ; tempY <= (others=> 1 0 1 ) ; tempY1 <= (others=> 1 0 1 ) ; lshiftedz rshiftedz <= (others=> 1 0 1 ) ; lshiftedy <= (others=> 1 0 1 ) ; rshiftedy <= (others=> 1 0 1 ) ; L <= (others=> 1 0 1 ) ; R <= (others=> 1 0 1 ) ; reader encrypt outputMSB_Y <= (others=> 1 0 1 ) ; reader encrypt_outputLSB Z <= (others=> 1 0 1 ) ; reader output_ready <= 1 0 1 ; match found_reg <= 1 0 1 ; State <= check_feedback; rand counter rrounds rtempZ rtempZ1 rlshiftedz rL rR rrshiftedz rlshiftedy wait cntr rtempY new key rtempY1 rrshiftedy output_strobe match found verified_outputY verified_outputZ key_cntr rmax rounds max rounds inv sum counter counter1 wait cntr delay_counter rounds elsif(clk 1 event and elk= case (State) is when check feedback => if (feedback= 1 0 1 )then State <= random; elsif (feedback= 1 1 1 ) then State <= INIT delta; end if; when random =>
1

11

)

then

66

if (rand_counter < "0000011010101000") then UNIFORM(seed1, seed2,rand); if (rand < 0.2) then random_number <= x"00000028"; --40 rounds saved_copy_random_number <= x"00000028"; output strobe<= '1'; else random number <= x"00000038"; --50 rounds saved_copy_random_number <= x"00000028"; output strobe<= '1'; end if; rand counter<= rand counter+ '1'; State <= random; else output strobe<= '0'; State <= check_feedback; end if; when INIT delta => newdelta maxrounds*delta rY <= encrypt outputMSB Y; rZ <= encrypt_outputLSB Z; rent<= conv_integer(rdelta counter); rtemp <= "00000000000000000000000000000000" & rdelta; State <= State1; when State1 => if(rdelta_counter < 31) then rtemp <= rtemp(62 downto 0) & '0'; if(rmax rounds(conv_integer(rdelta counter)) rresult <= rresult + rtemp; end if; rdelta counter<= rdelta counter+ '1'; State <= State1; else State <= State3; end if; when State3 => rY out<= rresult(31 downto 0); State <= delay; when delay => if (rdelay_counter < rmax_rounds) then -- count to 32 (delay) rdelay_counter <= rdelay_counter + 1; else State <= decode init; end if; --------------------------- Decode Routine -------------------------when decode init => -- Reset rounds,R,L rrounds <= conv_std_logic_vector(conv_unsigned(zero,8),8); rL <= conv_std_logic_vector(conv_unsigned(zero,31),32); rR <= conv_std_logic_vector(conv_unsigned(zero,31),32); rtempZ <= rZ;

'1') then

67

rtempZ1 rtempY rtempY1 rinv sum rkO rk1 rk2 rk3 State

<= <= <= <= <= <= <= <= <=

rZ; rY; rY; rY - out; rkey_temp(127 down to 96) ; rkey_temp(95 down to 64) ; rkey _temp(63 down to 32); rkey_temp(31 down to 0) ; update sum- decode;

when updatesum_decode => if (rrounds < rmax rounds) then rrounds <= rrounds + 1; State <= fourbitLSY_d; else State <= done; end if; when fourbitLSY d => if (rcounter < "0100") then rtempY <= rtempY(30 downto 0) & '0'; rcounter <= rcounter + 1; State <= fourbitLSY d; else rlshiftedy <= rtempY; rcounter <= conv_std_logic vector(conv_unsigned(zero,4),4); State<= Term7; end if; when Term7 => rlshiftedy <= rlshiftedy + rk2; State <= fivebitRSY_d; when fivebitRSY d => if (rcounter1 < "0101") then rtempY1 <= '0' & rtempY1(31 downto 1); rcounter1 <= rcounter1 + 1; State <= fivebitRSY_d; else rrshiftedy <= rtempY1; rcounter1<=conv_std_logic_vector(conv_unsigned(zero,4),4); State <= TermS; end if; when TermS => rrshiftedy <= rrshiftedy + rk3; State <= Term9; when Term9 => rL <= rlshiftedy xor (rY + rinv sum) State <= part3; when part3 => rZ <= rZ - rL; State <= newZ d; when newZ d =>

xor rrshiftedy;

68

rtemP.Z <= rZ; rtempZ1 <= rZ; State <= fourbitLSZ_d; when fourbitLSZ d => if (rcounter < "0100") then rtempZ <= rtempZ(30 downto 0) & '0'; -- 4-bit left shift rcounter <= rcounter + 1; State <= fourbitLSZ d; else rlshiftedz <= rtempZ; rcounter<=conv_std_logic_vector(conv_unsigned(zero,4),4); State <= Term10; end if; when Term10 => rlshiftedz <= rlshiftedz + rkO; State <= fivebitRSZ d; when fivebitRSZ d => if (rcounter1 < "0101") then rtempZ1 <= '0' & rtempZ1(31 downto 1); -- 5 bit right shift rcounter1 <= rcounter1 + 1; State <= fivebitRSZ d; else rrshiftedz <= rtempZ1; rcounter1 <= conv_std_logic vector(conv_unsigned(zero,4),4); State <= Termll; end if; when Termll => rrshiftedz <= rrshiftedz + rkl; State <= Term12; when Term12 => rR <= rlshiftedz xor (rz + rinv sum) xor rrshiftedz; State <= part4; when part4 => rY <= rY - rR; State <= newY d; when newY d => rtempY <= rY; rtempY1 <= rY; State <= checkrounds d; when checkrounds d => if (rrounds < rmax_rounds) then rinv_sum <= rinv_sum - rdelta copy; State <= updatesum_decode; else verified_outputY <= rY xor saved_copy_random_number; verified_outputZ <= rZ xor saved copy_random_number; t verifiedZ <= rZ xor saved_copy_random_number; t verifiedY <= rY xor saved_copy_random_number; State <= done;

69

end if; when done => if( (t_verifiedZ xor saved_copy_random_number) if( (t_verifiedY xor saved_copy_random_number) match found <= 1 1 1 ; match_found_reg <= 1 1 1 ; <= gen_new_key; State end if; else match found end if; when gen new_key => <= (others=> 1 0 1 ) ; z <= (others=> 1 0 1 ) ; if (match found_reg = 1 1 1 ) then new_key <= x"34676398ad9c23ef814574346613712b"; State <= initialize Y Z; else State <= INIT_delta; end if; when initialize Y Z => -- key counter keeps track of the first & second half of key sent 1 if (key_cntr 0 1 ) then Y <= storediD Y xor new key(127 downto 96); Z <= storediD Z xor new_key(95 downto 64); elsif (key_cntr
y
y

readers_copyiDZ) then readers copyiDY) then

<=

101;

z
tempZ tempZ1 tempY tempY1 lshiftedz lshiftedz lshiftedy rshiftedy counter counter1 sum rounds
L
R

1 1 ) then <= storediD Y xor new_key(63 downto 32); <= storediD Z xor new_key(31 downto 0); <= (others=> 1 0 1 ) ; <= (others=> 1 0 1 ) ; <= (others => I O I); <= (others => I 0 I ) ; <= (others => I O I ) ; <= (others => I 0 I ) ; <= (others => I 0 I ) ; <= (others => I 0 I ) ; <= (others => I 0 I ) ; <= (others => I 0 I ) ; <= (others => I 0 I ) ; <= (others => I O I ) ; <= (others => I 0 I ) ; <= (others => I 0 I ) ;
1

end if; State <= INIT; when INIT => delta copy

kO
k1 k2 k3 tempZ

<= <= <= <= <= <=

delta; rkey_temp(127 downto 96); rkey_temp(95 downto 64); rkey_temp(63 downto 32); rkey_temp(31 downto 0); Z;

70

tempZ1 tempY tempY1 rounds State

<= <= <= <= <=

Z; Y; Y; (others => updatesum;

I

0I

)

;

------------ Encode Routine -----------Y <= Y + ( (lshiftedz+kO) xor (z+sum) xor (rshiftedz+k1)); -when update sum => if (rounds < max rounds) then <= sum + delta copy; sum <= rounds + 1; rounds <= fourbitLSZ; State else <= done; State end if; when fourbitLSZ => Z << 4 if (counter < "0100") then tempZ <= tempZ(30 downto 0) & 1 0 1 ; - - 4bit lshift <= counter + 1; counter <= fourbitLSZ; State else lshiftedz <= tempZ; counter <=conv_std_logic vector(conv_unsigned(zero,4),4); State <= Term1; end if; when Term1 => lshiftedz State

<= lshiftedz + kO; <= fivebitRSZ;

when fi vebi tRSZ => Z >> 5 if (counter1 < "0101") then tempZ1 <= 1 0 1 & tempZ1(31 downto 1); -- 5 bit rshift counter1 <= counter1 + 1; State <= fivebitRSZ; else rshiftedz <= tempZ1; counter1<=conv_std_logic_vector(conv_unsigned(zero,4),4); State <= Term2; end if; when Term2 => rshiftedz State when Term3 => L State when part1 => y <= y + L; State <= newY; when newY =>

<= rshiftedz + k1; <= Term3;

<= lshiftedz xor (z + sum) xor rshiftedz; <= part1;

71

tempY tempY1 State

<= Y; <= Y; <= fourbitLSY;

when fourbitLSY => -- Y << 4 if (counter < "0100") then tempY <= tempY(30 downto 0) & '0'; counter <= counter + 1; State <= fourbitLSY; else lshiftedy<= tempY; counter <= conv std logic vector(conv_unsigned(zero,4),4); State <= Term4; end if; when Term4 => lshiftedy State

<= lshiftedy + k2; <= fivebitRSY;

-- y >> s when fivebitRSY => if (counter1 < "0101") then tempY1 <= '0' & tempY1(31 downto 1); <= counter1 + 1; counter1 <= fivebitRSY; State else rshiftedy <= tempY1; counter1<=conv_std_logic vector(conv_unsigned(zero,4),4); State <= TermS; end if;
when TermS => rshiftedy State when Term6 => R State when part2 => <= rshiftedy + k3; <= Term6;

<= lshiftedy xor (y + sum) xor rshiftedy; <= part2; <= z + R; <= newZ;

z
State when newZ => tempZ tempZ1 State

<= Z; <= Z; <= checkrounds;

when checkrounds => if (rounds < max rounds) then <= updatesum; State else reader encrypt outputMSB_Y <= Y; reader encrypt outputLSB Z <= Z; State <= wait state; end if; when wait state =>

72

if (wait_cntr < "0000000000101000") then wait_cntr <= wait_cntr + '1'; reader_output ready<= '1'; State <= wait state; else reader output_ready <= '0'; wait cntr <= "0000000000000000"; State <= do nothing; end if; when do_nothing => if (send_next key_cntr State <= else State <= end if; when others => null; end case; end if; end process; end Behavioral;

key= '1' and key_cntr <= '1'; initialize Y Z; do_nothing;

'0') then

TAG

(Tag. vhd)

library IEEE; use IEEE.STD LOGIC 1164.ALL; use IEEE.STD_LOGIC_ARITH.ALL; use IEEE.STD_LOGIC_UNSIGNED.ALL; use IEEE.MATH_REAL.all; use IEEE.NUMERIC STD.ALL; package subtype subtype subtype subtype subtype types is bit t is std_logic; round t i s std_logic vector (4 word_t is std_logic_vector (31 text_t is std_logic_vector (63 key_t is std_logic_vector (127 x"9e3779b9";

downto downto downto downto

0); 0); 0); 0);

constant delta: word t end types;

library IEEE; use IEEE.STD LOGIC 1164.ALL; use IEEE.STD LOGIC ARITH.ALL; use IEEE.STD LOGIC UNSIGNED.ALL; use IEEE.NUMERIC STD.ALL; use IEEE.MATH REAL.all; use work.types.all;

73

entity tag is generic( zero
) ;

Integer := 0

Port

random number in std_logic vector(31 downto 0); enable in std_logic; Reset in std_logic; tag_encrypt_outputMSB_Y out std_logic vector(31 downto 0); tag encrypt outputLSB Z out std_logic vector(31 downto 0); reader output ready in std_logic; send_next_key out std_logic; reader_encrypt_outputMSB_Y: in std_logic_vector(31 downto 0); reader_encrypt outputLSB Z : in std_logic_vector(31 downto 0); final_decryptY out std_logic_vector(31 downto 0); final_decryptZ out std_logic_vector(31 downto 0); new_key_value out std_logic_vector(63 downto 0); output ready out std_logic; sync out std_logic; elk in bitt); end tag;

architecture Behavioral of tag is type Statetype is (delta_done,done_l,done 2,done 3,INIT,INIT delta,check_feedback,INIT de lta d,Statel,State3,Statel d,State3 d,updatesum,decode_init,updatesum_d ecode,fourbitLSY_d,Term7,fivebitRSY d,Term8,Term9,part3,newZ_d,fourbitL SZ d,TermlO,fivebitRSZ_d,Termll,Term12,part4,newY_d,checkrounds_d,fourb itLSZ,Terml,fivebitRSZ,Term2,Term3,partl,newY,fourbitLSY,Term4,fivebitR SY,Term5,Term6,part2,newZ,checkrounds,delay,wait state,final,done); signal State : Statetype; signal sum,inv_sum : std_logic_vector(31 downto 0); signal counter,counterl: std_logic_vector(3 downto 0); signal wait cntr std_logic_vector(lS downto 0); signal delay_counter std_logic_vector(7 downto 0); signal rounds std_logic_vector(7 downto 0); signal kO,kl,k2,k3 std_logic_vector(31 downto 0); signal Y,Z std_logic_vector(31 downto 0); signal tempZ,tempZl std_logic_vector(31 downto 0); signal tempY,tempYl std_logic_vector(31 downto 0); signal lshiftedz std_logic_vector(31 downto 0); signal concat,concatl std_logic_vector(31 downto 0); signal rshiftedz std_logic_vector(31 downto 0); signal lshiftedy std_logic_vector(31 downto 0); signal rshiftedy std_logic_vector(31 downto 0); signal delta counter std_logic vector(15 downto 0); signal key temp key_t := x"00112233445566778899aabbccddeeff"; signal delta copy std_logic_vector(31 downto 0); signal L,R std_logic_vector(31 downto 0); signal max rounds std_logic_vector(31 downto 0); signal cnt,rcnt integer range 0 to 31; std_logic_vector(63 downto 0); signal temp signal result std_logic_vector(63 downto 0); std_logic_vector(31 downto 0); signal Y_out,rY out signal rdelta std_logic_vector(31 downto 0) .x"9e3779b9";

74

signal rdelta counter std_logic_vector(l5 downto 0); signal rrounds · std_logic_vector(7 downto 0); signal rtempZ,rtempZl std_logic_vector(31 downto 0); signal rtempY,rtempYl std_logic_vector(31 downto 0); signal rL,rR,rY,rZ std_logic_vector(31 downto 0); signal rsum,rinv_sum std_logic_vector(31 downto 0); signal rdelta_copy std_logic_vector(31 downto 0); signal rlshiftedz std_logic_vector(31 downto 0); signal rrshiftedz std_logic_vector(31 downto 0); signal rlshiftedy std_logic_vector(31 downto 0); signal rrshiftedy std_logic_vector(31 downto 0); signal rmax rounds std_logic_vector(31 downto 0); signal rcounter std_logic_vector(3 downto 0); signal rand counter std_logic_vector(l5 downto 0); signal rdelay_counter std_logic_vector(7 downto 0); signal rcounterl std_logic_vector(3 downto 0); signal rkO,rkl,rk2,rk3 std_logic_vector(31 downto 0); signal new_key std_logic_vector(l27 downto 0); signal rkey_temp std_logic_vector(l27 downto 0) .x"00112233445566778899aabbccddeeff"; signal rtemp,result : std_logic_vector(63 downto 0); signal saved_copy_random_number : std_logic vector(31 downto 0) : = x"00000028"; signal storediD_Y std_logic vector(31 downto 0) .x"01234567"; signal storediD_Z std_logic vector(31 downto 0) .x"89abcdef"; signal key_cntr std_logic; signal temp_send_next key: std_logic; begin PO: process(clk,Reset) begin if (Reset '1') then sum counter counterl rounds tempZ tempZl lshiftedz

<= (others=> '0'); <= (others=> '0'); <= (others=> '0'); <= (others=> '0'); <= (others=> '0'); <= (others=> '0'); <= (others=> '0'); L <= (others=> '0'); R <= (others=> '0'); send_next_key <= '0'; new_key_value <= (others=> '0'); rshiftedz <= (others=> '0'); lshiftedy <= (others=> '0'); tempY <= (others=> '0'); tempYl <= (others=> '0'); concat <= (others=> '0'); concatl <= (others=> '0'); wait cntr <= (others=> '0'); rshiftedy <= (others=> '0'); tag_encrypt outputMSB_Y <= (others=> '0'); tag_encrypt_outputLSB_Z <= (others=> '0'); final decryptY <= (others=> '0');

75

final - decryptZ output_ ready sync key_ cntr temp_ send- next - key rsum rresult rcounter rcounter1 rand counter rrounds rtempZ rtempZ1 rlshiftedz rL rR rrshiftedz rlshiftedy wait - cntr rtempY new- key rtempY1 rrshiftedy rmax rounds max - rounds rdelta copy
y

z
State elsif(clk'event and elk case (State) is when INIT delta =>

<= <= <= <= <= <= <= <= <= <= <= <= <= <= <= <= <= <= <= <= <= <= <= <= <= <= <= <=

(others => '0' ) ; '0'; '0'; '0'; '0' ; (others => '0' ) ; (others => '0' ) ; (others => '0' ) ; (others => '0' ) ; (others => '0' ) ; (others => '0' ) ; (others => '0' ) ; (others => '0' ) ; (others => '0' ) ; (others => '0') ; (others => '0' ) ; (others => '0' ) ; (others => '0' ) ; (others => '0' ) ; (others => '0' ) ; (others => '0' ) ; (others => '0') ; (others => '0' ) ; x"00000032"; -- 50 rounds x"00000032"; x"9e3779b9"; storediD Y xor random_number; storediD Z xor random number; <= INIT delta;

'1') then

cnt <= conv_integer(delta counter); temp <= "00000000000000000000000000000000" & delta; State <= State1; when State1 => if(delta counter < 31) then temp<= temp(62 downto 0) & '0'; if(max_rounds(conv_integer(delta counter)) result <= result + temp; end if; delta counter<= delta counter+ '1'; State <= State1; else State <= State3; end if; when State3 => y out <= result(31 down to 0) ; State <= delta done; when delta done => Y <= storediD Y;

'1') then

76

Z <= storediD Z; State <= INIT; when INIT => delta copy kO k1 k2 k3 tempZ tempZ1 tempY tempY1 State

<= <= <= <= <= <= <= <= <= <=

delta; key - temp(127 downto 96); key - temp(95 downto 64); key_ temp(63 downto 32); key_ temp(31 downto 0); Z; Z; Y; Y; update sum;

-------------------------- Encode Routine ---------------------Y <= Y + ( (lshiftedz+kO) xor (z+sum) xor (rshiftedz+k1)); -when updatesum => if (rounds < max rounds) then <= sum + delta copy; sum <= rounds + 1; rounds <= fourbitLSZ; State else <= done; State end if; z << 4 when fourbitLSZ => if (counter < "0100") then tempZ <= tempZ(30 downto 0) & '0'; -- 4bit lshift <= counter + 1; counter <= fourbitLSZ; State else lshiftedz <= tempZ; counter<=conv_std_logic vector(conv_unsigned(zero,4),4); State <= Term1; end if; when Term1 => lshiftedz State

<= lshiftedz + kO; <= fivebitRSZ;

-- z >> 5 when fivebitRSZ => if (counter1 < "0101") then tempZ1 <= '0' & tempZ1(31 downto 1);-- 5 bit rshift counter1 <= counter1 + 1; <= fivebitRSZ; State else rshiftedz <= tempZ1; counter1<=conv_std_logic vector(conv_unsigned(zero,4),4); State <= Term2; end if;
when Term2 => rshiftedz State when Term3 =>
L

<= rshiftedz + k1; <= Term3;

<= lshiftedz xor (z + sum)

xor rshiftedz;

77

State when part1 =>
y

<= part1;

State when newY => tempY tempY1 State

<= y + L; <= newY;

<= Y; <= Y; <= fourbitLSY;

-- y << 4 when fourbitLSY => if (counter < "0100") then tempY <= tempY(30 downto 0) & '0'; <= counter + 1; counter <= fourbitLSY; State else lshiftedy <= tempY; counter <=c o nv_std_logic vector(conv_unsigned(zero,4),4); State <= Term4; end if;
when Term4 => lshiftedy State

<= lshiftedy + k2; <= fivebitRSY;

-- y > > s when fivebitRSY = > if (counter1 < "0101") then tempY1 <= '0' & tempY1(31 downto 1); <= counter1 + 1; counter1 <= fi v ebitRSY; State else rshiftedy <= tempY1; counter1 <=conv_std_logic vector(conv_unsigned(zero,4),4); State <= TermS; end if;
when TermS = > rshiftedy State when Term6 = > R State when part2 => <= rshiftedy + k3; <= Term6;

<= lshiftedy xor <= part2; <= z + R; <= newZ;

(y + sum)

xor rshiftedy;

z
State when newZ = > tempZ tempZ1 State

<= Z; <= Z; <= checkrounds;

when checkrounds => if (rounds < max rounds) then State <= updatesum; else

78

tag_encrypt_outputMSB_Y <= Y; tag_encrypt outputLSB_Z <= Z; State <= wait state; end if; when wait state => if (wait cntr < "0000000000101000") then <=wait cntr + '1'; wait cntr <= '1'; output ready <= wait state; State else <= '0'; output ready <= '1'; sync <= "0000000000000000"; wait cntr <= INIT delta d; State end if; when INIT delta d => rent rtemp State newdelta = maxrounds*delta <= conv_integer(rdelta_counter); <= "00000000000000000000000000000000" & rdelta; <= State1 d;

when State1 d => if(rdelta counter < 31) then rtemp <= rtemp(62 downto 0) & '0'; if(rmax_rounds(conv_integer(rdelta_counter)) rresult <= rresult + rtemp; end if; <= rdelta counter+ '1'; rdelta counter <= State1_d; State else <= State3 d; State end if; when State3 d => rY_out <= rresult(31 downto 0); State <= delay;

'1')

then

when delay => if (reader output ready= '1') then rY <= reader encrypt outputMSB_Y; rZ <= reader encrypt outputLSB Z; <= decode init; State else <= delay; State end if; --------------------------- Decode Routine --------------------------when decode init => <= conv_std_logic_vector(conv_unsigned(zero,8),8); rrounds <= conv_std_logic_vector(conv_unsigned(zero,31),32); rL <= conv_std_logic_vector(conv_unsigned(zero,31),32); rR <= rZ; rtempZ <= rZ; rtempZ1 <= rY; rtempY <= rY; rtempY1 <= rY out; rinv sum

79

rkO rk1 rk2 rk3 State

<= <= <= <= <=

rkey_ temp(127 down to 96) ; rkey- temp(95 down to 64) ; rkey_ temp(63 down to 32) ; rkey_ temp(31 down to 0) ; updatesum_decode;

when updatesum_decode => if (rrounds < rmax rounds) then rrounds <= rrounds + 1; State <= fourbitLSY_d; else <= done; State end if; when fourbitLSY d => if (rcounter < "0100") then rtempY <= rtempY(30 downto 0) & '0'; rcounter <= rcounter + 1; State <= fourbitLSY d; else rlshiftedy <= rtempY; rcounter<=conv_std_logic vector(conv_unsigned(zero,4),4); State <= Term7; end if; when Term7 => rlshiftedy <= rlshiftedy + rk2; State <= fivebitRSY_d; when fivebitRSY d => if (rcounter1 < "0101") then rtempY1 <= '0' & rtempY1(31 downto 1); rcounter1 <= rcounter1 + 1; <= fivebitRSY_d; State else rrshiftedy<= rtempY1; rcounter1<=conv_std_logic vector(conv_unsigned(zero,4),4); State <= TermS; end if; when TermS => rrshiftedy <= rrshiftedy + rk3; State <= Term9; when Term9 => rL <= rlshiftedy xor (rY + rinv sum) State <= part3; when part3 => rZ <= rZ - rL; State <= newZ d; when newZ d = > rtempZ <= rZ; rtempZ1 <= rZ; State <= fourbitLSZ d;

xor rrshiftedy;

80

when fourbitLSZ d => if (rcounter < "0100") then rtempZ <= rtempZ(30 downto 0) & '0';-- 4 bit left shift rcounter <= rcounter + 1; State <= fourbitLSZ_d; else rlshiftedz <~ rtempZ; rc o unter<=conv_std_logic_vector(conv_unsigned(zero,4),4); State <= Term10; end if; when Term10 => rlshiftedz <= rlshiftedz + rkO; State <= fivebitRSZ d; when fivebitRSZ d => if (rcounter1 < "0101") then rtempZ1 <= '0' & rtempZ1(31 downto 1); -- 5 bit rshift rcounter1 <= rcounter1 + 1; State <= fivebitRSZ d; else rrshiftedz <= rtempZ1; rcounter1<=conv_std_logic_vector(conv_unsigned(zero,4),4); State <= Term11; end if; when Term11 => rrshiftedz <= rrshiftedz + rk1; State <= Term12; when Term12 => rR <= rlshiftedz xor (rz + rinv sum) xor rrshiftedz; State <= part4; when part4 => rY <= rY - rR; State <= newY_d; when newY d => rtempY <= rY; rtempY1 <= rY; State <= checkrounds_d; when checkrounds d => if (rrounds < rmax rounds) then rinv_sum <= rinv_sum - rdelta copy; State <= updatesum_decode; else final_decryptY <= rY; final_decryptZ <= rZ; State <= done 1; end if; when done 1 => <= rY xor storediD Y; concat <= rZ xor storediD Z; concat1 State <= done 2;

81

when done 2 => new key_value <= concat & concat1; send_next_key <= '1'; temp_send_next key<= '1'; State <= done 3; when done 3 => if (temp_send_next_key = '1' and key_cntr key_cntr <= '1'; State <= delay; else State <= done 3; end if; when others => null; end case; end if; end process PO; end Behavioral;

'0')

then

82

APPENDIXC
VARIABLE ROUNDS SCHEME TOP LEVEL (VHDL)

library IEEE; use IEEE.std_logic 1164.all; use IEEE.std_logic arith.all; use IEEE.std_logic signed.all; entity toplevel is port( Reset,Clk -- System Reset, System Clock
) ;

IN

std_logic

end entity toplevel; architecture struct of toplevel is signal signal signal signal signal signal signal signal signal signal signal signal signal signal connecting_ strobe tag_ response match found verified_outputY verified_outputZ encrypt_outputMSB_Y encrypt outputLSB Z sync new- rounds - value reader_encrypt_outputMSB Y reader_encrypt_outputLSB_Z reader_output ready final_decryptY final decryptZ std- logic; std- logic; std- logic; std- logic - vector(31 std- logic - vector(31 std- logic - vector(31 std- logic - vector(31 std- logic; std_logic_vector(63 std- logic - vector(31 std_logic_vector(31 std- logic; std_logic_vector(31 std- logic - vector(31

down to down to down to down to

0) 0) 0) 0)

; ; ; ;

down to 0) ; down to 0) ; down to 0) ; down to 0) ; down to 0) ;

component reader is generic( zero
) ;

Integer .- 0

(Reset: in std_logic; query: out std_logic; feedback : in std_logic; sync : in std_logic; match_found : out std_logic; encrypt_outputMSB_Y : in std_logic_vector(31 downto 0); encrypt_outputLSB_Z : in std_logic_vector(31 downto 0); verified_outputY : out std_logic_vector(31 downto 0); reader_encrypt_outputMSB_Y : out std_logic_vector(31 downto 0); reader_encrypt_outputLSB_Z : out std_logic_vector(31 downto 0); reader_output_ready: out std_logic; verified_outputZ out std_logic_vector(31 downto 0); elk : in std_logic); end component reader;

Port

83

component tag is generic( zero
) ;

Integer .- 0

Port(enable in std_logic; Reset: in std_logic; send_next_key : out std_logic; new rounds value : out std_logic_vector(63 downto 0); tag_encrypt outputMSB_Y : out std_logic_vector(31 downto 0); tag_encrypt_outputLSB_Z : out std_logic_vector(31 downto 0); final_decryptY : out std_logic_vector(31 downto 0); final decryptZ : out std_logic_vector(31 downto 0); reader_output_ready: in std_logic; reader_encrypt_outputMSB_Y : in std_logic vector(31 downto 0); reader_encrypt_outputLSB_Z : in std_logic vector(31 downto 0); output ready: out std_logic; sync: out std_logic; elk : in std_logic); end component tag; begin Ul: reader generic map( zero => 0 port map Clk Reset query feedback sync reader_encrypt outputMSB_Y reader_encrypt_outputLSB_Z reader_output ready match found encrypt_outputMSB_Y encrypt_outputLSB Z verified_outputY verified_outputZ
) ;

=> => => => => => => => => => => => =>

Clk, Reset, connecting_strobe, tag_response, sync, reader_encrypt outputMSB_Y, reader_encrypt_outputLSB_Z, reader_output ready, match_found, encrypt_outputMSB_Y, encrypt_outputLSB_Z, verified_outputY, verified_outputZ

U2: tag generic map( zero

=> 0

port map elk Reset random number enable output ready sync new- rounds - value reader_output_ready reader encrypt outputMSB Y

=> => => => => => => => =>

Clk, Reset, random number, connecting_strobe, tag_response, sync, new_rounds_value, reader_output_ready, reader_encrypt_outputMSB_Y,

84

reader_encrypt outputLSB Z final_decryptY final_decryptZ tag_encrypt outputMSB Y tag_encrypt_outputLSB_Z
) ;

=> => => => =>

reader_encrypt_outputLSB Z, final_decryptY, final_decryptZ, encrypt_outputMSB_Y, encrypt outputLSB Z

end architecture;

READER (Reader.vhd)

library IEEE; use IEEE.STD LOGIC 1164.ALL; use IEEE.STD LOGIC ARITH.ALL; use IEEE.STD LOGIC UNSIGNED.ALL; use IEEE.NUMERIC STD.ALL; use IEEE.MATH REAL.all; entity reader is generic( zero
) ;

Integer .- 0

Port (Reset: in std_logic; query: out std_logic; reader_output_ready: out std_logic; feedback : in std_logic; sync : in std_logic; match_found: out std_logic; encrypt_outputMSB_Y : in std logic_vector(31 downto 0); encrypt_outputLSB_Z : in std_logic_vector(31 downto 0); reader_encrypt_outputMSB_Y :out std_logic vector(31 downto 0); reader_encrypt outputLSB Z :out std_logic vector(31 downto 0); verified_outputY out std_logic_vector(31 downto 0); verified_outputZ out std_logic vector(31 downto 0); elk in std_logic); end reader; architecture Behavioral of reader is type Statetype is (INIT,INIT_delta,Statel,State3,random,initialize_Y_Z,new_state,check_fe edback,wait_state,delay,decode init,updatesum,updatesum_decode,fourbitL SY_d,Term7,fivebitRSY_d,Term8,Term9,part3,newZ_d,fourbitLSZ_d,TermlO,fi vebitRSZ_d,Termll,Term12,part4,newY_d,checkrounds_d,fourbitLSZ,Terml,fi vebitRSZ,Term2,Term3,partl,newY,fourbitLSY,Term4,fivebitRSY,Term5,Term6 ,part2,newZ,checkrounds,gen_new_rounds,final,done,do_nothing); signal State : Statetype; signal rdelta,delta : std_logic vector(31 downto 0) .x"9e3779b9"; signal rounds,rrounds std_logic_vector(7 downto 0); signal tempZ,tempZl,rtempZ,rtempZl: std_logic_vector(31 downto 0); signal tempY,tempYl,rtempY,rtempYl: std_logic_vector(31 downto 0); signal L,R,rL,rR : std_logic_vector(31 downto 0); signal sum,rsum std_logic_vector(31 downto 0); signal inv_sum,rinv_sum : std_logic vector(31 downto 0); signal rdelta copy std logic_vector(31 downto 0) := x"9e3779b9";

85

signal Y,rY : std_logic_vector(31 downto 0); signal Z,rZ : std_logic_vector(31 downto 0); signal lshiftedz,rlshiftedz std_logic_vector(31 downto 0); signal rshiftedz,rrshiftedz std_logic_vector(31 downto 0); signal lshiftedy,rlshiftedy std_logic_vector(31 downto 0); signal rshiftedy,rrshiftedy std_logic_vector(31 downto 0); signal rnax_rounds,rrnax rounds : std_logic_vector(31 downto 0); signal counter,counter1,rcounter : std_logic_vector(3 downto 0); signal rand_counter : std_logic_vector(15 downto 0); signal delay_counter,rdelay_counter: std_logic_vector(7 downto 0); signal rcounter1 : std_logic_vector(3 downto 0); signal rkO,rk1,rk2,rk3,kO,k1,k2,k3 : std_logic_vector(31 downto 0); signal rkey_ternp : std_logic_vector(127 downto 0) .x"00112233445566778899aabbccddeeff"; -signal storediD_Y : std_logic_vector (31 downto 0) .- x"01234567"; signal storediD_Z : std_logic_vector(31 downto 0) .- x"89abcdef"; signal wait_cntr : std_logic_vector(15 downto 0); signal delta counter,rdelta counter : std_logic vector(15 downto 0) ."0000000000000000"; signal delta_copy : std_logic_vector(31 downto 0); signal cnt,rcnt : integer range 0 to 31; signal ternp,rternp std_logic vector(63 downto 0) x"OOOOOOOOOOOOOOOO"; signal result,rresult : std_logic vector(63 downto 0) .x"OOOOOOOOOOOOOOOO"; signal Y_out,rY out : std_logic_vector(31 downto 0) := x"OOOOOOOO"; signal new_rounds : std_logic_vector(63 downto 0); signal saved_copy_randorn_nurnber : std_logic_vector(31 downto 0); signal new_saved_copy_randorn_nurnber : std_logic_vector(63 downto 0); signal t_verifiedY,t_verifiedZ: std_logic_vector(31 downto 0); signal rnatch_found_reg: std_logic; signal key_cntr : std_logic; signal readers_copyiDY std_logic vector (31 downto 0) x"01234567"; signal readers copyiDZ std_logic_vector(31 downto 0) x"89abcdef"; begin process(clk,Reset) variable int rand integer; variable seed1, seed2: positive .- 12; variable rand : real; begin if (Reset = I 1 I ) then query <= I 1 I ; rsurn sum rcounter rcounter1 rand counter rrounds rternpZ rternpZ1 rlshiftedz rL rR

<= <= <= <= <= <= <= <= <= <= <=

(others (others (others (others (others (others (others (others (others (others (others

=> => => => => => => => => => =>

I I I I I I I I I I I

0I ) ; 0I ) ; 0I ) ; 0I ) ; 0I ) ; OI ) ; OI ) i 0 I) ; 0I ) ; 0I ) ; 0I ) ;

86

rrshiftedz <= (others=> 1 0 1 ) ; rlshiftedy <= (others=> 1 0 1 ) ; wait cntr <= (others=> 1 0 1 ) ; rtempY <= (others=> 1 0 1 ) ; rtempYl <= (others=> 1 0 1 ) ; rrshiftedy <= (others=> 0 <= I 0 I ; match found verified_outputY <= (others=> 0 verified_outputZ <= (others=> 1 Q 1 ) ; <= 0 key_cntr rmax rounds <= x"00000032"; -- 50 rounds max rounds <= x"00000032"; inv sum <= (others=> 0 counter <= (others=> 0 counterl <= (others=> 0 wait cntr <= (others=> 0 delay_counter <= (others=> 1 0 1 ) ; rounds <= (others=> 1 0 1 ) ; Y <= (others=> 1 0 1 ) ; Z <= (others=> 1 0 1 ) ; tempZ <= (others=> 0 tempZl <= (others=> 0 tempY <= (others=> 1 0 1 ) ; tempYl <= (others=> 0 lshiftedz <= (others=> 1 0 1 ) ; rshiftedz <= (others=> 0 lshiftedy <= (others=> 0 rshiftedy <= (others=> 0 L <= (others=> 0 R <= (others=> 0 reader encrypt outputMSB_Y <= (others=> 1 0 1 ) ; reader_encrypt_outputLSB Z <= (others=> 1 0 1 ) ; reader output ready <= 1 0 1 ; match_found_reg <= 0
1 1 ); 1 1 ); I I; 1 1 1 1 ); ); ); ); 1 1 1 1 1 1 ); 1 1 ); 1 1 ); 1 1 1 1 1 1 1 1 ); ); ); ); 1 1 ); 1 1 ;

State <= check feedback; elsif(clk 1 event and elk= 1 1 1 ) then case (State) is when check feedback => if (feedback= 0 )then State <= random; elsif (feedback= 1 then State <= INIT delta; end if;
1 1 1 1 )

when random => if (rand_counter < "0000011010101000") then UNIFORM(seedl, seed2,rand); if (rand < 0.2) then saved_copy_random_number <= x"00000028"; else saved_copy_random_number <= x"00000028"; end if; rand_counter <= rand_counter + State <= random;
1

11

;

87

else State <= check_feedback; end if; when INIT delta => -- newdelta maxrounds*delta rY <= encrypt outputMSB Y; rZ <= encrypt outputLSB_Z; rent<= conv_integer(rdelta_counter); rtemp <= "00000000000000000000000000000000" & rdelta; State <= State1; when State1 => if(rdelta counter < 31) then rtemp <= rtemp(62 downto 0) & '0'; --'0' & temp( downto 1); if(rmax_rounds(conv_integer(rdelta_counter)) '1') then-- was max rounds(conv_integer rresult <= rresult + rtemp; end if; rdelta counter<= rdelta counter+ '1'; State <= State1; else State <= State3; end if; when State3 => rY_out <= rresult(31 downto 0); State <= delay; when delay => if (rdelay_counter < rmax rounds) then -- count to 32 (a random number) rdelay_counter <= rdelay_counter + 1; else State <= decode init; end if; ------------------ START DECODE HERE!! -----------------Term7 starts here when decode init => <= conv std_logic vector(conv_unsigned(zero,8),8); -- reset rounds rL <= conv_std_logic vector(conv_unsigned(zero,31),32); reset L rR <= conv_std_logic vector(conv_unsigned(zero,31),32); reset R <= rZ; rtempZ rtempZ1 <= rZ; rtempY <= rY; rtempY1 <= rY; rinv sum <= rY_out; --x"b8ab04e8"; -- for 40 rounds-x"8dde6e40";-- for 64 rounds --x"c6ef3720"; for 32 rounds rkO <= rkey_temp(127 downto 96); -- Split the 128-bit key into 4 sub-keys rrounds

88

rk1 rk2 rk3
-- y

-- z
State

<= rkey_temp(95 downto 64); <= rkey_temp(63 downto 32); <= rkey_temp(31 downto 0); <= encrypt_outputMSB_Y; --x"01234567"; <= encrypt outputLSB Z; <= updatesum_decode;--updatesum_decode;

when updatesum_decode => verified_outputZ <= rtempZ; verified_outputY <= rtempY; if (rrounds < rmax rounds) then rrounds <= rrounds + 1; State <= fourbitLSY d; else State <= done; end if; when fourbitLSY d => if (rcounter < "0100") then rtempY <= rtempY(30 downto 0) & '0'; rcounter <= rcounter + 1; State <= fourbitLSY_d; else rlshiftedy <= rtempY; rcounter <= conv std logic_vector(conv_unsigned(zero,4),4); State <= Term7; end if; when Term7 => rlshiftedy <= rlshiftedy + rk2; State <= fivebitRSY_d; when fivebitRSY d => if (rcounter1 < "0101") then rtempY1 <= '0' & rtempY1(31 downto 1); rcounter1 <= rcounter1 + 1; State <= fivebitRSY_d; else rrshiftedy <= rtempY1; rcounter1 <= conv std logic_vector(conv_unsigned(zero,4),4); -- Reset counter1 State <= TermS; end if; when TermS => rrshiftedy <= rrshiftedy + rk3; State <= Term9; when Term9 => rL <= rlshiftedy xor State <= part3; when part3 =>

-- Reset counter

(rY + rinv sum)

xor rrshiftedy;

89

rZ <= rZ - rL; State <= newZ d; when newZ - d => <= rZ; rtempZ <= rZ; rtempZl State <= fourbitLSZ d; when fourbitLSZ d => if (rcounter < "0100") then rtempZ <= rtempZ(30 downto 0) shift rcounter <= rcounter + 1; State <= fourbitLSZ d; else rlshiftedz <= rtempZ; rcounter <= conv std logic_vector(conv_unsigned(zero,4),4); State <= Term10; end if; when Term10 => rlshiftedz <= rlshiftedz + rkO; State <= fivebitRSZ d; when fivebitRSZ d => if (rcounterl < "0101") then rtempZ1 <= '0' & rtempZ1(31 downto 1); shift rcounter1 <= rcounterl + 1; State <= fivebitRSZ d; else rrshiftedz <= rtempZ1; rcounter1 <= conv std logic_vector(conv_unsigned(zero,4),4); State <= Term11; end if; when Terml1 => rrshiftedz <= rrshiftedz + rk1; State <= Term12; when Term12 => rR <= rlshiftedz xor (rz + rinv sum) State <= part4; when part4 => rY <= rY - rR; State <= newY_d; when newY d => rtempY <= rY; rtempY1 <= rY; State <= checkrounds d;

& '0';

-- 4 bit left

-- Reset Counter

-- 5 bit right

-- Reset counterl

xor rrshiftedz;

90

when checkrounds d => if (rrounds < rmax rounds) then rinv sum <= rinv sum - rdelta copy; State <= updatesum_decode; else verified outputY <= rY; verified_outputZ <= rZ; t verifiedZ <= rZ; t verifiedY <= rY; State <= done; end if;

-- how about this?

when done => if(t verifiedZ = readers_copyiDZ) then if (t_verifiedY = readers copyiDY) then match found<= 1 1 1 ; match_found_reg <= 1 1 1 ; State <= gen new_rounds; end if; else match found<= 1 0 1 ; end if; when gen_new rounds => if (match_found_reg = 1 1 1 ) then new rounds <= x"0000000000000045"; else State <= INIT delta; end if; when initialize y
y

State <= initialize_Y_Z;

z

z
tempZ tempZ1 tempY tempY1 lshiftedz rshiftedz lshiftedy rshiftedy counter counter1 sum rounds
L

R State <= INIT; when INIT =>

=> <= <= <= <= <= <= <= <= <= <= <= <= <= <= <= <=

storediD y xor new- rounds(63 down to 32) ; storediD z xor new- rounds(31 down to 0) ; (others => I 0 I ) ; (others => I 0 I ) i (others => I 0 I ) ; (others => I 0 I ) ; (others => I 0 I ) ; (others => I 0 I ) ; (others => I 0 I ) ; (others => I 0 I ) ; (others => I 0 I ) ; (others => I 0 I ) ; (others => I O I ) i (others => I 0 I ) ; (others => I 0 I ) ; (others => I 0 I ) ;

------------ Encode Routine -----------Y <= Y + ( (lshiftedz+kO) xor (z+sum) xor (rshiftedz+k1) ); -when updatesum => if (rounds < max rounds) then

91

sum rounds State else State end if;

<= sum + delta copy; <= rounds + 1; <= fourbitLSZ; <= done;

when fourbitLSZ => Z << 4 if (counter < "0100") then tempZ <= tempZ(30 downto 0) & '0'; -- 4bit lshift counter <= counter + 1; State <= fourbitLSZ; else lshiftedz <= tempZ; counter <=conv_std_logic vector(conv_unsigned(zero,4),4); State <= Term1; end if; when Term1 => lshiftedz State

<= lshiftedz + kO; <= fivebitRSZ;

-- z >> 5 when fivebitRSZ => if (counter1 < "0101") then tempZ1 <= '0' & tempZ1(31 downto 1); -- 5 bit rshift counter1 <= counter1 + 1; State <= fivebitRSZ; else rshiftedz <= tempZ1; counter1<=conv_std_logic_vector(conv unsigned(zero,4),4); State <= Term2; end if;
when Term2 => rshiftedz State when Term3 =>
L

<= rshiftedz + k1; <= Term3;

State when part1 => y <= y + L; State <= newY; when newY => tempY tempY1 State

<= lshiftedz xor (z + sum) xor rshiftedz; <= part1;

<= Y; <= Y; <= fourbitLSY;

-- y << 4 when fourbitLSY => if (counter < "0100") then tempY <= tempY(30 downto 0) & '0'; <= counter + 1; counter <= fourbitLSY; State else lshiftedy<= tempY;

92

counter State end if; when Term4 => lshiftedy State

<= conv_std_logic_vector(conv_unsigned(zero,4),4); <= Term4;

<= lshiftedy + k2; <= fivebitRSY;

when fivebitRSY => -- Y >> S if (counter1 < "0101") then tempY1 <= '0' & tempY1(31 downto 1); <= counter1 + 1; counter1 <= fivebitRSY; State else rshiftedy <= tempY1; counter1<=conv_std_logic vector(conv_unsigned(zero,4),4); State <= TermS; end if; when TermS => rshiftedy State when Term6 => R State when part2 =>

<= rshiftedy + k3; <= Term6;

<= lshiftedy xor (y + sum) xor rshiftedy; <= part2; <= z + R; <= newZ;

z
State when newZ => tempZ tempZ1 State

<= Z; <= Z; <= checkrounds;

when checkrounds => if (rounds < max rounds) then State <= updatesum; else reader encrypt outputMSB_Y <= Y; reader encrypt outputLSB Z <= Z; State <= wait state; end if; when wait state => if (wait cntr < "0000000000101000") then wait_cntr <= wait_cntr + '1'; reader_output ready<= '1'; State <= wait state; else reader_output ready<= '0'; wait cntr <= "0000000000000000"; State <= do nothing; end if;

93

when do_nothing => null; when others => null; end case; end if; end process; end Behavioral;

TAG

(Tag.vhd)

library IEEE; use IEEE.STD LOGIC 1164.ALL; use IEEE.STD_LOGIC_ARITH.ALL; use IEEE.STD_LOGIC_UNSIGNED.ALL; use IEEE.MATH_REAL.all; use IEEE.NUMERIC STD.ALL; package subtype subtype subtype subtype subtype types is bit t is std_logic; round t i s std_logic vector (4 word_t is std_logic_vector (31 text_t is std_logic_vector (63 key_t is std_logic vector (127 .- x"9e3779b9";

downto downto downto downto

0); 0); 0); 0);

constant delta: word t end types;

library IEEE; use IEEE.STD LOGIC 1164.ALL; use IEEE.STD_LOGIC_ARITH.ALL; use IEEE.STD_LOGIC UNSIGNED.ALL; use IEEE.NUMERIC_STD.ALL; use IEEE.MATH REAL.all; use work.types.all; entity tag is generic( zero
) ;

Integer := 0

Port

enable in std_logic; Reset in std_logic; tag_encrypt outputMSB_Y out std_logic vector(31 downto 0); tag_encrypt outputLSB Z out std_logic vector(31 downto 0); reader_output_ready in std_logic; reader_encrypt_outputMSB_Y : in std_logic_vector(31 downto 0); reader_encrypt outputLSB Z : in std_logic vector(31 downto 0); final decryptY out std_logic_vector(31 downto 0); final decryptZ out std_logic_vector(31 downto 0); new_rounds_value out std_logic_vector(63 downto 0); output ready out std_logic; sync out std_logic;

94

elk end tag;

in bitt);

architecture Behavioral of tag is type Statetype is (delta_done,done_l,done 2,done 3,INIT,INIT delta,check_feedback,INIT_de lta_d,Statel,State3,Statel d,State3 d,updatesurn,decode_init,updatesurn_d ecode,fourbitLSY_d,Terrn7,fivebitRSY_d,Terrn8,Terrn9,part3,newZ_d,fourbitL SZ_d,TerrnlO,fivebitRSZ_d,Terrnll,Terrnl2,part4,newY_d,checkrounds_d,fourb itLSZ,Terrnl,fivebitRSZ,Terrn2,Terrn3,partl,newY,fourbitLSY,Terrn4,fivebitR SY,Terrn5,Terrn6,part2,newZ,checkrounds,delay,wait_state,final,done); signal State : Statetype; signal surn,inv_surn : std_logic_vector(31 downto 0); signal counter,counterl : std_logic_vector(3 downto 0); signal wait_cntr,delta counter: std_logic_vector(15 downto 0); signal delay_counter :std_logic_vector(7 downto 0); signal rounds std_logic_vector(7 downto 0); signal kO,kl,k2,k3 std_logic_vector(31 downto 0); signal Y,Z std_logic_vector(31 downto 0); signal ternpZ,ternpZl std_logic_vector(31 downto 0); signal ternpY,ternpYl std_logic_vector(31 downto 0); signal lshiftedz,lshiftedy: std_logic_vector(31 downto 0); signal concat,concatl : std_logic_vector(31 downto 0); signal rshiftedz,rshiftedy: std_logic vector(31 downto 0); signal key_ternp : key_t := x"00112233445566778899aabbccddeeff"; signal delta copy : std_logic_vector(31 downto 0); signal L,R,rnax_rounds : std_logic_vector(31 downto 0); signal cnt,rcnt : integer range 0 to 31; signal temp, result : std_logic_vector(63 downto 0); signal rdelta std logic_vector(31 downto 0) .- x"9e3779b9"; signal rdelta counter std_logic_vector(15 downto 0); signal rrounds std_logic_vector(7 downto 0); signal rternpZ,rternpZl std_logic_vector(31 downto 0); signal rternpY,rternpYl std_logic_vector(31 downto 0); signal rL,rR,rY,rZ std_logic_vector(31 downto 0); signal rsurn,rinv_surn std_logic_vector(31 downto 0); signal rdelta_copy std_logic_vector(31 downto 0); signal rlshiftedz std_logic_vector(31 downto 0); signal rrshiftedz std_logic_vector(31 downto 0); signal rlshiftedy std_logic_vector(31 downto 0); signal rrshiftedy std_logic_vector(31 downto 0); signal rrnax rounds std_logic_vector(31 downto 0); signal rcounter std_logic_vector(3 downto 0); signal rand counter std_logic_vector(15 downto 0); signal rdelay_counter std_logic_vector(7 downto 0); signal rcounterl std_logic_vector(3 downto 0); signal rkO,rkl,rk2,rk3 std_logic_vector(31 downto 0); signal rkey temp std logic vector(127 downto 0) .x"00112233445566778899aabbccddeeff"; signal rternp std_logic_vector(63 downto 0); signal rresult std_logic_vector(63 downto 0); signal Y out, rY out std logic vector(31 downto 0); signal s~ved_copy_randorn_nurnber : std_logic_vector(31 downto 0) := x"00000028";

95

signal storediD_Y x"01234567"; signal storediD_Z x"89abcdef"; signal key_cntr begin PO: process(clk,Reset) begin if (Reset

std_logic vector(31 downto 0) std_logic vector(31 downto 0) std_logic;

.-

<= (others => I O I ) ; <= (others => I 0 I ) ; <= (others => I 0 I ) ; <= (others => I 0 I ) ; <= (others => I 0 I ) ; <= (others => I 0 I ) ; <= (others => I 0 I ) ; <= (others => I O I ) ; L <= (others => I 0 I ) ; R <= (others => I 0 I ) ; rshiftedz <= (others => I 0 I ) ; lshiftedy <= (others => I 0 I ) ; tempY <= (others => I O I ) ; tempYl <= (others => I 0 I ) ; concat <= (others => I O I ) ; concatl wait cntr <= (others=> 1 0 1 ) ; rshiftedy <= (others=> 1 0 1 ) ; tag_encrypt outputMSB_Y <= (others=> 1 0 1 ) ; tag encrypt_outputLSB Z <= (others=> 1 0 1 ) ; final_decryptY <= (others=> 1 0 1 ) ; final decryptZ <= (others=> 1 0 1 ) ; output ready <= 1 0 1 ; sync <= 1 0 1 ; key_cntr <= 1 0 1 ; rsum <= (others => I 0 I ) ; rresult <= (others => I 0 I ) ; <= (others => I 0 I ) ; rcounter <= (others => I O I ) ; rcounterl <= (others => I 0 I ) ; rand counter <= (others => I O I) ; rrounds <= (others => I 0 I); rtempZ <= (others => I O I ) ; rtempZl <= (others => I O I ) ; rlshiftedz <= (others => I 0 I ) ; rL <= (others => I O I ) ; rR <= (others => I 0 I ) ; rrshiftedz <= (others => I O I ) ; rlshiftedy <= (others => I 0 I ) ; wait cntr <= (others => I 0 I) ; rtempY <= (others => I 0 I ) ; rtempYl <= (others=> 1 0 1 ) ; rrshiftedy <= x"00000032"; -- 50 rounds rmax rounds <= x"00000032"; max rounds <= x"9e3779b9"; rdelta copy y <= storediD_Y; <= storediD_Z; z

1 1 ) then sum counter counterl rounds tempZ tempZl lshiftedz
1

96

State elsif(clk'event and elk case (State) is

<= INIT delta; '1' and enable= '1') then

when INIT delta => cnt <= conv_integer(delta counter); temp <= "00000000000000000000000000000000" & delta; State <= State1; when State1 => if(delta counter < 31) then temp<= temp(62 downto 0) & '0'; if(max_rounds(conv_integer(delta counter)) result <= result + temp; end if; delta counter<= delta counter+ '1'; State <= State1; else State <= State3; end if; when State3 => y out <= result(31 down to 0) ; State <= delta - done; when delta done => Y <= storediD Y; Z <= storediD_Z; State <= INIT; when INIT => delta copy kO k1 k2 k3 tempZ tempZ1 tempY tempY1 State

'1')

then

<= <= <= <= <= <= <= <= <= <=

delta; key _temp(127 down to 96) ; key - temp(95 down to 64) ; key - temp(63 down to 32) ; key_temp(31 down to 0) ; Z; Z; Y; Y; updatesum;

Encode Routine ---------------------Y <= Y + ( (lshiftedz+kO) xor (z+sum) xor (rshiftedz+k1)); -when updatesum => if (rounds < max rounds) then <= sum + delta copy; sum <= rounds + 1; rounds <= fourbitLSZ; State else <= done; State end if; z << 4 when fourbitLSZ => if (counter < "0100") then tempZ <= tempZ(30 downto 0) & '0'; -- 4bit lshift <= counter + 1; counter

----~---------------------

97

State else

<= fourbitLSZ;

lshiftedz <= tempZ; counter<=conv_std_logic_vector(conv_unsigned(zero,4),4); State <= Term1; end if; when Term1 => lshiftedz State

<= lshiftedz + kO; <= fivebitRSZ;

when fivebitRSZ => -- Z >> 5 if (counter1 < "0101") then tempZ1 <= '0' & tempZ1(31 downto 1) ;-- 5 bit rshift counter1 <= counter1 + 1; State <= fivebitRSZ; else rshiftedz <= tempZ1; counter1<=conv_std_logic vector(conv_unsigned(zero,4),4); State <= Term2; end if; when Term2 => rshiftedz State when Term3 => L State when part1 => y State when newY => tempY tempY1 State

<= rshiftedz + k1; <= Term3;

<= lshiftedz xor <= part1;

(z + sum)

xor rshiftedz;

<= y + L; <= newY;

<= Y; <= Y; <= fourbitLSY;

-- y << 4 when fourbitLSY => if (counter < "0100") then tempY <= tempY(30 downto 0) & '0'; counter <= counter + 1; <= fourbitLSY; State else lshiftedy <= tempY; counter <=conv_std_logic vector(conv_unsigned(zero,4),4); State <= Term4; end if;

when Term4 => lshiftedy State

<= lshiftedy + k2; <= fivebitRSY;

-- y >> 5 when fivebitRSY => if (counter1 < "0101") then tempY1 <= '0' & tempY1(31 downto 1);

98

counter1 State else

<= counter1 + 1; <= fivebitRSY;

rshiftedy <= tempY1; counter1<=conv_std_logic_vector(conv_unsigned(zero,4),4); State <= TermS; end if; when TermS => rshiftedy State when Term6 => R State when part2 =>

<= rshiftedy + k3; <= Term6;

<= lshiftedy xor (y + sum) <= part2; <= z + R; <= newZ;

xor rshiftedy;

z
State when newZ => tempZ tempZ1 State

<= Z; <= Z; <= checkrounds;

when checkrounds => if (rounds < max rounds) then <= updatesum; State else tag_encrypt outputMSB Y <= Y; tag_encrypt outputLSB Z <= Z; State <= wait state; end if; when wait state => if (wait cntr < "0000000000101000") then <=wait cntr + 1 1 1 ; wait cntr <= 111; output ready <= wait state; State else <= I 0 I; output ready <= 111; sync <= "0000000000000000"; wait cntr <= INIT delta d; State end if; when INIT delta d => rent rtemp State newdelta = maxrounds*delta <= conv_integer(rdelta_counter); <= "00000000000000000000000000000000" & rdelta; <= State1 d;

when State1 d => if(rdelta counter < 31) then rtemp <= rtemp(62 downto 0) & 1 0 1 if(rmax rounds(conv_integer(rdelta_counter)) rresult <= rresult + rtemp; end if; <= rdelta counter+ 1 1 1 ; rdelta counter

;
1

1

1

)

then

99

State else State end if;

<= State1 d; <= State3_d;

when State3 d => rY out<= rresult(31 downto 0); State <= delay; when delay => if (reader output ready= '1') then rY <= reader_encrypt outputMSB_Y; rZ <= reader_encrypt outputLSB Z; State <= decode init; else <= delay; State end if; --------------------------- Decode Routine --------------------------when decode init => <= conv_std_logic_vector(conv_unsigned(zero,8),8); rrounds <= conv_std_logic vector(conv_unsigned(zero,31),32); rL <= conv_std_logic vector(conv_unsigned(zero,31),32); rR <= rZ; rternpZ <= rZ; rternpZ1 <= rY; rternpY <= rY; rternpY1 <= rY_out; rinv sum <= rkey_ternp(127 downto 96); rkO <= rkey_ternp(95 downto 64); rk1 <= rkey_ternp(63 downto 32); rk2 <= rkey_ternp(31 downto 0); rk3 <= updatesurn_decode; State when updatesurn_decode => if (rrounds < rrnax rounds) then <= rrounds + 1; rrounds <= fourbitLSY d; State else <= done; State end if; when fourbitLSY d => if (rcounter < "0100") then rternpY <= rternpY(30 downto 0) & '0'; rcounter <= rcounter + 1; <= fourbitLSY_d; State else rlshiftedy <= rternpY; rcounter<=conv_std_logic vector(conv_unsigned(zero,4),4); State <= Terrn7; end if; when Terrn7 => rlshiftedy <= rlshiftedy + rk2; State <= fivebitRSY d; when fivebitRSY d =>

100

if (rcounter1 < "0101") then rtempY1 <= '0' & rtempY1(31 downto 1); rcounter1 <= rcounter1 + 1; State <= fivebitRSY d; else rrshiftedy<= rtempY1; rcounter1<=conv_std_logic_vector(conv unsigned(zero,4),4); State <= TermS; end if; when TermS => rrshiftedy <= rrshiftedy + rk3; State <= Term9; when Term9 => rL <= rlshiftedy xor (rY + rinv sum) xor rrshiftedy; State <= part3; when part3 => rZ <= rZ - rL; State <= newZ d; when newZ d => rtempZ <= rZ; rtempZ1 <= rZ; State <= fourbitLSZ d; when fourbitLSZ d => if (rcounter < "0100") then rtempZ <= rtempZ(30 downto 0) & '0';-- 4 bit left shift rcounter <= rcounter + 1; State <= fourbitLSZ d; else rlshiftedz <= rtempZ; rcounter<=conv std_logic_vector(conv_unsigned(zero,4),4); State <= Term10; end if; when Term10 => rlshiftedz <= rlshiftedz + rkO; State <= fivebitRSZ d; when fivebitRSZ d => if (rcounter1 < "0101") then -- 5 bit rshift rtempZ1 <= '0' & rtempZ1(31 downto 1); rcounter1 <= rcounter1 + 1; State <= fivebitRSZ d; else rrshiftedz <= rtempZ1; rcounter1<=conv_std_logic vector(conv_unsigned(zero,4),4); State <= Term11; end if; when Term11 => rrshiftedz <= rrshiftedz + rk1; State <= Term12;

101

when Term12 => rR <= rlshiftedz xor State <= part4; when part4 => rY <= rY - rR; State <= newY d;

(rz + rinv sum)

xor rrshiftedz;

when newY d => rtempY <= rY; rtempY1 <= rY; State <= checkrounds d; when checkrounds d => if (rrounds < rmax rounds) then rinv_sum <= rinv_sum - rdelta copy; State <= updatesum_decode; else final_decryptY <= rY; final_decryptZ <= rZ; State <= done 1; end if; when done 1 => <= rY xor storediD- Y; con cat <= rZ xor storediD- Z; concat1 State <= done 2; when done 2 => new rounds value <= concat & concat1; State <= done 3; when done 3 => null; when others => null; end case; end if; end process PO; end Behavioral;

102


