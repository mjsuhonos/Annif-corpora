SYNTHESIS OF CLASSICAL AND NON-CLASSICAL CMOS TRANSISTOR FAULT MODELS MAPPED TO GATE-LEVEL FOR RECONFIGURABLE HARDWARE-BASED FAULT INJECTION

By
R aha A bedi B achelor o f E lectrical Engineering A m ir K abir U niversity o f Technology T ehran, Iran, 2002

A thesis presented to R yerson U niversity in partial fulfillm ent o f the requirem ents for the degree o f M aster o f A pplied Science in the program o f Electrical and C om puter Engineering

Toronto, O ntario, Canada, 2005

© R aha A bedi 2005

PROPERTY OF

RVERSON im W igfiY UBR

UMI N u m b er: E C 5 2 9 9 8

All rig h ts re s e r v e d INFORMATION TO U SERS

T he quality of this reproduction is d ep en d en t upon the quality of the copy subm itted. Broken or indistinct print, colored or poor quality illustrations and photographs, print bleed-through, su b stan d ard m argins, and im proper alignm ent can adversely affect reproduction. In th e unlikely ev en t that the author did not send a com plete m anuscript and th ere are m issing p ag es, th e se will be noted. Also, if unauthorized copyright material had to be rem oved, a note will indicate the deletion.

UMI
UMI Microform EC 52998 Copyright 2008 by P ro Q u est LLC All rights reserv ed . This microform edition is protected ag ain st unauthorized copying under Title 17, United S ta te s Code.

P ro Q u est LLC 789 E a st E isenhow er Parkw ay P.O. Box 1346 Ann Arbor, Ml 48106-1346

ABSTRACT
Title o f Thesis: SYNTHESIS OF CLASSICAL AND NON-CLASSICAL CMOS TRANSISTOR FAULT MODELS MAPPED TO GATE-LEVEL FOR RECONFIGURABLE HARDWARE-BASED FAULT INJECTION

Raha Abedi, Master o f Applied Science, 2005

Thesis Directed By:

Dr. Reza Sedaghat, Electrical and Computer Engineering Department

One of the main goals of fault injection techniques is to evaluate the fault tolerance of a design. To have greater confidence in the fault tolerance of a system, an accurate fault model is essential. While more accurate than gate level, transistor level fault models cannot be synthesized into FPGA chips. Thus, transistor level faults must be mapped to the gate level to obtain both accuracy and synthesizability. Re-synthesizing a large system for fault injection is not cost effective when the number of faults and system complexity are high. Therefore, the system must be divided into partitions to reduce the re-synthesis time as faults are injected only into a portion of the system. However, the module-based partial reconfiguration complexity rises with an increase in the total number o f partitions in the system. An unbalanced partitioning methodology is introduced to reduce the total number o f partitions in a system while the size of the partitions where faults are to be injected remains small enough to achieve an acceptable re-synthesis time.

IV

Acknowledgment

I w ould lik e to thank Dr. Sedaghat and O PR -A L lab for their contribution and support. I w o u ld like to express m y gratitude to m y parents w ho have alw ays im m ensely encouraged and inspired me. They are m y great teachers in life. I am grateful to m y husband w ho guided and helped m e all the way. W ithout his support this w o rk w o u ld have not been accom plished.

Table of Contents

ABSTRACT...................................................................................................................................... iii Table o f Contents ................................................................................................................vi

List of Tables..................................................................................................................................viii List of Figures.................................................................................................................................... x Nomenclature................................................................................................................................... xii Chapter 1 Introduction......................................................................................................................1 1.1 Accurate Fault M odel.............................................................................................................2 1.2 FPGA-based Fault Injection.................................................................................................. 3 1.3 Summary o f Contributions..................................................................................................... 4 1.4 Thesis Outline....................................................................... 4 Chapter 2 Fault M odeling................................................................................................................ 6 2.1 Logical Fault Model................................................................................................................ 6 2.2 Logical Fault T ypes................................................................................................................ 7 2.2.1 Classical F aults................................................................................................................ 7 2.2.2 Non-classical Faults.........................................................................................................8 2.3 Transistor level fault m odel................................................................................................... 9 Chapter 3 Transistor Level to Gate Level Comprehensive Fault Model Mapping..................11 3.1 CMOS Physical Failures and defects.................................................................................11 3.2 Transistor to Gate Level Fault M apping.............................................................................12 3.2.1 Transistor Level Representation o f Primitive Gate Circuits..................................... 13 3.3 NORn Complete Fault List Pattern..................................................................................... 14 3.3.1 Input / Output Stuck-at Faults.......................................................................................15 3.3.2 Short Faults.....................................................................................................................16 3.3.3 Open Faults:................................................................................................................... 22 3.4 NANDn Complete Fault List Pattern.................................................................................. 25 3.5 Inverter Complete Fault List................................................................................................28 3.6 D-Latch Complete Fault L ist...............................................................................................29 3.6.1 Input / Output Stuck-at Faults...................................................................................... 30 3.6.2 Short Faults.................................................................................................................... 32 3.6.3 Open Faults.................................................................................................................... 34 3.7 D Flip-Flop Complete Fault List..........................................................................................35 3.7.1 Input / Output Stuck-at Faults...................................................................................... 36 3.7.2 Short Faults.................................................................................................................... 37

V I

3.7.3 O pen F a u lts............................................................................................................................... 40 C hapter 4 U ser-D efined V H D L Library o f T ransistor Level F aults.............................................41 4.1 V H D L Presentation o f Faulty G a te s ...........................................................................................41 4.2 C reating Faulty V H D L C om ponents A u to m atically .......................................... 44 4.3 D esigning a U ser-defined L ib ra ry .............................................................................................. 47 4.3.1 Existing L ib raries.....................................................................................................................47 4.3.2 Library m an ag em en t............................................................................................................... 47 4.3.3 A liasing the faulty com ponents to W O R K lib ra ry .........................................................48 C hapter 5 F ault Injection into C ircuit V H D L D e sc rip tio n ............................................................. 50 5.1 B ehavioural Feature o f H ardw are L anguages.......................................................................... 51 5.2 Structural Feature o f H ardw are L a n g u a g e s .............................................................................. 51 5.3 F ault Injection in V H D L D e sc rip tio n .........................................................................................53 C hapter 6 B inary Tree-based P artitioning M ethodology ................................................................. 56 6.1 B alanced V ersus U nbalanced P artitioning.................................................................................56 6.2 B inary Tree A pproach..................................................................................................................... 60 6.2.1 A nalyzing M erge and Sort A lg o rith m ............................................................................... 61 6.3 G enerating V H D L Full B inary T re e ........................................................................................... 64 C hapter 7 A utom ating the Synthesis P rocedure o f M odule-B ased D ynam ic Partial R econfiguration.............................................................................................................................................67 7.1 P artial R eco n fig u ratio n................................................................................................................... 68 7.2 M odular D e s ig n ................................................................................................................................69 7.2.1 M odular D esign E ntry and Synthesis P h a s e .................................................................... 70 7.2.2 M odular D esign Im plem entation P h a se .............................................................................71 7.3 A utom ating the Synthesis Procedure o f M odule-based Fault Injection M eth o d 73 7.4 E xperim ental R e su lts...................................................................................................................... 80 C hapter 8 C onclusion.................................................................................................................................87 8.1 R esearch C o n trib u tio n .................................................................................................................... 87 8.2 F uture W o rk .......................................................................................................................................88 A p p en d ices..................................................................................................................................................... 89 A ppendix A: O R n Com plete F ault L ist P a tte rn .............................................................................. 89 A ppendix B: A N D n F ault P a tte rn ....................................................................................................... 92 A ppendix C: B uffer F ault l i s t ...............................................................................................95

vu

List of Tables
Table 1; A Short between PMOS Drain and Power Table 2: Short between Two Inputs Table 3; Short between One Input and One PMOS Drain Table 4: When A is connected to A ( 7 < k< n-1 and Ki^ i) Table 5: When Di (1 < / < n-1) is shorted to Dn Table 6; h? Open Table 7; liN Open Table 8; NANDn Input/Output Stuck-at-faults Table 9: NANDn Short Faults Table 10: NANDn Open Faults Categories Table 11: NANDn Open Faults Table 12: Inverter Input / Output Stuck-at Faults Table 13: Inverter Short Faults Table 14: Inverter Open Faults Table 15: D-Latch Input / Output Stuck-at Faults Table 16: Short between Each Node and VCC or the Ground in D-latch Table 17: D-Latch Short Faults between Two Nodes Table IS: D-Latch Open Faults Table 19: Fault Free D Flip-Flop Table 20: D Flip-Flop Input / Output Stuck-at Faults Table 21 : D Flip-Flop Short Faults Table 22: D Flip-Flop Open Faults Table 23: Total Number o f Faults for Each Gate Table 24: Total Number o f Subroutines Table 25: S38417 Partition Size Table 26: ORn Input/Output Stuck-at-faults Table 27: ORn Short Faults

Vlll

T able 28: O R n O pen Faults C ategories T able 29: O R n O pen Faults T able 30: A N D n Input/O utput Stuck-at-faults T able 31 : A N D n Short Faults Table 32: A N D n O pen Faults C ategories Table 33: A N D n O pen Faults T able 34: B uffer Input/O utput Stuck-at-faults Table 35: B uffer Shore Faults T able 36: B uffer O pen Faults

IX

List of Figures
Figure 1: DRAM Cell Figure 2: 2-input NOR (gate-level) Figure 3: 2-input NOR (transistor-level) Figure 4; I2 Stuck-at-0 Fault of 3-input NOR Figure 5: A Short between Z)/and Ground Figure 6: NORn Transistor Level Figure 7: Faulty N 0R 3 Transistor Level Figure 8: NANDn Transistor Level Figure 9: CMOS Inverter Figure 10: T-gate Figure 11 : CMOS D-Latch Figure 12; D Flip-Flop Figure 13: NOR2_Short_Fault Synthesizable VHDL code Figure 14: NOR2_open_fault synthesizable VHDL code Figure 15: Perl Program Section for NORn Input stuck-at-1 Fault Figure 16: ClV.vhd Figure 17: C17.prj Figure 18: Half-adder Behavioural Model Figure 19: Half-adder Structural Model Figure 20: Faulty AND2 Instantiation Figure 21: Balanced Partitioning Figure 22: Balanced Partitioning Graph Figure 23: Unbalanced Partitioning Figure 24: Unbalanced Partitioning Graph Figure 25: Full Binary Tree (Depth level = 4) Figure 26: The Construction of a Recursion Tree for the Recurrence T(n) = 2T(n/2) + cn Figure 27: The Flow of Binary Tree Based Partitioning and Modification of the VHDL Code for Fault Injection

X

Figure 28; M odular D esign Entry and Synthesis F low Figure 29: C ircuit N am e A ssignm ent Figure 30: S1238 Step 2 Figure 31: V erifying the Entered B ranch L ength F igure 32: V erifying the E ntered B ranch C haracters Figure 33: M aking a Partition D irectory inside the C ircuit D irectory F igure 34: C opy a P artition V H D L C ode to Its D irectory Figure 35: A n Exam ple o f Fault List for 8123 8 F igure 36: 81238 C ircuit D irectory Figure 37: 8 1 2 3 8_Partition LLLL X 8 T Script File F igure 38: 81238_Partition_L LL L D irectory Files Figure 39: Executing the Script File (xst.scr) Figure 40: Size o f C ircuits Figure 41: Full B inary Tree D epth Level o f C ircuits Figure 42: R e-synthesis T im e o f the F aulty P artition Figure 43: Benchm arks Synthesis Tim e F igure 44: 838417 P artition synthesis tim e F igure 45: Partition Selection o f a Full B inary T ree (D epth level = 9) F igure 46: U nbalanced V ersus B alanced Partitioning F igure 47: O R n T ransistor Level F igure 48: A N D n T ransistor Level F igure 49: B uffer T ransistor Level

XI

Nomenclature
c C

Constant Clock Drain o f the i* CMOS transistor Ground Total number o f gates Integers i*'' input of a gate Input of the i^'' PMOS transistor Input of the i"' NMOS transistor Not Clock Total number of partitions
i*'' partition

Di
G

Gt i, j, k, n li lip
liN

nC N ?i

Pf
Qi

Partition with injected faults i* * ' CMOS transistor State o fQ at timet-1 Source of the i*'' CMOS transistor Stuck-on Size o f the i* partition T-gate number i Logic value unknown high impedance XOR For all values o f i Zero or One Cost function

Q" Si
S-on S(?i)

Tj
V

X Z

© Vi <0 11> Y

XU

Chapter 1 Introduction
A s system s becom e m ore com plex it becom es increasingly difficult to provide com prehensive fault testing to determ ine th e validity o f a system. H ence, faults can rem ain in a system and m anifest them selves as errors. Furtherm ore, faults m ay be introduced into a hardw are system from external sources such as electrom agnetic interference. N ot only can com ponents w ithin a system fail, no transistor w ill function forever. These faults can ultim ately cause a system to fail. The ability o f a system to function in the presence o f faults, i.e. to becom e fault tolerant, is a rapidly grow ing area o f research. A fault tolerant system has th e ability to respond gracefully to an unexpected hardw are or softw are failure. The need

for fault to lerant system s is driven by various factors such as extrem ely high reliability and availability needs, reduced life-cycle costs, and long-life requirem ents. M ost real-tim e system s m ust function w ith very high availability even under hardw are fault conditions. To design a fault tolerant system m any fault injection techniques to evaluate the dependability o f the system have been proposed. In all o f these techniques single or m ultiple faults are intentionally inserted into the system to study the behaviour o f the system in the presence o f faults. Physical failures o r defects in a circuit m ay cause faulty circuit behaviour and thus reduce the fault tolerance rate o f the system. To evaluate the fault tolerance o f a system , an accurate fault m odel is required. N ext, an approach to inject each fault into the system is essential and finally, an adequate test pattern to determ ine i f the fault has changed the behaviour o f the

circuit. We will focus mainly on defining an accurate fault model and a method of injecting faults into a system.

1.1 Accurate Fault Model
More accurate fault models are usually defined below the gate level. The major disadvantage of using a transistor level (low level) fault model is the performanee degradation o f fault simulation, fault emulation and test pattern generation [3]. Therefore, there is a critical need to map the transistor level fault model onto the gate level without any performance degradation, while at the same time obtaining an accurate fault model. For many years the only practical approach has been based on the stuck-at fault model. However, problems arise in CMOS LSI and VLSI circuits. The stuck at fault model is not sufficient for systems that require high reliability or high availability such as pacemakers, ABS (anti-lock braking systems) in automobiles, or air traffic control. There are other types o f physieal failures and defects, i.e. short or open faults that disturb system performance. There are many studies which model physical failure and defect in CMOS circuits. In [32, 33, and 34], the main focus is on modeling short faults between a gate and a source of one CMOS transistor in a circuit. A methodology to obtain a minimal set of faults is proposed in [35]. This methodology is based upon theoretical basis allowing the determination of the equivalence and dominance of non-classical CMOS faults, hi [5, 36] short, open and stuck-at faults are presented for CMOS circuits based on simulation results and thoroughly cover open and stuck-at faults. However, the fault model they present only considers short faults for one transistor in the circuit at a time, such as a short between a gate and a drain o f the same transistor. However, in [3] all the possible short faults are taken into account in the fault model, including connecting two nodes from different CMOS transistors. In this research, all shorts that could possibly occur among transistors (e.g. a short between the gate of one transistor and the drain of another transistor) in the circuit in addition to all possible stuck-at and open faults are considered. By applying a complete version of accurate fault models [3, 5] to each gate to generate a complete fault list, it is revealed that the fault list for each type of primitive gate follows a specific pattern regardless o f its number of inputs. The number of gate inputs can be used to calculate the total number o f possible faults at the transistor level using general formulas presented in this research.

1.2 FPGA-based Fault Injection
A fter generating a fault m odel, softw are sim ulation and hardw are em ulation are the m ain techniques that researchers follow to inject faults into a system . Fault sim ulation provides a high degree o f controllability [37, 38] and design m istakes in the fault-tolerant system can be detected and corrected at a very early stage in the design process [38]. H ow ever, the m ain draw back related to fault sim ulation is that it is tim e-consum ing w hen m any faults have to be injected in a com plex circuit [39, 16]. For fault em ulation a prototype o f the system is needed. A n advantage o f prototyping is the possibility to perform "in-system " em ulation before any m anufacturing. R econfigurable devices such as FPG A s are appropriate to im plem ent and test the prototype. To cope w ith the tim e lim itation im posed by sim ulations, it has been proposed to take advantage o f hardw are prototyping using FPG A -based hardw are em ulators [40]. A nother advantage o f em ulation is to allow the designer to study the actual behaviour o f the system in the application environm ent, taking into account real-tim e interactions o f various hardw are and softw are com ponents [15]. FPG A -based fault injection has been an area o f increased research. For exam ple, [41, 42] discuss injecting faults through fault injectors for stuck-at faults and [43] applying a FPGAbased fault injection m ethod through fault injection chain hardw are. A nother m ethod is to inject faults by using scan-chain hardw are for injecting bit-flip faults into flip-flop o f the target system [44, 39, and 26]. In [21, 45, and 46] FPG A -based em ulators have been used to only inject stuck-at faults for test pattern generation purposes w ithout evaluating the faulttolerance o f the system . U sing run-tim e reconfiguration (RTR) for fault injection is another approach proposed by [47] to save tim e by reconfiguring only a few resources o f the device. H ow ever, because this approach m odifies bitstream s it is not capable o f accessing the drain o f specific C M O S transistor in the circuit to m ake it an open node or to short it to the others nodes o f the circuit. This is due to the fact that bitstram s represent the Look U p Table (LU T) values o f the circuit and not the gate level description. During the synthesis som e gates m ay be m apped into other gates due to optim ization. Therefore, there is no possibility to access th e transistor level description o f those gates to inject faults. The FPG A -based fault injection into sw itch-level o f a m odel w hich is in abstraction level betw een gate level and transistor level is discussed in [48].

When an emulator is used, the initial VHDL description must be synthesizable. It is apparent that a transistor level fault model cannot be synthesized into FPGA chips. Therefore, the fault model mapping from transistor level to gate level has a critical role in our study for injecting transistor level faults into the FPGA. In this work, first the transistor fault model is mapped to gate level fault model. Next, a method is described to inject this fault model into the FPGA by considering the advantages o f module-based dynamic partial reconfiguration.

1.3 Summary of Contributions
This thesis contributes to the following areas: · Generating a complete fault list of primary gates (NOR, NAND, OR, AND, Inverter, Buffer, D-Latch, D Flip-Flop). · · Presenting a fault pattern for each type of gate regardless of its number o f inputs. Extracting a general formula for each type of gate to calculate the total number of faults according to the gate number of inputs. · Generating automatically a faulty component library that represents the transistor level faults at a gate level description. · Presenting a methodology to partition a high level (e.g. VHDL) description of a circuit to reduce the synthesis time as well as module-based circuit design complexity. · · Generating faulty VHDL partitions exhaustively and providing a data base. Automate the synthesis process of faulty and fault free partitions based on a desired fault list and modular design regulations.

1.4 Thesis Outline
The necessity o f fault modeling as well as different fault classifications are discussed in Chapter 2. Chapter 3 presents a complete transistor to gate level fault mapping o f primary gates and their related fault pattern as well as general formulas to calculate the total number o f faults. Generating and automating a user-defined library based on the fault patterns from Chapter 3, is described in Chapter 4. In Chapter 5 the behavioural and structural VHDL description features are discussed and an appropriate approach to inject faults in the VHDL

description o f a circuit is introduced. A m ethodology o f partitioning a system to reduce the synthesis tim e and system m odule-based com plexity is discussed in C hapter 6. The autom ation o f synthesis procedure based on m odular design param eters and experim ental results are presented in C hapter 7. C hapter 8 is dedicated to conclusions and intended future w orks.

Chapter 2 Fault Modeling
An instance o f an incorrect operation of the system being tested is referred to as an observed error. Causes of observed errors may be design errors, fabrication errors, fabrication defects, or physical failures. Design errors can be detected and corrected at an early stage of the design process by simulating the design. Fabrication defects are not directly attributable to human error; rather, they result from an imperfect manufacturing process. Physical failures occur during the lifetime of a system due to component wear-out and/or environmental factors. In general. Physical faults do not allow a direct mathematical treatment of testing and diagnosis. The solution is to deal with logical faults, which are a convenient representation of the effect o f physical faults on the operation of the system. The basic assumptions regarding the nature o f logical faults are referred to as a fault model [1].

2.1 Logical Fault Model
Logical faults represent the effect of physical faults on the behaviour of the modeled system. Given a logical fault and model of a system, we should be able in principle to determine the logic function o f the system in the presence of the fault. Thus, fault modeling is closely related to the type o f modeling used for the system. The advantages of modeling physical faults as logical faults can be described as follows [1]: · The problem o f fault analysis becomes a logical rather than a physical problem.

·

The com plexity is greatly reduced since m any different physical faults m ay be m odeled by the sam e logical fault.

·

Som e logical fault m odels are technology-independent in the sense that the sam e fault m odel is applicable to m any technologies.

·

Tests derived for logical faults m ay be used for physical faults w hose effect on circuit behaviour is not com pletely understood or is too com plex to be analyzed.

A logical fault m odel can be defined in different levels o f circuit descriptions. Transistor, gate, and RTL level o f circuit descriptions, each have their ow n logical fault m odels. As m entioned, these fault m odels are related to the type o f m odeling used for the circuit.

2.2 Logical Fault Types
Faults can be categorized into tw o m ajor groups o f classical and non-classical faults. 2.2.1 C lassical F a u lts The classical faults can be categorized as follows [1 ,2 ]:

·

Single (line) stuck-at fault: The given line has a constant value (0/1) independent o f the other signal values in the circuit. In m any technologies, a short betw een ground or pow er and a signal line can m ake the signal rem ain at a fixed voltage level. The corresponding logical faults consist o f the signal being stuck at a fixed logic value v (v = 0/1), and is denoted by stuck-at-v.

·

M ultiple stuck fault: Several signal stuck-at faults occur sim ultaneously. F or a circuit w ith k lines, i.e., k input signals and input/output elem ents, there are 2 k single stuck faults, and 3^-1 m ultiple stuck faults. For a large com binational circuit w ith m ultiple outputs, alm ost all m ultiple faults can be covered by test patterns derived for single faults.

·

B ridging fault: Tw o or m ore norm ally distinct points (lines) are shorted together. A short betw een tw o signal lines usually creates a new logic function. The logical fault representing such a short is referred to as a bridging fault. Input bridging can form a w ired logic or voting m odel.

Input-to-output bridging can introduce feedback or cause oscillation or latching. 2.2.2 Non-classical Faults In general, non-classical faults are categorized as follows [2, 3]:

·

Pattern-sensitive fault: The presence of a faulty signal depends on signal values o f nearby points (most common in DRAMs).

0 0 0

0 d a

0 b 0

a=b=0 a= b=l

d=0 d= 1

Figure 1: DRAM Cell Coupling fault: Pattern sensitivity between a pair of cells. Crosspoint fault: A PLA (Programmable Logic A rra y in h e re n tly has a device (diode or transistor) at every crosspoint in the (AND and OR) arrays, even if not used. The connection of each diode is programmed to realize the desired logic. A crosspoint fault can be caused by an extra or missing device. Transistor stuck-open fault: Transistor (switch) is always off, not controllable by gate input. This fault can turn the circuit into a sequential one. This type of fault is more difficult to test and needs a sequence of at least 2 tests to detect a single fault. Transistor stuck-open fault is unique to CMOS circuits. Transistor stuck-on fault: Transistor (switch) is always on, not controllable by gate input. This kind of fault can be caused by a permanently conducting transistor and also occurs in CMOS circuits. (Line) break (stuck-open) fault: An open wire.
' PLA is an array o f gates having interconnections that can be programmed to perform a specific logical function.

·

(Line stuck) short fault: A short is form ed by connecting points not intended to be connected.

·

D elay fault: Propagation (transition) delays along a path (gate) that fall outside the desired lim its are referred to as either path delay faults or gate delay faults.

·

Function conversion fault: D efects inside a CM OS gate m ay result in an incorrect function o f the gate. If there is a short betw een input and output o f an inverter the gate is no longer inverting. Furtherm ore, conversion o f an A N D into a N A N D , O R into N O R etc. is possible.

·

C onditional fault: A conditional fault is defined as a fault w hich can only be detected i f one or m ore conditions are satisfied. Each condition consists o f a fixed logical value (0 or 1) at a specified mode. This kind o f fault is defined for CM OS and it is sim ilar to pattern-sensitive fault o f DRAM s.

Stuck-open and stuck-on faults are transistor level faults; stuck-at, bridging, delay faults are gate level faults; pattem -sensitivity, crosspoint faults are function level faults. M ost o f th e non-classical faults can be m apped onto classical stuck-at faults [4], bridging faults and transition faults. The transition fault is based on the assum ption that a transition at a gate never occurs in a com binational circuit. In a sequential circuit, transition does not occur w ithin a clock cycle.

2.3 Transistor level fault model
L e t's see h o w a transistor fault can affect the behaviour o f the circuit. In the presence o f transistor faults o r an interconnection w iring faults circuit will not function correctly. M any things can go w rong, leading to a variety o f faults. A transistor switch can break so that it is either perm anently closed or open. A wire in the circuit can be shorted to V C C or to ground, or it can sim ply be broken. There can be an unw anted connection betw een tw o w ires. A logic gate m ay generate a w rong output signal because o f a fault in the circuitry that im plem ents the gate. CM O S logic circuits present som e special problem s in term s o f faulty behaviour. T he transistors m ay fail in a perm anently open or shorted (closed) state. M any such failures m anifest them selves as stuck-at faults. H owever, som e produce entirely different behaviour.

9

For example, transistors that fail in the shorted state may cause a continuous flow of current from VCC to ground, which can create an intermediate output voltage that may not be determined as either logie 0 or 1. Transistors failing in the open state may lead to conditions where the output capacitor retains its charge level because the switch that is supposed to discharge it is broken. The effect is that a combinational CMOS circuit starts behaving as a sequential circuit [7]. As CMOS has emerged as an important technology for VLSI, testing of large CMOS networks has become a crucial issue. The classical stuck-at fault model assumptions are not sufficient for modeling certain faults that are specific to a CMOS-based VLSI technology. This applies particularly when systems with a high reliability or high availability such as space applications are considered. Depending on the teclinology, typical physical defects as such as CMOS stuck-open faults may not be covered by a stuck test set. Therefore, new fault models have been introduced at different description levels to increase the accuracy of fault modeling. Transistor level fault model is more accurate than gate level fault model. However, its fault simulation, fault emulation, and test pattern generation are degraded in comparison to the gate level. In order to maintain the efficiency resulting from gate level modeling while the accuracy of the fault model is increased, transistor to gate level fault mapping is required. Next chapter is directed towards a mapping of classical and non-classical transistor level faults to the gate level.

10

Chapter 3 Transistor Level to Gate Level Comprehensive Fault Model Mapping
In order to have greater confidence in the fault tolerance o f a system m ore accurate fault m odels are needed. A n accurate fault m odel cannot be attained unless all faults in the transistor level (low level) are considered thoroughly. H owever, these transistor-level faults m ust be m apped onto gate level (higher level) so that the efficiency o f fault sim ulation, fault em ulation and test pattern generation on the gate level is not sacrificed. This chapter considers single physical failures for static CM OS prim itive gates and show s their effects in th e o utput behaviour in term s o f gate level faults. W e have found a specific fault pattern for each ty p e o f gate regardless o f its num ber o f inputs is proposed. A ll kinds o f faults from stuck-at to short and open faults have been considered in these patterns. A general form ula to calculate the total num ber o f faults for each type o f gate is extracted from these patterns.

3.1 CM OS Physical Failures and defects
Failures in CM OS circuits can be classified into shorts, opens, and circuit degradation. Shorts are due to oxide breakdow n and m etal bridging, and are caused by static discharge and tim e-dependent defects, w hile m etallization problem s caused by electro-m igration or electro m echanical corrosion can produce shorts and opens. D egradations include threshold voltage shifts caused by ionic contam ination, surface-charge spreading, and the trapping o f hot

11

electrons in the gate oxide. However, these degradations, if permanent, will consequently be translated into classical type o f faults at the input(s) and/or output(s) [5]. It should be noted that 75 percent of the cases are shorts and opens, while the rest could be considered unobservable or insignificant [6]. Hence, physical faults of CMOS cells have been divided into two groups, namely shorts and opens. For example, for any two-input CMOS gate, the following faults are considered: 1) Short Faults: · · · · · · Short between gate and source in both p-channels; Short between gate and drain in both p-chaimels; Short between source and drain in both p-channels; Short between gate and source in both n-channels; Short between gate and drain in both n-channels; Short between source and drain in both n-channels.

2) Open (Floating) Faults: · · · Open gate in both p-channels and n-channels; Open source in both p-charmels and n-channels; Open drain in both p-charmels and n-channels.

3) Input / Output Stuck-at Faults: · · · Input #1 stuck-at-0 or 1; Input #2 stuck-at-0 or 1; Output stuck-at-0 or 1.

However, it should be noted that some faults are redundant, which consequently reduces the number o f faults.

3.2 Transistor to Gate Level Fault Mapping
The complexity o f integrated circuits requires that a practical approach to fault simulation, fault emulation, and test pattern generation be based on a higher level o f circuit description. The adequate fault model depends on the desired accuracy for modeling the actual defects and the complexity of the circuit description. For years the only practical approach has been based on the classical stuck-at fault model and a gate level description o f

12

the circuit. T h e m ain reason is that fault sim ulators and fault em ulators can handle the gate level descriptions efficiently and in a tim ely m anner. H ow ever, the conventional stuck-at fault assum ptions are not sufficient for m odeling certain faults that are specific to som e V LSI technology, especially, w hen certain physical failures such as shorts betw een tw o nodes or open nodes occur in C M O S technology [3]. The g eneral idea o f transistor to gate level fault m apping is to com bine the accuracy o f m odeling faults at the transistor level w ith the efficiency o f fault sim ulation, em ulation, and test pattern generation based on gate level description o f the circuit. T he starting point in this research is to consider all the faults that can possibly occur in a transistor level description o f th e standard cell library [3]. The m ain focus o f this study will be on static C M O S library. In this study N A N D , N O R , A N D , OR, Inverter, Buffer, D -lateh and D flip-flop cells are considered. F o r each cell the effeet o f each transistor level fault on the gate level fault m odel is determ ined using the results given in [3, 5]. By applying an accurate fault m odels to each gate (cell) to generate a com plete fault list in this w ork, w e have found that the fault list for each ty p e o f prim itiv e gate follow s a specific pattern regardless o f the num ber o f inputs. The n u m b er o f gate inputs can be used to calculate the total num ber o f possible faults at the tra n sisto r level using general form ulas w hich w ill be described later. 3.2.1 T ran sistor L evel R epresentation o f Prim itive G ate C ircuits T he accuracy such as internal nodes values cannot be reached b y ju s t considering a circuit at the gate level. Figure 2 show s a gate level N O R circuit. A t the gate level, faults can only be injected or diagnosed on input and output pins. T here is no w ay to access th e gate internally to inject m ore faults, nor to observe its fau lt tolerance or d iagnose th e fault after its detection. T herefore, w e m ust use the transistor level o f p rim itiv e gates in order to cover m ore faults and obtain a m ore accurate fault m odel. F ig u re 3 show s the 2 -input N O R (N O R 2) transistor level circuit.

o

Figure 2: 2-input NO R (gate-level)

13

Injecting a fault in a CMOS gate may result in different output values according to different input combinations. The relationship between inputs and the faulty output shows the faulty function o f the CMOS gate. For example, if 7/ is shorted to Di the output o f N 0R 2 gate in Figure 3 will be: 0 h
=

f

72 = 0

else

The relationship between inputs and the faulty output will be thoroughly discussed in following sections for all possible faults in the CMOS gates.

Qs

l2 N

Û4

Figure 3: 2-input NOR (transistor-level)

These relations between inputs and output follow a specific pattern regardless of gate input numbers for each gate. We will discuss and explain an example o f this pattern for a NOR gate with n inputs in the next section.

3.3 NORn Complete Fault List Pattern
Figure 6 shows a CMOS NOR gate with n inputs, n is an integer where {n > 2). 7, symbolizes one o f the NOR i^ * ' input where ( l < i < n).

14

liN an d Ijp are th e inputs o f connected to

N M O S and PM O S transistors respectively. They are both

F o r stuck-at-faults and short faults / , , Ijp and 7,^ function as the sam e node.

Thus, th ey ' will be generally labeled as /,. H ow ever, in the open fault case, they act as separate nodes. T he th ree groups o f faults (stuck-at, short, and open) and their effects on the output o f N O R n are represented as follow s w ith respect to the above assum ptions: 3.3.1 In p u t / O utput Stuck-at Faults N O R n is faulty i f either 7, or O is stuck-at-0 or 1. W hen 7, is stu ck -at-1 it turns its N M O S on thus, the output is connected to ground and results in low output (O = "0"). In contrast, w h en 7, is stuck-at-0 it turns its PM O S on and N M O S off. Therefore, the fau lty N O R n gate still acts as a N O R gate but w ithout 7, input. The output is the result o f N O R (Ii, h li-i, li+n---. In)- F igure 4 illustrates I 2 stuck-at-0 faults. In this case

Q 2 is sw itched on and Q 5 is sw itched off. Therefore, the output is the result o f N O R w ith only tw o inputs o f 7/ and I3 (N O R (Ii,l 3 )). I f (ji -- 2) and one o f the tw o inputs is stuck-at-0 then the output w ill be the N O R o f th e rem aining non-faulty input w hich acts as an inverter. W hen the output is stuckat-0 o r 1, it w ill no longer be dependent on inputs. The to tal n um ber o f input/output stuck-at faults for N O R n gate is (2n+2). vcc I' - 4 ^ ^
D,

1 2 ----

Q2

Ü 2
Q3 1 3--- c|[c
Da

--

i [~Q<

12--

| [~ q 5

13--

ir ^

Figure 4 : 12 Stuck-at-0 Fault o f 3-input N O R

15

3.3.2 Short Faults The many types o f short faults that may occur in a NORn circuit are categorized as follows: 1) Short between a PMOS drain and ground or power: As far as output stuck-at-0 and stuck-at-1 are concerned, there is no need to analyze the Z),, connection to ground and power due to the similarities in results. For any i
(1

< i < n- 1 ), Di can be shorted to ground or power thus, the total number o f

faults for this category will be 2 (n-1 ). If Di is shorted to ground, noted as (D, G), the output O will always be low.

When the circuit is fault free by applying low inputs the output is connected to VCC through conducting PMOS transistors. Given the presence of a short fault between Z>, and ground, the output will be connected to ground through the PMOS transistors located below the node £), and the short between Z), and ground. This will result in a low value for the output o f this faulty circuit. For the rest of the input combinations, where at least one input with a high value exists, i.e. at least one NMOS transistor is conducting; the output is forced to low again. Figure 5 illustrates Dj G fault in

N 0R 3 gate. When I 2 and I 3 are low Q2 and Q3 are switched on and the output is connected to ground through Q2 , Qs, and Di.

VCC

Di

1 2

c|[Q2 Ü 2

1 3 --c|[Q3
Ü3

Figure 5: A Short between D/ and Ground

16

I f Dj is connected to VCC, (D,

VCC), the circuit w ill behave differently w ith

regard to its inputs. W hen all inputs are low (Ij=0, 1<J< n) the output w ill be high. A s soon as one o f the inputs, connected to the PM O S transistor located above Di, goes hig h it sw itches one N M O S transistor on and the related PM O S transistor off. In this case, a path is established betw een ground and VCC, through Z ),, output and N M O S transistor. This condition takes the output to an uncertain value betw een 0 v o lt and VCC. T he output is called stuck-on in this situation [5]. For the rest o f the input com binations the output w ill be low w hile Z), is shorted to VCC. A ll the conditions are sum m arized in Table 1. In fact T able 1 show s the output pattern w ith regard to input conditions w hen any d rain o f the n -input N O R gate is shorted to
VCC.

In Table 1, Ij = 0
Ij

V

1< j< n
(V

indicates all inputs from Z/ to Z,, are low . In this case the output is high.

= 0

i+ l<

j < n) denotes all inputs o f PM O S transistors below the shorted drain (Z),) are low and
(Il

II h ||...|| li) =1 indieates at least one o f the PM O S transistor inputs above the

shorted d rain is high. In this case the output has an unknow n value betw een 0 and V C C v o lt (stuck-on).

VCC

Dn+1

Sn+1

Sn+i

Figure 6: NO Rn Transistor Level

17

Shoi I f lults
li= 0 Di <--> VCC
&

Input conditions
V l < i < n (m eans all inputs from 7/ to 1,, are low )

1
S-on (Stuck-on)

lj = 0 ( V i + l < j < n )

(I. II b II...11 0 = 1
For all other input com binations

0

Table 1: A Short between PMOS Drain and Power 2) Short between two inputs: (/; h where l < k < n and k i)

Assume /, is shorted to /*. The output is unknown when these two inputs have opposite values while the rest of the inputs are low. The circuit output can have a high or low value depending on the input combinations. The faulty output pattern for this kind o f fault is shown in Table 2. In Table 2, Ij = 0
V

(1< j< n and j ^ i, j

k) denotes all inputs except /, and 4 are

low and h © Ik =1 indicates /, and 1^ have different values. In this case the output is unknown. The total number of short faults that connect two inputs undesirably can be computed from equation (3.3.2.1). {n - l ) + (« - 2 ) + ... + ( K - ( « - l ) ) = ^ ( n - y ) y = ! (3.3.2.1)

g h o r t faults

Input conditions
l i = 0 V 1<1 < n

Faulty output (O) 1
X

li < r ^ Ik
( l < k < n and k 7 i)

lj= 0 V ( l < j < n a n d j 7 i , j y k ) & li © lk=l For all other input com binations

0

Table 2: Short between Two Inputs 3) Short between one input and one PMOS drain: (7, ^ - ^ D k where 1 < k < n ) The total number o f faults in this category is n^. There are two cases for determining the output value given this type o f fault. The first case occurs when l\ is

18

shorted to a drain o f any PM O S transistor located below it (7, <--> Dk w here i< k< n ). T he second case considered is w hen /, is shorted to the drain o f one o f the PM O S transistors above it (7, Dk w here l < k < i - 1 ).

In the first case th e output is equal to 7, if all the PM O S inputs located below the Dk are low. Thus, the output is connected to 7, through conducting PM O S transistors an d th e short b etw een 7, and D k . B ut even i f one o f the inputs, located below D k , has a h ig h value it turns its related PM O S transistor o ff and N M O S transistor on. Therefore, th e output w ill be lo w [3]. I f 7, is shorted to D,, the output equals 7, for any inputs com bination. These are show n in Table 3. In T able 3, Ij = <0| 1> V 1< j< k points out that PM O S transistor inputs above Dk can be either hig h or lo w and Ij = 0 V k + l< j< n indicates all PM O S transistor

in puts belo w Dk are low. In this case the output has the exact value o f 7,. In the second case, th e output rem ains low for all input com binations [Ij. I f all in puts located belo w Dk including 7, are low the output, w hich is connected to 7; th ro u g h eonducting PM O S transistors and the short betw een Dk and 7,, w ill be low. If one o f these inputs has a high value the p ath betw een the output and 7, is disconnected; the output w ill be connected to the ground through conducting N M O S transistors.
S h o r t f a u lts li Dk (i < k < n - I ) Dk is lo c a te d b e lo w th e Ij. li D,, (l<i<n) li > Dk (1 < k < i - l ) Dk is lo c a te d a b o v e th e Ij. I n p u t c o n d it io n s l j = < 0 | 1> & h= 0 V ]<j<k li ; F a u lt y o u t p u t ( O )

V k + l < j< n 0

F o r a ll oth er input c o m b in a tio n s F or all input c o m b in a tio n s

li

F or all in pu t c o m b in a tio n s

0

Table 3: Short between One Input and One PMOS Drain

19

4) Short between two PMOS drains: (D, ^ - ^ D k where {l< k< n and

i) )

Another type o f short faults occurs when Dj is shorted to another drain. There will be a difference in the output results if Z), is shorted to D,,, considered the same as the output, or if it is shorted to one of the other PMOS drains. If Di is connected to Dk (Z< k< n-1 and Ki^ i):

The output is stuck-on if all inputs, except the inputs between two shorted drains, are low. If at least one input of any transistor between the two shorted drains is high, the related NMOS transistor is turned on and a conducting path between VCC and ground appears. Figure 7 illustrates the short fault between Dj and D 2 for N 0R 3. By applying (010) as an input vector, Qi, Q3 and Q5 turn on and VCC is connected to the ground through Qi, D 1D 2 , Qs and Q5 . The output will be high if all inputs are low and will be low for all other input combinations. The output faulty pattern for short between two drains is shown in Table 4. In Table 4, Ij = 0 (V 1< j< i and m< j< n (i+l< m <n-l)) denotes all PMOS transistor inputs except those between A and Dk are low and (F+i || h + 2 ||...|| Im )=1 shows at least one of the inputs of PMOS transistors between D, and A is high. In this case the output has an unknown value between 0 and VCC volt (stuck-on).

i^ fb rt faults
Di Dk (l<k<n-l, 1< i < n - l and k # i )

Input conditions
Ij= 0 V l < J < n Ij=0(V & l < j < i andm<j<n(i+l<m<n-l))

Faulty output (O )
1 S-on (Stuck-on) 0

(li+l I I Ii+2 ·  1 0=1 For all other input com binations

Table 4: When D, is connected to A (1< k< n-1 and

i)

-

If Di (1 < i< n-I) is shorted to D,, the output will correspond to Table 5.

In this case, the reason behind a stuck-on faulty output is similar to the explanation o f stuck-on for Table 4.

20

F igure 7 illustrates this situation for N O R 3 w hen D i is connected to D 3 ( n = i) . I f a (010) input vector is applied, a conducting path from VCC to ground will go th ro u g h Q i, D 1 D 3 and Qs w hereas w hen a (001) input vector is applied, the conducting path w ill go through Qi, D 1D 3 and Qs. Thus, the output is stuck-on if the input o f at least one transistor betw een tw o shorted drains is high. T he total n um ber o f faults that short tw o drains can be com puted from equation (3.3.2.2).

w -- 1

(n - 1 )+ (n -

2

) 4 -... + ( » - ( » - 1 )) =
7= 1

(3.3.2.2)

ÎS M Ë È faults lj=0
Di D,,

In p u t conditions
V 1< i < n l<j<i) Ij=0 (V &

f a u l t y d o tp tif (< ))'
1 S -o n (S tu c k -o n ) 0

(1 < i < n - l )

(f+ l 1 1 Ii+2 In )=1 F or all oth er input c o m b in a tio n s

Table 5; W hen A (7 < f < n-1) is s h o rte d to D,,

5) S hort betw een one input and the output (/,

w here(7 < i < n ) )

This fault w as discussed in 3), w here inputs are shorted to D ,, .

A ll five types o f short faults have been covered in detail. T he total num ber o f sh o rt faults from the first to the last category is:

n -I

2 ^ ( « --y ) - l - + 2« --2
7=1

(3.3.2.3)

21

vcc

Û 4 I2 -- 1 [ ^ 1 3 -

Figure 7; Faulty NOR3 Transistor Level

3.3.3 Open Faults: Open faults occur after breaking at least one connection (channel) in the circuit. The souree o f the open state is a logic fault, which prevents the channel from conducting [5]. Under these circumstances every node in the circuit must be considered separately, since each node contributes to a different output result in the fault analysis. For instance, in the case of NORn, /,, D,,+i....D2 n and O are all separate nodes. Different types of open faults that can occur in the circuit are classified as follows: 1) liP (1 < i< n): Open When liP is open the logical fault type, which represents the Ijp open physical failure, is equivalent to VCC stuck open. This results in /,p stuck- at - la n d /,-at= /, [5]. When liP is stuck-at-1 the output will be in a tri-state if all inputs are low. In this case all PMOS transistors except the one with /,p input, which is stuck-at-1, are turned on and all NMOS transistors are off due to the low input values. The output has neither a path to VCC nor to ground. This is shown in Table 6. The total number of faults for Cp open fault is equal to n. and /,/> as well as D,,,

22

O pen faults
liP ;O pen (1 < i < n )

Input con d itions
li = 0 V l < j < n F or all oth er input c o m b in a tio n s

F au lty ou tp ut ( O #
Z

0

T a b le 6: Ijp O p e n 2) liM (1 < i <n): O pen T he logical fault type o f to th e situation w here open fault is identical to /, open fault w hich is sim ilar [5]. In the /,at stuck-at-0 condition,

is stuck-at-0 and Ijp =

th e o u tp u t is high im pedance i f all N O R n inputs except /, are low. In this case, all P M O S transistors conduct except that w ith input /,. A lthough /, is high, its N M O S tran sisto r (Qn + i) is o ff since 7,a? is stuck-at-0. T herefore, the output is neither

co nnected to V C C nor ground. H ow ever, if /, and the other inputs have low values the N O R n output w ill be connected to the VCC and w ill go high. This is show n in Table 7. T he total num ber o f faults for 7/# open fault is equal to n.
O pen faults In pu t conditions Ij = 0 V 1< j < n liN :O pen
(1 < i < n ) Ij = 0 ( V 1< j < n and j 9^ 1) & I j =I F or all o th er input c o m b in a tio n s

F au lty ou tp u t (O)-! 1
Z

0

T a b le 7: I în O p en 3) It {1 < i < n): O pen

li open fault acts sim ilar to w hen Cm is stuck-at-0 and Cp = /, [5]. The N O R n o u tp u t results for /, open fault is the sam e as Cm open fault. The total num ber o f faults in th is case is also n. 4) Di\ O pen A represents a drain belonging to N M O S or PM O S transistors. W hen (1 < i < n \ A is a PM O S drain. T he logical fault type A open fault is VCC stuck open, w h ich can b e rep laced b y Cp stu ck -at-1, Cn = h fault m odel. T herefore, the output w ill be the

23

same as /,/> open fault. A is a NMOS drain if {n+1 < i < 2n) and the output result will be the same as an 7,7 ^ open fault. The total number of faults in this category is 2n. 5) Si: Open If (/ = 7) the result of Si open will be the same as 7,^ open fault and if {n+1 < i < 2n) then 5, open fault behaves like an 7,A r open fault [5]. The PMOS sources, other than S], have not been considered since they are the same node as other PMOS drains which have been taken into account in the previous category. The total number of faults is 2 n+l for source open faults.
6

) 0 \ Open

A stuck open fault causes the output to be connected neither to power nor to ground. Therefore, the output is in a tri-state {O = Z). The number of faults in this category is 7. All open faults o f the NORn gate have been analyzed and the total number o f open faults from all six categories is 6n+2. The general formula for the total number of faults for NORn is concluded by adding the total number of faults from all groups of faults (stuck-at, short, and open):

n -\

2^^{n --j^ + n ^ + 1 0 n + 7. y=i

(3.3.3.1)

The patterns and formulas for the total number o f faults for other primary gates can be calculated in the same manner. The final results for NAND, Inverter, D-latch, and D flip-flop gates are presented in the following sections. Fault list patterns for AND and OR gates can be concluded from NOR, NAND, and Inverter. The D flipflop fault list can be concluded from the D-latch fault list.

24

3.4 N AN D n Com plete Fault L ist Pattern
F igure 7 presents a N A N D n gate. T he output pattern in the presence o f faults is presented in th ree groups o f faults in T able 8 for I/O stuck-at -fa u lts, T able 9 for short faults an d T able 10 an d T able 11 for open faults.

VCC

lip
Dn + 1
llN

liP
Dn +i Di

Szn

'HfQîn
Dzn 0

41^01
Si

3 i- 1 I bi-1 liN ip Q i

Sn-1
InN

----- I Qn S,,

F igu re 8: N A N D n T ran sistor L evel

In p u t/ou tp u t stuck-at^fauIts
Ij: stu ck -a t-0 stu ck -a t- 1 O: stu c k -a t-0 (fo r a n y in pu t c o m b in a tio n s) O: s tu c k -a t-1 (fo r an y in pu t c o m b in a tio n s)

F au lty ou tp u t (O ) 1
N A N D ( I| , I2 ..., 0 In)

1

T ab le 8: N A N D n Input/O utput Stuck-at-faults

T he m an y types o f short faults that m ay occur in a N A N D n circuit are categorized as follow : 1) Short betw een a N M O S source and ground or pow er

25

2) Short between two inputs 3) Short between one input and one NMOS source 4) Short between two NMOS sources 5) Short between one NMOS source and the output 6) Short between one input and the output

Short faults
Ii =l Si <--> G (ground) (1 < i < n - l )

Input conditions
V 1< j< n Ij=l ( V l < j < i ) & (Ij+, & Ii+2& ...& In)= 0 For all other input com binations For any input com bination Ij =l V l < j < n

'Faulty output (O) 0 S-On 1 1 0 X 1 1

S i< -^ V C C (1 < i < n - l )

Ij < -A Ik ( l < k <n and k / i )

l j =l ( V l < j < n a n d j ^ i j 9^k) & li © I k = l For all other input com binations

li^ ^ S k (i<k<n-l) Ij^ ^ S k (1 < k < i - l ) (1 < i < n )

For any input com bination Ij=l & Vl<j<k

li 1 0 S-on 1 0 S-on 1 li

l j = < 0 | l > V k + l < j <n For all other input com binations I | =l V l < j < n lj= 1 ( V 1< j < i and m < j < n (i+ l< m < n -l)) & (Ii+1& Ii+2&-. -&Im) = 0 For all other input com binations li = l V l < j < n

Sk ( l < k < n-1 1< i < n-1 and k f i):

S i( - - » 0 (1 < i < n - l )

Ij = 1 V ( i + l < j < n ) & (I1& I 2 & . . . & l i ) = 0 For all other input com binations For any input com bination

Ii<-AO (1 < i < n )

Table 9: NANDn Short Faults

26

M any o p en faults turn o u t to have a sim ilar logical fault type. T able 10 puts these faults into logical fau lt categories and T able 11 show s the output resu lt for each category.

O p e n f a u lt s liP : o p en ( 1 < i < n) Si: o p e n (n + 1 < i < 2 n) Dj: o p e n (n +1 < i < 2 n) li : o p e n ( 1 < i < n) liN : o p e n ( 1 < i < n) Si: o p e n ( I < i < n) Dj: o p en ( i = 1) O: op en

L o g ic a l f a ^ ï ï y p ë i

lip: stu ck -a t-1

I,n: stu ck -a t-0 Z

T ab le 10: N A N D n O pen Faults C ategories

L o g ica l fa u lt typ e o f open faults

Input con d itions
I j = l V 1< j< n I j = l ( V l< j< n and j i) & Ij = 0 F or a ll other input c o m b in a tio n s I j = l V l <j <n F or all other input c o m b in a tio n s F or a n y in pu t c o m b in a tio n

F au lty ou tp u t (O )
0 Z 1

lip: stu c k -a t-1

I,N: stu c k -a t-0 Z

z
1

(O:o p e n )

z

T able 11: N A N D n O pen Faults T he g eneral form ula for th e total num ber o f faults for N A N D n is:
n -\ n -]

' ^ { n --j ) + ' ^ { n - k ) + k= 2 y=i

+ 11« + 1

(3.4.1)

T h e fault list patterns o f O R and A N D gates w ith n inputs can easily be concluded from N O R n and N A N D n. T he com plete tables o f patterns for these gates are presented in the appendices. Inverter, D -L atch, and D Flip-Flop have a specific num ber o f inputs. Therefore, it is not appropriate to say they are follow ing a specific fault list pattern due to their num ber o f inputs. E ach has only one com plete fault list w hich w ill be presented in Sections 3.6 and 3.7.

27

3.5 Inverter Complete Fault List
The most important CMOS gate is the CMOS inverter. It consists o f only two transistors, a pair o f one N-type and one P-type transistor. Figure 9 shows an inverter gate. The output pattern in the presence of faults is presented in three groups o f faults in Table 12 for input / output stuck-at faults. Table 13 for short faults and Table 14 for open faults. The total number o f faults for the inverter is: 13

vcc

Figure 9: CMOS Inverter

Itipiit/output stuck-at fault ' Faulty output ( O #
I: stuck-at-0 I: stuck-at-1 0 : stuck-at-0 O: stuck-at-1 1 0 0 1

Table 12: Inverter Input / Output Stuck-at Faults

Bihort faults

Faulty output (O)
I

Table 13: Inverter Short Faults

28

O pen faults
O:open Ip: o p en 1^: op en I; o p en S ,: o p en S 2: o p e n D i: o p en D 2: op en

In pu t con d itions
For a ny I 1= 1 1= 0 1= 0 1= 1 N /A 1= 1 1= 0 1= 0 1= 1 1= 1 1= 0 1= 0 1= 1

F au lty ou tp u t (O )

Z
0

z
1

z

z
0

z
1

z
0

z
1

z

T ab le 14; Inverter O pen Faults

3.6 D -Latch Com plete Fault List
In C M O S technology, T -gates allow efficient realizations o f several im portant logical functions [9]. Such a circuit consisting o f one N -type and one P-type transistor connected in parallel an d controlled by inverted gate voltages is show n in Figure 10. This circuit is defined as a tran sm issio n gate (T-gate) circuit. If the gate voltage o f the N -type transistor is 'G N D ' an d the P -type transistor has a gate voltage o f 'V C C , both transistors are non-conducting. O n th e oth er hand, i f th e gate voltage o f the N -type transistor is 'V C C and the gate voltage o f the P -type tran sisto r is 'G N D ', both transistors are conducting. I f the source voltage is near V C C , there is a voltage drop across the N -type transistor but (alm ost) no voltage drop across the Pty p e transistor. I f the source vo ltage is near G ND, the N -type transistor has (alm ost) no v oltage drop. D ue to the sym m etry o f standard M O S transistors, there is no reason to d ifferen tiate betw een source and drain in a T-gate. The contacts are therefore usually referred to as 'L' (left) and 'R' (right). F ig u re 11 illustrates a D -latch by using only 8 transistors (2 inverters and 2 T -gates) for cases w h ere bo th the clock (C) and the inverted clock (nC) signals are available. I f th e in v erted clo ck is n o t available, an additional inverter is required to provide the control signal fo r th e tw o T -gates [9].

29

A standard D-latch can be built from four 2-input NAND gates [8]. Thus, 16 transistors are needed for one D-latch. However, in this study we consider the D-latch circuit in Figure 11 in order to reduce the number of transistors leading to a lower number of possible faults. The case o f a faulty inverter has been discussed in previous sections. Here, we assume that: 1. Both the clock and the inverted clock signal are available. 2. All signals are propagated up to the edge of the D-latch cell correctly. The similar approach to NOR gate is applied to the D-latch to obtain its faulty output in the presence o f a single fault. Later, the results from a D-latch fault list can be used to determine the fault list o f a D flip-flop. nC

R

Figure 10: T-gate

3.6.1 Input / Output Stuck-at Faults D, C (Clock), nC (inverted clock), and Q represent the input/output nodes o f the D-latch in Figure 11. These nodes can be stuck-at-1 or stuck-at-0 leading to a faulty output. The results are shown in Table 15. Q' represents the previous state of output Q. When D is a stuck-at-fault, the output remains in its previous state as long as the clock is low. The output shows a faulty value for D when the clock goes high. When C and Q are stuck-at-faults the result o f the faulty output can be easily computed. For example, when C is stuck-at-0 the feedback T-gate (T2 ) is always conducting so the output remains in its previous state if nC is high. When nC is low and C is stuck-at-0 Ti gate also conducts,

30

th erefo re the output has the value o f D. W hen C is stuck-at-1 7y is alw ays conducting and th e value o f D goes directly to the output. T 2 conducts w hile n C is stuck-at-1. The output rem ains in its previous state if C is low . O nce C becom es high, the T / gate eonducts and the value o f D goes to the Q. I f n C is stuck-at-0 gate Tj conducts and the output has the value o f D.
c

A2

À
nC

F2

nC

JL
vcc
Si Aip

VCC S3

Bp
Q1 |-- C Di Ü2 Q2 Q4 Bn
82

Q3 Ds

Ai

B

Q
4

A in

]

S4

Figure 11: C M O S D L atch
#S t u c k a t f a u lt D : stuck-at-1 D : stu ck -a t-0 C: stuck-at-1 C: stu ck -a t-0 Q: stu ck -at-1 Q: stu ck -a t-0 nC: stu ck -at-1 nC: stu ck -a t-0 I n p u t c o n d itio n s C = 0 C= I c = o C= 1 N /A nC= 1 nC = 0 F o r a n y D and C F o r an y D and C C= 1 C = 0 C= 1 c = o

F a u im m m w # Q (p r e v io u s sta te ) 1 Q 0 D 0 D 1 0 D O' D

Table 15: D-Latch Input / Output Stuck-at Faults

31

3.6.2 Short Faults
A short fault can occur at the connection o f two nodes in a D-latch circuit. In this category o f faults A, A/, A 2, A/p m à Ain are considered one node and are referred to as A because their behaviour is identical in the presence of short faults. Also, B, Bp, Bn, DI and D 2 are collectively referred to B and finally Fj, F 2 and Q are named Q. By these assumptions there are 6 nodes in the D-latch transistor-level circuit (A C, nC, Q, A, B). Short faults can be categorized in two groups for the D-latch. 1) Short between each node and VCC or ground The shorts between D, C, nC or Q and VCC or shorts between D, C, nC or Q and ground have not been considered here because their stuck-at-1 and stuck-at-0 have the same effect and they have already been discussed in Section 3.6.1. The results from connecting A and B to VCC or ground are presented in Table 16. A and B have direct control over Q without depending on C or D. Therefore, when they are shorted to VCC or ground they change their output value independently.

1 S h o r t faults A eA V C C 1^ B 1B G VCC G

In p u t co n d itio n s For any C and D For any C and D For any C and D For any C and D

F a u lty o u tp u t fO ) 0 0 1 1

Table 16: Short between Each Node and VCC or the Ground in D-latch 2) Short between two nodes There are six nodes in the D-latch circuit D, C, nC, Q, A, B. If these nodes are connected to each other incorrectly, a faulty output will result. Table 17 shows the results that can be attained from a D-latch truth table. A short between D and nC leads to different output states depending on their value. If D and nC are both low D is passed to the Q through Tj gate. If these two signals are both high T 2 gate conducts and Q remains in its previous state. When D and nC have opposite values, the value o f the short outcome is unknovm. Therefore, the output is in an unknown state.

32

A short betw een D and A, B, o r Q passes the value o f D to these nodes asynchronously. W h en C is connected to nC, one o f th e transistors o f the T / and T2 gates conducts an d th e output has the value o f the D constantly. A short betw een C and Q forces the o u tp u t to C value. A connection betw een C and A results in ^ = C for any value o f D. WTien C is shorted to B, the output is N O T(C ) due to an inverter betw een nodes B and g. A ny short betw een n C and Q, A, and B forces the value o f n C to one o f these nodes. W hen node A and B are shorted together one o f the inverters is bypassed and th e ou tp u t Q is alw ays inverted com pared to a fault free D-latch. T he sam e situation occurs w h en B is shorted to Q. W hen A is shorted to Q the output behaviour is the sam e as a fault free circuit.
1 S hort fau lts D C

In pu t conditions
D = C = 0 , (Z) and C are lo w ) D = C = 1 , ( D and C are h ig h ) D = NOT(C ) , ( D and C h a v e o p p o site v a lu e s) D = nC = 0 , (£) and n C are b o th lo w ) . D = nC =1 , (D and n C are b o th h ig h ) D = F or F or F or

Faulty outhtit (O ii
QD X D QX D D

1D ^ ^

nC

D < r-^ 0

D
D

A
B

NOT ( n C ) , ( D and nC h a v e o p p o site v a lu e s) a n y C and Q' a n y C and Q' a n y C and Q

NO T ( D )
D C C

C 4 --^ nC

F or a n y C , D and Q F or an y D and Q F o r an y D F or an y D and Q' F o r a n y C , D and Q F or a n y C , D and Q F or an y C , D and Q' C= 1 C = 0 C= 1 C = 0 C - 1

c C C

Q A
B

NO T (C) = nC
nC

n C ^ --¥ Q nC ^ > A

nC

B B

A A

nC NO T(nC) = C NOT (D ) NOT (Q-)
D 0

Q

B < r^ Q

C= 0

NO T (D ) NO T (Q-)

Table 17: D-Latch Short Faults between Two Nodes

33

3.6.3 Open Faults
The open fault D causes a tri-state for the output when C is high and the gate Tj is closed. When C is low the gate T2 is switched on and causes the output to keep its previous state. Open faults C and nC do not affect the output behaviour since one Tgate is conducting at a time.

# p e n faults
D :o p en C :op en n C :op en A; open A ,: open A 2: open

Input conditions
C= 1 c = o nC = 0 nC = 1 C= 0 C= 1 C= 1 C -0 For any D, C and Q' C= 1 C= 0 (C = D = l ) | | ( C = 0 & Q - = 1) ( C and D both high or C low and (T h igh) (C = I & D = 0 ) | | ( C = O ' = 0 ) (C = D = 1 ) | | ( C = 0 & 0 ' = 1) (C = l & D = 0 ) | | ( C = Q - = 0 ) For any D, C and f f (C = D = 1) 1| ( C = 0 & O ' = 1) ( C = l & D = 0)|l(C = O'=0) (C = D = l ) | l ( C = 0 & O ' = I) ( C = l & D = 0)|1 (C = Q- = 0) For any D, C and Q' C= 1 C= 0 For any D, C and Q' Like A,p: open Like A,p: open Like A in : open Like A | n : open Like Bp: open Like Bp: open Like B n ; open L ike B n ' open

Faulty output (0 ) Z
QD QQD

Z
Q-

z
D

Z
1

A,p:open

AiNiopen B : open Bp: open B n : open F|: open F2: open Q: open S]: open D j: open S;: open D;: open S3: open D 3: open S4: open D 4: open

z z
0 z z 0 1 z

z
D

Z Z

Table 18: D-Latch Open Faults

34

O pen fault A has the sam e effect as open fault D. O pen faults A], B and F / produce a tri-state output. W hen A 2 or F 2 is opened the output has the value o f D w hen gate Ty is sw itched on. The output goes to a tri-state w hen gate Ti is o ff because th e feedback circuit is disconnected. Once A ip is opened the output is high if the input o f th e first inverter (transistors Qj and Q 2 ) is high. W hile the input o f the first inverter is low the output goes to a tri-state due to disconnection o f Qj PM O S transistor. The sam e approach is used w hen ^ / v is opened. In this case Q 2 is disconnected and the lo w input value o f the first inverter results in a low output. A high input value forced th e o utput to a tri-state. The sam e conclusions can be draw n for open faults Bp and Bm- T h e total num ber o f faults for the D -latch is 49.

3.7 D Flip-Flop Complete Fault List
A n edge sensitive D flip-flop can be m ade from tw o D -latches in m aster and slave m ode [7]. A lth o u g h som e V L SI libraries indicate alternative configurations, the case study discu ssed here considers only this configuration. The sam e fault analysis can be extended to a cu sto m D flip-flop library. The fault list for a D flip-flop can be easily concluded from a D latch fault list. F igure 12 show s a D flip-flop circuit. In this figure the inverters are show n w ith g ate form ats. T he faults related to the inverters have been discussed in the D -latch and in v erter sections. T herefore, in this section we assum e that all o f the inverter gates are fault free. A ll the faults related to a circuit's nodes are taken into account in this section. T o co n sid er the edge sensitivity o f a D flip-flop, we divide the circuit into tw o level sensitive D -latches. In the presence o f one fault, the output B o f first D -latch (D L l) is first co m p u ted an d th e n the second D -latch (DL2) output Q is studied. Table 19 illustrates the resu lt o f th e fault free D flip-flop for Figure 12. This approach show s that the D flip-flop fau lt list can be determ ined by follow ing the D -latch fault list pattern.
Input conditions C= 1 c = o F a u lt F ree Qj O' { previous state) NO T (B) Fau lt F ree B NOT (D ) B` (previous state)

T able 19: F au lt F ree D Flip-Flop

35

DLl

DL2

nQ

Figure 12: D Flip-Flop

3.7.1 Input / Output Stuck-at Faults D, C, nC, Q and nQ are the inputs and outputs of D flip-flop. Table 20 shows the output results in the presence of a single stuck at fault.

S tu ck -a t-fa u lt D; stuck-at-1 D: stuck-at-0 C; stuck-at-1 C; stuck-at-0 Q: stuck-at-1 Q; stuck-at-0 nQ; stuck-at-1 nQ: stuck-at-0 nC: stuck-at-1 nC: stuck-at-0

In p u t co n d itio n s C= 1 c = o C= 1 c = o nC = 0 nC = 1 nC = 0 nC = 1 C= 1 C= 0 C= 1 C= C= C= C= 0 1 0 1

F a u lty B 0 B` 1 B` N O T (D ) N O T (D ) B" N O T (D ) B" N O T (D ) B" N O T (D ) B' N O T (D ) BD B N O T (D )

F a u lty ou tp u t ( 0 ) QN O T (B ) QN O T (B ) QN O T (B ) N O T (B )

1 0 0 Q N O T (B ) QN O T (B ) N O T (B ) Q N O T (B )

G= 0 C= 1 C= 0 C= 1 C= 0

Table 20: D Flip-Flop Input / Output Stuck-at Faults

36

3.7.2 Short Faults
T o exam ine short faults for a D flip-flop, som e nodes are considered as one node due to th eir sim ilar behaviour in the presence o f a short fault. Therefore, A, Aj, and A 2 are addressed as A, B, Bj, and B 2 are addressed as B. F represents F, F j and F 2 . H represents H, H j, and H 2 and finally K, K j, and K 2 are addressed as K in short faults study. T able 21 show s all the possible short faults in a D Flip-Flop.

1 S h ort faults A VCC

In pu t con d itions
C= 1 c = o C= 1 c = o C= 1 C = 0 C = 1 c = o C= 1 c = o C = 1 c = o C= 1 c = o C= 1 c = o C= 1 c C c C = = = = o 1 o 1

F a u lty B
0 I N O T (D ) 0 N O T (D ) 1 1 0 N O T (D ) B N O T (D ) B' N O T (D ) B' N O T (D ) B` N O T (D ) B' N O T (D ) B B' D X D B` X N O T (D ) B N O T (D ) B N O T (D ) N O T (D ) D

F au lty ou tp u t ( 0 )
Q I Q0 Q 1 Q 0 Q 0 Q1 0 1 1 0 0

A < --> G E VCC G VCC

E
B

B <--^ G F F VCC G

H <--> V C C H
K K G VCC G

c = o C= 1 c = o D = C = 0 D = C= 1 D = N O T (C ) D = nC = 0 D = nC = 1 D = N O T (n C ) C= 1 C = 0 C= 1 c = o C= I c = o C= 1 c = o C = 1

1
N O T (B ) Q X Q N O T {B ) X D Q N O T (B ) QD Q D

D

C

D ^ ^

nC

D

Q nQ A E B

D
D ^ ^ D D

Q

37

c = o D 4 - -» F D D H K C= 1 c = o C= 1 c = o C=1 c = o For any C, nC C= 1 C= 0 C= 1 C= 0 C= 1 C= 0 C= 1 C= 0 C= 1 C= 0 C= 1 C= 0 C= 1 c = o C= c = C= c = C= c = 1 o 1 o 1 o N O T (D ) B N O T {D ) B N O T (D ) B N O T (D ) N O T (D ) B" N O T (D ) B' N O T (C ) N O T (D )

N O T (D ) N O T (D ) D N O T (D ) N O T (B ) C q N O T (B ) Q' c q-

C <r-^ nC C<-->Q C nQ

C<--> A

C < r^ E
C < --> B

1
C N O T (D ) B N O T (D ) B N O T (D ) B' N O T (D ) B" N O T (D ) B N O T(nC ) = C N O T (D )

0
q-

1
nC C nC nC q N O T (B) QN O T (B) qq

C < r-^ F C < -^ H
C<--> K nC ^ > Q

nC < --> nQ nC A

C= 1 c = o C= 1 c = o C= 1 c = o C= c = C= c = C= c = C= c = C= 1 o 1 o 1 o 1 o 1

nC f -- ^ E nC 4--^ B nC < --> F nC < --> H nC < --> K Q f-^nQ A

0
nC N O T (D ) B" N O T (D ) B' N O T (D ) B" N O T (D ) B N O T (D ) B" N O T (D ) B' N O T (D ) B" N O T (D ) B N O T (D ) B'

0
c nC C Y A D N O T (B) D N O T (B) B B q N O T (B) 1 1 1

c = o C= 1 c = o C= 1 C -0 C= 1 c = o C= 1 c = o

q e ^ B q e ^ F q e -)H

38

Q nQ

K A

C= 1

c=o
C= 1

N O T (D ) B' N O T (D ) B' N O T (D ) B N O T (D ) B N O T (D ) B N O T (D ) B N O T (D ) B N O T (D ) B D N O T ( B ') N O T (D ) B` N O T (D ) B' N O T (D ) B' N O T (D ) N O T ( B ') N O T (D ) B' N O T (D ) B' N O T (D ) B' N O T (D ) B' N O T (D ) B" N O T (D ) B" N O T (D ) B" N O T (D ) B N O T (D ) B

N O T (Q -) B

c =o
C = 1

Q
N O T (B )

n Q < --> E n Q < --> B nQ > F

c =o
c 1

Q
N O T (B )

c=o
C= 1 C -0 C= 1

Q N O T (B )

Q N O T (B )

n Q <--> H n Q < --> K A A A A A E E E E <-->K B ^-> F B B F 1F 4-^ H E B F H K B F

c =o
C= 1

Q
N O T (B )

c =o
C= 1

Q N O T (B )

c =o
C = 1

Q N O T (B )

c =o
C = 1

Q N O T (B ) N O T (D ) X D N O T (B ) N O T (D ) X

c =o
C= 1

c =o
C= 1

c =o
C= 1

c =o
C = 1

Q B D X N O T (B ) D X N O T (B ) B N O T (B ) N O T (Q - ) B

c =o
C= 1

c =o
C= 1

c =o
C = 1

c =o
C= 1

c =o
C= 1

< -^K
H K

c =o
C= 1

c =o
C= 1

c =o
C= 1

Q N O T (B ) N O T (Q -) B

1H

c =o

Table 21: D Flip-Flop Short Faults

39

3.7.3 Open Faults
Faulty B

Oiîefltànlts
D : open C : open nC : open Q ; open nQ ; open A; open

Input conditions
For any C nC= 1 nC = 0

z
B`

z
NOT(B)

C= 1
C= 0 For any C C= 1 C= 0 C= 1

NOT(D) NOT(D)
B Z

QQ-

NOT(B)
Z

NOT(D)
B' Z B' Z

QNOT(B)

QNOT(B)
Z

c =o
For any C C = 1

I A l: open 1 A2: open 1 E: open 1 B: open I B l: open
B 2 :o p e n

NOT(D)
Z

O'
NOT(B)

c =o
C= 1

NOT(D)
Z Z

c =o
For any C For C= C= C= any C 1 0 1

QNOT(B)
Z Z

z
NOT(D)
Z

O'
NOT(B)

1 F: open 1 FI: open 1 F2; open
H: open H I: open H2: open K :o p en K l.'open K2: open

NOT(D)
B'

c =o
C= 1

z
Z 1

NOT(D)
B

c =o
C= 1

NOT(D)
B"

z
NOT(B)
Z

c =o
C= 1

NOT(D)
B

c =o
C= 1

NOT(D)
B"

c =o c
C= 1 = C= 1

QNOT(B)
Z Z 1

NOT(D)
B`

I

o

NOT(D)
B

c =o
C= 1

NOT(B)
Z

c =o
C= 1

NOT(D)
B

c =o

NOT(D)
B"

Table 22: D Flip-Flop Open Faults

The total number of faults for the D Flip-Flop is 98.

40

Chapter 4 User-Defined VHDL Library of Transistor Level Faults
In a structural level o f abstraction a system closely corresponds to the actual hardw are and thus can easily be understood and used by a hardw are designer. To describe a system at th e structural level, the com ponents o f that system are listed and the interconnections betw een th em are specified. A term often used to describe this form o f description is netlist. V H D L p rovides language constructs for concurrent instantiation o f com ponents, the p rim ary constructs fo r structural specification o f hardw are [10]. A com plete transistor m apping to a gate level fault list o f each prim ary gate w as p resen ted in the previous chapter. In the presence o f a fault from a gate fault list, the changes in gate fu n ctio n lead to a different output. A ll possible gate functions in the presence o f faults are discu ssed in C hapter 3. These functions can be presented in V H D L form at describing the b eh av io u r o f th e faulty gates in a synthesizable hardw are language.

4.1 V H DL Presentation o f Faulty Gates
E ach gate has a specific num ber o f faults w hich can be calculated from the general fo rm u la o b tain ed for each type o f gate in C hapter 3. Table 23 shows the results w hen 2 < n < 5. T h e u p p er b o und for the num ber o f inputs is five due to the fact that the selected benchm arks u sed in o u r case study w ere restricted to a m axim um o f five inputs.

41

Gate Name
N 0R 2 N 0R 3 N 0R 4 N 0R 5 NAND2 NAND3 NAND4 NAND5 AND2 AND3 AND4 AND5 OR2 OR3 OR4 OR5 Inverter Buffer D-latch D Flip-Flop

Total number o f faults
28 47 70 97 28 47 70 97 41 62 87 116 39 60 85 114 13 24 49 98 1272

Total =

Table 23: Total Number of Faults for Each Gate

The total number o f necessary VHDL codes to represent each fault in a gate can be extracted from Table 23. For example, to represent all possible faults in a N 0R 2 gate, 28 VHDL codes are needed. For instance, a short fault between Di and /; makes the N 0R 2 gate (Figure 3) behaves differently. The difference o f behaviour between a faulty NOR and a fault free NOR gate can be observed at the output. Thus, the output will be:

42

ai::;
T his o u tp u t can b e presented by a synthesizable V H D L code show n in F igure 13: L I B R A R Y ieee; USE i e e e .s t d _ l o g i c _ 1 1 6 4 .a l l ; E N T I T Y N 0 R 2 _ s h o rt _f au lt is port ( I I , 12 : IN STD_LOGIC; O : OUT STD_LOGIC); END NOR2_short_fault; A R C H I T E C T U R E faulty_inoclule of N0R2_short_fault SI GN AL A: STD_LOGIC; B E G IN -- II is shorted to 01 A <= 12; O <= II WH EN A = 'O' ELSE 'O'; E N D fau lt y module; IS

F ig u re 13: N O R 2 _ S h o rt_ F a u lt S y n th esizab le V H D L co d e T h e o p en node, Ijp^ can be an exam ple o f an open fault. In this case th e behaviour o f the faulty o u tp u t w ill be:

T his fau lty o u tp u t is presented by the synthesizable V H D L code in F igure 14.

L I B R A R Y ieee; USE i e e e .s t d _ l o g i c _ 1 1 6 4 ,all; E N T I T Y N0 R 2 _ o p e n _ f a u l t is p o r t ( II, 12 : IN STD_LOGIC; 0 : OUT STD_LOGIC); END N0R2_open_fault;

43

ARCHITECTURE faulty_module of N0R2_open_fault IS SIGNAL A: STD_LOGIC; BEGIN -- IIP is open A <= Il or 12; 0 <= '0' WHEN A = '1' ELSE 'Z '; END faulty module;

Figure 14: NOR2 open fault synthesizable VHDL code

The above codes can be considered as components in a circuit specified by structural (gate level) VHDL code. The next section discusses how to automatically create faulty VHDL components.

4.2 Creating Faulty VHDL Components Automatically
As shown in Table 23, 1272 VHDL codes will be needed to create all faulty components o f primitive gates. It is neither cost-efficient nor error-free to write a large number of VHDL modules manually especially when modifications may be required. Therefore, the process of creating faulty VHDL modules must be automated. For this purpose we will use Perl as our scripting language. In the Perl automated program, the patterns of each gate obtained from the tables in Chapter 3 are used and the proper VHDL components are generated. In general, the program runs as follows:

Step 1: Write a FOR loop for changing the number of input, n, from 2 to 5 for a specific type o f gate. Step 2: Define an array, called @fault_number*. Each member of this array shows the total number o f faults for each group of faults which belongs to one of the rows of fault pattern tables defined in Chapter 3. For example, the total number of input stuck-at-1 in NORn is n. Therefore, its related member o f the array, $fault_number[i]^, has the value of n.

' A n array is defined by @ character in Perl language. ^ A scalar is defined by $ character in Perl language.

44

Step 3: W rite a general subroutine, called subroutine entityvhdl, to create a V H D L file in a desired directory. In this subroutine the entity part o f the V H D L code is w ritten w ith regard to th e value o f n. Step 4: W rite specific subroutines w hich w ill represent each row o f fault patterns in the tables. F o r exam ple, the subroutine o f input stuck-at-1 in N O R n assigns a low value to the output. T hese subroutines create the architectural body o f V H D L m odule based on their related fault patterns. T able 24 show s the total num ber o f Step 4 subroutines for each type o f gate. Step 5: W rite a F O R loop for each row o f tables. N um ber o f iteration o f the loop depends o n th e v alue o f $fault_num ber[i] firom Step 2. In this loop, subroutine entityvhdl and one o f th e subroutines o f Step 4 are called and the related V H D L com ponent is created. F igure 15 show s a section o f the program for input stuck-at-1 in N O R n.

f o r ( $ n = 2 ;$n<6;$n++) { $ f a u l t _ n u m b e r [0]= $n;

FOR loop of step 1 # step 2

f o r ( $ m = l ; $ m < = $ f a u l t _ n u m b e r [0];$m++) # input stuck-at-1
{

&entityvhdl($n,$m); & in pu ts tucklfault ;
}
}

# calling step 3 subroutine # calling step 4 subroutine # for input stuck-at-1

########################################## # S ub ro ut in es ########################################## sub entityvhdl { $underline="_F"; $component_name="NOR$n$underline$m"; $file_name= "NOR$n$underline$m.vhd";
$ first p a r t _ V H DL _b od y= " LIBRARY ieee;\n
* Comm ents are specified with # in Perl

45

'

'

USE ieee.std_logic_1164.all;\n\n ENTITY $component_name is\n p o r t (";

open (FILE, ">$file_name"); print FILE "$first_part_VHDL_body\n"; @inputs= sinputgenerator($n); print FILE "0inputs : IN STD_LOGIC;\n 0 : OUT STD_LOGIC);\n END $component_name; \n ARCHITECTURE faulty of $component_name IS\n
}

############################################

sub inputgenerator { my @INPUT; my $x; for ($x=l; $x<=($n-l); $x++)
{

# defining inputs for # entityvhdl subroutine

$INPUT[$x]="I$x,
}

";

$INPUT[$n]= "I$n "; return @INPUT;
}

################################################

sub inputstucklfault
{

# step 4 subroutine

print FILE "BEGIN \n -- one input is stuck-at-l\n 0 <= '0';\n END faulty; ";
}

Figure 15: Perl Program Section for NORn Input stuck-at-1 Fault

46

G ate T ype NOR NAND OR AND D -L atch D Flip-Flop Inverter B uffer

T otal num ber o f Step 4 subroutines 12 14 18 21 41 76 8 14

T a b le 24: T otal N um ber o f Subroutines

4.3 D esigning a User-defined Library
L ogic fam ilies o r group o f com ponents can be categorized according to their physical characteristic, price, com plexity, usage, or other properties. The V H D L language supports the use o f design libraries for categorizing com ponent or utilities. In general, libraries are used for d esig n organization. Specific applications o f libraries include sharing com ponents betw een designers, grouping com ponents o f standard logic fam ilies, and categorizing special purpose utilities such as subprogram s or types. 4.3.1 E x istin g L ibraries P redefined libraries in V H D L are the STD and the W O R K libraries. T he STD library contains all the standard types and utilities and is visible to all designs. The W O R K library is sim ply a nam e that refers to the current w orking library. W hen a V H D L environm ent is created for a user, the keyw ord W O R K refers to the root library o f th e user. A s n ew libraries are created, the user can designate a new default library b y equating one o f the libraries to the W O R K library [10]. 4.3.2 L ib rary m an agem en t L ibrary m anagem ent tasks, such as the creation or deletion o f a library or aliasing it to W O R K , are n o t p a rt o f the V H D L language. These tasks are d one outside o f

47

VHDL and depend on the specific tool which, in this research, is the Xilinx ISE CAD tool. The use of a library, however, is supported by VHDL. The LIBRARY keyword followed by the name of a library makes it visible to a design. The following statement is assumed by all designs: LIBRARY WORK; 4.3.3 Aliasing the faulty components to WORK library The faulty VHDL components, created automatically with respect to each gate type pattern, can be added to the WORK library so that it is visible to all circuit VHDL codes. The components can be added to the WORK library manually by using GUI format of Xilinx ISE tool or by using ISE command line. The number o f VHDL components is 1272. Adding all components to WORK library is inefficient. Only necessary components must be eonsidered. Therefore, based on the cireuit specification, only some components are added to WORK library. This job can be done automatically by knowing the component list of each circuit and ISE command line in Perl language. For example, we considered the benchmark C l7, a combinatorial circuit. Then we injected a fault to the code by replacing the NAND2 module by a faulty module called NAND2_F1 shown in Figure 16. There are only two gates used in this code therefore, only NAND2.vhd and NAND2_Fl.vhd are added to the WORK library. To automate this process, Perl program gets two lists: the component list of a specific circuit and the user fault list. By using these two lists, it opens a new file, called project files {.prj), and assoeiates all fault free eomponents of the component list and faulty components of the user fault list to WORK library. When the ISE synthesizer tool (XST) is synthesizing the circuit VHDL code it will look at all components listed in the project file and then synthesize them. Figure 17 shows the project file related to the fault injected benchmark C l7.

48

l i b r a r y IEEE;

use IEEE.std_logic_1164-all; entity cl7 is
p o r t ( PIl, POl, e n d cl7; a r c h i t e c t u r e STRUCTURE of cl7 is s ignal GIO, begin G 1 0 _ N A N D 2 : N A N D 2 port m a p (E 1 = > P I 1 ,E 2 = > P I 3 ,A = > G 1 0 ); // fault is in je c te d in G11_NAND2 gate Gil, G16, G19 : std_logic; PI2, P02 PI3, PI4, PI5 : in std_logic;

: out std_logic) ;

G11_1SIAND2 :NAND2_F1 port m a p (E 1 = > P I 3 ,E2=>PI 4 ,A = > Gil); G 1 6 _ N A N D 2 : N A N D 2 port m a p (E 1 = > P I 2 ,E 2 = > G 1 1 ,A = > G16) G 1 9 _ N A N D 2 : N A N D 2 port m a p (E 1 = > G 1 1,E 2 = > P I 5 ,A= > G19) G 2 2 _ N A N D 2 : N A N D 2 port m a p {E 1 = > G 1 0 ,E 2 = > G l 6,A=> POl) G 2 3 _ N A N D 2 : N A N D 2 port map(E1=>G16,E2=>G19, A=> P 0 2 ) e nd STRUCTURE;

F igure 16: C l 7.vhd

vhdl work vhdl w o r k

../ f a u l t y c o m p o n e n t / N A N D 2 .vhd ../ f a u l t y c o m p o n e n t / N A N D 2 _ F l .vhd

v hd l w o r k c l 7.vhd

Figure 17: C 17.prj O nce the related V H D L components are added to WORK library, the user-defined faulty com ponent library w ill be ready for use. In the next chapter w e w ill discuss how to use the faulty com ponents in the V H D L codes o f circuits as w ell as the method o f injecting faults.

49

Chapter 5 Fault Injection into Circuit VHDL Description

A circuit can be modeled in several manners according to the desired abstraction level (e.g. architectural, logic, geometric), to the wanted view (e.g. behavioural, structural, physical) and to the modeling method being used (e.g. language, diagram, mathematical model). In recent years, there has been a trend towards using hardware description languages (HDLs) for circuit specification. The conciseness of HDL models has made them preferable to the corresponding flow, state and logic diagram, even though some diagram models are more powerful in visualizing the circuits' functions. Circuit specifications shall not be described in terms of diagrams, because the information that most of them convey can be expressed in equivalent form by HDL models [11]. VHDL is the VHSIC, i.e. Very High Speed Integrated Circuit, hardware description language. It can describe the behaviour and structure of electronic systems, but is particularly suited as a language to describe the structure and behaviour of digital electronic hardware designs, such as ASICs and FPGAs as well as conventional digital circuits [49]. This chapter will discuss behavioural and structural features of HDL models. It will also present different approaches of fault injection into both behavioural and structural HDL models based on their features. In this research we are using a structural VHDL description o f a circuit for injecting faults. One reason is that the structural features of VHDL descriptio"

50

are co m p atib le w ith o u r user-defined library introduced in C hapter 4. Section 5.3 w ill discuss our fau lt in jectio n ap p ro ach in m ore detail.

5.1 Behavioural Feature o f Hardware Languages
T he b eh av io u ral descrip tio n deals w ith the system as if it w ere a kind o f "black b o x " w ith its inputs an d o u tputs, w ith no regard to its structure. T he goal is to ignore the redundant details an d to con cen trate on the necessary function specifications. B eh a v io u ral m o d elin g for circuits is considered in increasing levels o f com plexity. C om b in atio n al logic circuits can be described by a set o f ports (input / output) and a set o f equations th at relate v ariab les to logic expressions. The declarative paradigm applies best to com b in atio n al circuits, interco n n ectio n (i.e. w h ich are a structure) by definition m em ory-less. Indeed, they can be seen as an o f operators, each operator evaluating a logic function.

T hese m o d els d iffer fro m structural m odels in that there is not a one-to-one correspondence betw een expressions an d logic gates, as a single gate m ay not exist for som e expressions for im p lem en tatio n [11]. F ig u re 18 show s the half-adder circuit in the V H D L language, u sin g its behavioural m o d elin g capability.

A r c h i t e c t u r e B E H A V I O U R of H A L F _ A D D E R is Pr ocess Begin C ar ry <Sum E n d process; E n d BEHAVIOUR; <= (a and b) (a xor b) ; ;

F igu re 18: H alf-ad d er B eh aviou ral M odel

5.2 Structural Feature o f Hardware Languages
T he structural d escrip tio n defines the w ay that the system is to be b u ilt up. T h e focus is on th e b lo ck s a n d h o w th ey interact w ith each other to form a system s structure. T he subsystem s, w h ic h are to p ro v id e its functional execution, are defined som ew here else.

51

Structural languages models describe an interconnection of components. Hence, their expressive power is similar to that of circuit schematics, even though specific language constructs can provide more powerful abstractions. Hierarchy is often used to make the description modular and compact. The basic features of structural languages place them close to the declarative class, even though some structural languages also have procedural features. Variables in the language correspond to ports of components [11]. Figure 19 shows the half adder circuit in the VHDL language, using its structural modeling capability.

Architecture STRUCTURE of HALF_ADDER is

component AND2 Port (x, y: in bit; End component; o: out bit);

component X0R2 Port (x, y : in bit; End component; o : out bit);

Begin Gl: AND2 port map (a, b, carry); sum) ;

G 2 : X0R2 port map (a, b, End STRUCTURE;

Figure 19: Half-adder Structural Model The model contains two declarations of other models, AND2 and X0R2, as well as two instantiations of the models, called Gl and G2. Additional information on the components AND2 and X 0R 2 is provided elsewhere. In this research the structural VHDL model of some combinational and structural benchmark circuits are used. A fault can easily be injected into the VHDL description of the circuit by just replacing one fault free component with a faulty one. All the fault free and faulty components are declared in a user-defined library which is added to WORK library of

52

th e V H D L codes as explained in C hapter 4. A s an exam ple, the G l instantiation in Figure 19 can be rep laced by the follow ing;

G l : A ND 2_ F1 port m a p

(a, b, carry);

F igu re 20: F au lty A N D 2 Instantiation T h e n ex t section describes the m ethod o f injecting faults into V H D L description o f a circu it an d a so lu tio n w ill be proposed to lim it the synthesis tim e and com plexity along the w ay.

5.3 F ault Injection in VH DL Description
D u e to th e evolution o f technology, the probability o f faults occurring in the field o f in teg ra te d circuits is noticeably increasing. Single E vent Effects (SEEs) such as Single E vent U psets (S E U s) o r Single E vent Latchup, w hich are noticeable sources o f failures in space ap p licatio n s, w ill becom e obvious sources o f collapses even at the sea level, for the next g en eratio n o f technology. T he interest in integrated on-line fault detection m echanism s and /o r fau lt to leran ce is therefore rapidly increasing for circuits designed in deep sub-m icron tech n o lo g ies. T herefore, there is an urgent need to evaluate circuit fault tolerance. A key issue in d esig n in g fault to lerant digital system s is the validation o f the design w ith respect to th e d ep en d ab ility requirem ents. T he final assessm ent o f the circuit including system dependability and reliability is classically ex ecu ted after m anufacturing o f the circuits using fault injection on a system pro to ty p e. I f th e prelim in ary analysis carried out during the circuit design w as n o t com plete, u n accep tab le b eh av io u r can be identified only at that stage. T he re-w ork o f the circuit im plies th e n v ery h ig h costs and a lot o f w asted tim e. It becom es therefore crucial, especially w ith th e ad v en t o f system s-on-chip, to perform a thorough analysis o f the failure m odes o f the circu it as early in th e design process as possible and at least before any m anufacturing. C lassical in jectio n techniques (e.g. pin-level fault injection, m em ory corruption, heavy-ion injectio n , p o w er supply disturbances, laser fault injection or softw are fault injection) all app ly o n a fab ricated circuit and cannot be used in this context [12]. B y contrast, som e

53

studies have proven that performing fault injection in high-level models of the circuit can be a practical approach to an early analysis of faulty behaviours [13,14]. More recently, several researchers proposed the application of fault injection early in the design process. The main approach consists in injecting the faults in high level descriptions (most often, VHDL models) of the circuit or system. Delong et al. [18] described, for example, the injection of faults in behavioural VHDL descriptions of microprocessor-based systems. The approach uses instruction-level models o f the processors. During simulation stuck-at faults are injected in the memory or in the processor registers, through a fault injection controller that is a module added to the initial description of the system. The injection process relies on specific data types and on the bus resolution functions; such an approach is therefore difficult to generalize for architectures that do not use tri-state buses. Another approach presented in [19], and then [13] or [20], is more general and considers the injection of different types of faults in the VHDL model of a circuit at several abstraction levels and using various techniques based on the modification of the initial VHDL description or on the use of simulation primitives. As mentioned in [16], the main drawback related to the use of simulation is the huge amount of time required to run the experiments when many faults have to be injected in a complex circuit. In-system emulation using hardware prototyping on FPGA-based logic emulation systems has also been proposed to consider the effects of the circuit environment in the application [15]. Another advantage expected from such emulation is to noticeably reduce the time needed for the fault injection experiments when compared to simulations [16]. Therefore, based on the discussion above and in Section 5.2, we have considered in this work fault injection into structural models written in VHDL, and FPGA-based hardware prototyping for early failure mode analysis of a complex digital circuit. When an FPGA-based emulator is used, the initial VHDL description must be synthesizable. In some cases, the approaches developed for fault grading using emulators (e.g. [21, 22]) may be used to inject faults. However, such approaches are classically limited to permanent stuck-at fault injection. Several specific approaches have therefore been recently considered [23-28]. In most cases, modifications are introduced in the circuit description.

54

In th e structural fau lt injection technique, a fault m odel was provided by replacing one m o d u le w ith another. T he replacem ent m odule is a predefined or user-defined m odule. Thus, this fau lt m odel is general enough to cover m any other fault m odels w hich affect the fun ctio n ality o f m odules. I f the replaced m odule is also synthesizable m odel synthesizability is n o t affeeted [17]. In this w o rk th e m odules for replacem ent are generated by m apping transistor level faults into g ate level form at. In other w ords, the replacem ent m odules are defined at the gate level u ser-d efin ed library w ith a synthesizable V H D L form at as show n in C hapter 4. The fault in jectio n tech n iq u e is b ased on replacing the fault free m odule in the initial system V H D L d escrip tio n w ith a faulty m odule from th e user-defined library. E xam ples o f this replacem ent are sh o w n in F igure 16 an d Figure 20. A lth o u g h th e tran sisto r level faults are injected in the initial structural V H D L description o f th e system b y u sin g faulty m odules, the synthesis tim e is high for m odifying large circuits. T o allev iate th is problem , a large circuit m ust be divided into sm all partitions. T hen one p a rtitio n is co n sid ered at a tim e w here faults are injected. T herefore, synthesis and im p lem en tatio n tim e is reduced because all partitions are synthesized and im plem ented only once, w h ereas th e p artitio n w ith injected faults is re-synthesized and re-im plem ented as m any tim es as th ere are faults. It should also be noted that the bitstream s o f the fault free partitions are g en erated an d dow nloaded into F PG A only once. T he bitstream o f the faulty partition m u st b e generated an d dow nloaded into FPG A several tim es depending o n the num ber o f faults to b e in jected into th e FPG A . In th e n ex t ch ap ter w e w ill introduce our m ethod o f partitioning w hich leads to a red u ctio n in d esig n synthesis tim e and com plexity.

55

Chapter 6 Binary Tree-based Partitioning Methodology
Partitioning is a common method for reducing the design complexity of a system. As system complexity increases, the timing problem plays an important role in the whole design process. The goal o f partitioning is to divide a complex system into small subsystems subject to balance constraints while minimizing interconnections among subsystems. Partitioning optimizations are critical to the synthesis of large-scale VLSI systems. In this chapter the advantage of using unbalanced partitioning over balanced partitioning will be discussed. Then, the methodology to apply a full binary tree to perform an unbalanced partitioning o f a circuit VHDL description will be described.

6.1 Balanced Versus Unbalanced Partitioning
A system has a balanced partitioning if all partitions are of nearly equal size, whereas unbalanced partitioning can be defined as a system with different sized partitions. The primary focus of this research is to reduce the synthesis time while injecting different types o f faults into FPGAs. To reach this goal the system is divided into small partitions where faults are injected in the desired locations. Thus, fault free partitions are synthesized once while the faulty partition is re-synthesized after modifying its structural VHDL description to inject different faults. Thus, if the faulty partition size is reduced the total synthesis time for injecting faults into that partition is also reduced. If, in a balanced partition circuit, N is the total number of partitions and Gt is the total number o f gates in the circuit, the size of each partition S(Pi) is;

56

S(PO = G t / N

W h e r e N > 1 and l < i < N

(6.1)

G is co n stan t fo r a specific circuit. T herefore, to reduce the size o f partitions th e total n u m b er o f partitio n s N m ust be increased. F igure 21 show s a balanced partitioned circuit w ith 5 p artitio n s w here faults are injected into P4. F igure 22 show s the graph related to this ty p e o f partitio n in g . In this case;

S(Pi) = S(P2) = S(P3) = S(P4) = S(Ps) =

G t

/5

(6.2)

In th is research w e also focus on m odule-based partial reconfiguration o f FPG A s. Partial reco n fig u ratio n involves defining a distinct portion o f an FPG A design to be reconfigured w hile th e rest o f th e device rem ains in active operation. These portions are referred as reco n fig u rab le m odules. T he partial reconfiguration flow utilizes a m odified form o f the m o d u lar d esig n process [29]. W e w ill expand m ore on this subject in the next chapter. In this w ork, th e reco n fig u rab le m odule is the partition w here faults are to be injected. T he low er the n u m b er o f m o d u les, the b etter th e m odule-based partial reconfiguration perform ance w ill be. T he reaso n is th at the com plexity o f the design process w ill increase due to follow ing factors: co m p lex ity o f d efin in g bus m a c ro s', having m ore constraints (local and global clock routing), d ifficu lt ro u tin g cau sed by th e fixed location o f bus m acros, and w asting device resources w h en sizes o f m odules are sm all. T hese factors are further explained in Section 7 .1.

PI

P2

P3

P4
. .  

P5

F igu re 21: B alanced P artitioning C learly, w h en using th e balanced partitioning m ethod there is a conflict between reducing synthesis tim e and reducing th e n um ber o f partitions. T he suggested m ethod to solve this
' B u s m a c r o s a re u s e d a s f ix e d d ata p a th s fo r sig n a l e x c h a n g e b e tw e e n a r e c o n fig u r a b le m o d u le and o th er m o d u le s .

57

problem is to divide the system into an unbalanced subsystem by applying full binary tree methodology which uses the iterative genetic algorithm with minimum ratio cut. This algorithm will be discussed in Section 6.3.

System

Subsystem s

P 4

P 5

Figure 22: Balanced Partitioning Graph Figure 23 shows an unbalanced partitioning for the total number of 5 partitions. First, the circuit is divided into two equal partitions. One o f these two partitions is called Pj. The other part is again divided into two equal partitions. This recursive process continues until 5 partitions are obtained. Figure 24 illustrates the graph format of this type of partitioning. Assume faults are injected into P 4 . By applying this method the size of P 4 is

considerably smaller than Pj, P 2 , and P 3 . Therefore, the synthesis time is lower than when all partitions are of equal size. Pi, P 2 , P 3 , and P 5 are synthesized once and P 4 is re-synthesized each time after modifying the P 4 structural VHDL code. Figure 24 is a part o f a full binary tree graph where each node is half the size of its parent node. The complete form o f a binary tree graph with depth level of 4 is shown in Figure 25. Faults can be injected into any of the 4`'' level partitions. Once one partition in the 4^ level is selected for fault injection, partitions from the higher levels are selected respectively in order to constitute an unbalanced partitioning in the system. To improve the module-based partial reconfiguration performance, fewer partitions are needed. There is no need for the partitioned system to contain all the 16 small partitions from the 4`'' level when faults are to be injected into only one partition. If we assume partition "LLLR" in Figure 25 is a selected partition in the 4^'' level for injecting the faults, the other partitions would be "LLLL", "LLR", "LR", and "R" (shown as gray circles in Figure 25) to create an unbalanced partitioning. In this approach nodes in the binary tree are selected vertically instead of horizontally.

58

F igu re 23; U nb alan ced P artitionin g

S y s te m

PI

P2

P3

P5

P4

F igu re 24: U n balanced P artitionin g G raph The relation betw een the sizes o f partitions in Figure 25 when faults are injected into "LLLR" is;

S(R) - 2S(LR) = 4S(LLR) = 8S(LLLL) S(LLLL) = S(LLLR) (6.3)

I f N is the total number o f partitions in an unbalanced partitioning method and G t is the total number o f gates in the circuit the size o f the sm allest partition S(P) is:

(6.4)

59

By comparing (6.1) and (6.4), it can be proven that the size of the smallest partition in the unbalanced partition is smaller than the size of the balanced partition. Consequently the synthesis time is less in unbalanced partitioned systems.

System

Level 0

Level 1 Level 2

LL LLR LLL

LR

Level 3

Level 4 LLLL LLLR LLRL LLRR

Figure 25: Full Binary Tree (Depth level = 4)

6.2

Binary Tree Approach
Binary trees are defined recursively. A binary tree is a structure defined on a finite set of

nodes that either · · contains no nodes, or is composed o f three disjoint sets of nodes; a root node, a binary tree called its left subtree, and a binary tree called its right subtree. The binary tree that contains no node is called the empty tree or null tree, sometimes denoted NIL. If the left subtree is nonempty, its root is called the left child of the root of the entire tree. Likewise, the root of a non-null right subtree is the right child of the root o f the entire tree. If a subtree is the null tree NIL, we say that the child is absent or missing. If a node in a binary tree has just one child the position o f the child- whether it is the left child or the right child- matters.

60

In a tree th a t results is a full binary tree, each node is either a le a f or has exactly a degree o f 2. T h e re are no d eg ree-1 nodes. C onsequently, the order o f the children o f a node preserv es th e po sitio n inform ation [31]. In th is research the full binary tree is generated based o n the m erge sort algorithm features. In o th er w ords every child in the tree has the h a lf size o f its parent and each child has th e sam e size as other children in the sam e level o f depth. The features o f the m erge sort alg o rith m an d its w orst-case running tim e are discussed in subsection 6.2.1. 6.2.1 A n a ly zin g M erge and Sort A lgorithm M an y useful algorithm s are recursive in structure. To solve a given problem , they call them selves recursively one or m ore tim es to deal w ith closely related su bproblem s. These algorithm s typically follow a divide-and-conquer approach. T hey b re ak th e problem into several subproblem s that are sim ilar to the original problem b u t sm aller in size, solve the subproblem s recursively, and then com bine these so lu tio n s to create a solution to the original problem . T h e divide-and-conquer paradigm involves three steps at each level o f the recursion: · · D ivid e th e problem into a num ber o f subproblem s. C on q u er the subproblem s by solving them recursively. I f the subproblem sizes are sm all enough, how ever, ju s t solve the subproblem in a straightforw ard m anner. · C om bine the solution to the subproblem s into the solution for the original problem . T he m erge sort algorithm closely follow s the divide-and-conquer paradigm . In tu itiv ely , it operates as follow s. · D ivide: D ivide the w-element sequence to be sorted into tw o

subsequences o f n/ 2 elem ents each. · · C onquer: Sort the tw o subsequences recursively using m erge sort. C om bine: M erge the tw o sorted subsequences to produce th e sorted answ er.

61

RYERS0K

IJ0PAW

When an algorithm contains a recursive call to itself, its running time can often be described by a recurrence equation or recurrence, which describes the overall running time o f a problem of size n in terms of the running time on smaller inputs. We can then use mathematical tools to solve the recurrence and provide limits on the performance of the algorithm. We reason out as follow to set up the recurrence for the worse-case running time of merge sort on n numbers, T(n) . Merge sort on just one element takes constant time. When we have n > 1 elements, we break down the running time as follows. · Divide: The divide step computes the middle of the subarray, which takes constant time c. · Conquer: We recursively solve two subproblems, each o f size n/2, which contributes 2T(n/2) to the running time. · Combine: The merge procedure on an «-element subarray takes time cn.

Therefore the recurrence for the worst-case running time T(n) of merge sort is:

T{n) = \ ^ \2 T {n l2 ) + cn

^ if n > \

(6.5)

Figure 26 shows how we can solve the recurrence (6.7). For convenience to simplify matters, we assume that n is an exact power of 2. Part (a) of Figure 26 shows T(n), which in part (b) has been expanded into an equivalent tree representing the recurrence. The cn term is the root (the cost at the top level of recursion), and the two subtrees of the root are the two smaller recurrences T(n/2). Part (c) shows this process carried one step further by expanding T(n/2). The cost for each of the two subnodes at the second level of recursion is cn/2. We continue expanding each node in the tree by breaking it into its constituent parts as determined by the recurrence, until the problem size is reduced to 1, each with a cost of a. Part (d) shows the resulting tree. Next, we add the costs across each level of the tree. The top level has total cost cn. In general the level i below the top has 2 ' nodes, each contributing a cost o f c(n/2' ), so that the zth level below the top has total cost 2' c(n/2 `) = cn.

62

T(n)

en

on

T(n/2)

T(n/2)

cn/2

T(n/4)

T(n/4)

T(n/4)

T(n/4)

(a)

(b)

(c)

on

- on

cn/2

cn/2

cn

Ign

cn/4

cn/4

cn/4

cn/4

cn

c

c

c

c

c

c

c

c

_____ ^ cn

n

(d)

Figure 26: The Construction of a Recursion Tree for the Recurrence T(n) = 2T(n/2) + cn

63

The total number of levels of the "recursion tree" in Figure 26 \slg n + 1 where

Ign stands for log2 n. To compute the total cost represented by the recurrence (6.5), we
simply add up the costs of all the levels. There are Ign +1 levels, each costing cn, for a total cost of cn (Ign + 1) --cnlgn + cn. Ignoring the low-order term and the constant c gives the desired result of 0(n* Ign) [31]. Therefore, the complexity of generating a full binary tree based on the merge sort algorithm is 0 (n*lg n).

6.3 Generating VHDL Full Binary Tree
We note that unbalanced partitions are extracted from a full binary tree. Each parent in the tree has two equally sized children. In other words, we generate a full binary tree based on the balanced partitioning method. In this research, we are using the genetic algorithm to divide each VHDL code of the parent node into two equally sized VHDL codes. The initial VHDL code is divided into two balanced partitions, "L'.vhd" and "R^.vhd" to create a binary tree. Each of these two VHDL codes is again divided into two balanced partitions which result in "LL.vhd", "LR.vhd", "RL.vhd", and "RR.vhd". This process continues until the proper depth level is reached. The depth level of the binary tree depends on the size of the partition and the limit for the cutset size between this partition and the others. The proper partition size, which depends on the application, results in an acceptable synthesis time. The cutset size limit depends on the type o f FPGAs since the reconfigurable module (the faulty partition) in the module-based partial reconfiguration communicates with other fixed modules by using a special bus macro. Bus macros are used as fixed data paths for signals going between a reconfigurable module and another module. Each bus macro provides 4 bits of inter-module communication signals. As many bus macros as needed must be instantiated to match the number of bits traversing the boundaries o f the reconfigurable module [29]. However, there is an upper boundary limit for the number of bus macros in each type of FPGA. This boundary limits the cutset size of the partition circuit. If the cutset size of the reconfigurable module is more than the maximum number o f bus macros of the specific device, the tree must go through deeper levels. For example, the maximum number of bus macros for XC2V1000 is 160 signals.

' L stands for left child ^ R stands for right child

64

A s prev io u sly m entioned, th e G enetic algorithm is used in this w ork in an attem pt to d ivide a V H D L code into tw o balanced partitions. T he evolutionary com putational approach (som etim es called a genetic algorithm ) represents the circuit as a chrom osom e. In a chrom osom e, each node is given a fixed index in an integer array; and the value at each index determ ines w h ich partitio n a node belongs to. For exam ple, i f w e w ished to place each circuit node in eith er P artition 0 or P artition 1, then the entire circuit configuration could be rep resen ted as a string o f ones and zeros called chrom osom es. A u n iq u e chrom osom e exists for every possible circuit configuration in the solution space. E a ch chrom osom e has a w eight that is determ ined by the size o f the cutset and how b alan ced th e circuit is. The best solution will have the low est w eight. In a circuit w ith 10 m illio n nodes, the size o f the solution space w ould be chrom osom es. U nfortunately,

finding th e b est so lution to such a problem w ould take years even by using the fastest com puters o f today. F o r this reason w e do not concern ourselves w ith trying to find the best solutions, b u t rather a good solution that is considered acceptable. In o rd er to solve the problem , an iterative approach is used. A series o f techniques called genetic m u tatio n and genetic crossover are applied to the chrom osom es for each iteration, resu ltin g in n e w offspring chrom osom es. The best chrom osom es are repeatedly m ated and evo lv ed u n til a solution w ith acceptable param eters is declared the w inner. O ne o f the p aram eters in this w o rk is to approach to the m inim um ratio cut. M inim um ratio cut seeks the p artitio n su ch th at (cost (A ,B ) / |A |.|B|) is m inim ized w here A and B are tw o disjoint p artitio n s [30]. T he (cost (A ,B ) / |A |.|B |) is m inim ized w hen A and B have an equal size. The w in n er w ill determ in e w hat th e final circuit configuration w ill look like, including in w hich p artitio n each node w ill be contained. T h e p artitio n in g p ro g ram is im plem ented by getting a V H D L file w hich describes the stru ctu ral config u ratio n o f the circuit. This configuration is converted into a directed h y p erg rap h , and from there into a clirom osom e. A fter the w inning chrom osom e is determ in ed , it is u sed to construct a V H D L representation o f the resulting partitioned circuit. T h e stru ctu ral V H D L codes b ased on full binary tree are generated and saved once for each circu it and th e result can b e used several tim es based on the unbalanced partition selections. F igu re 27 show s th e flo w o f the partitioning structural V H D L code.

65

Structural V H D L code

Converted into directed hypergraph representation

Binary tree partitioning using Genetic algorithm

Converted back into structural V H D L codes

Faults are injected in the V H D L codes o f last branches (exhaustively)

Figure 27: The Flow of Binary Tree Based Partitioning and Modification of the VHDL Code for Fault Injection

After generating the full binary tree of partitioned structural VHDL codes, the structural VHDL codes o f the last branches must be modified for faults injection based on the transistor to gate level library modules. The process of modifying the VHDL code to inject faults is done exhaustively, i.e. all possible faults in the library that can occur on each partition are injected into their respective VHDL codes one at a time (single fault) and then faulty VHDL codes are saved in a database. Based on the partition selection and the user fault list, relative faulty and fault free structural VHDL codes from the database can be synthesized and injected into the FPGA. The fault list might include either all possible faults that can occur in a selected partition from the last branches or specific faults. The next chapter will describe how to use the VHDL code database to automate the synthesis procedure according to the partition selection and the user fault list.

66

Chapter 7 Automating the Synthesis Procedure of ModuleBased Dynamic Partial Reconfiguration
F P G A s are extensively em ployed today for rapid system prototyping and in countless finished products. The m ain feature o f FPGAs is their ability to change the system 's hardw are structure in the field, a process known as reconfiguration. Device reconfiguration enables th e increm ental developm ent o f system s, the correction o f design errors after im plem entation, real tim e fault injections, and the addition o f new hardware functions. System s built w ith FPG A s can be reconfigured either statically or dynamically. A static reconfigurable system m ust be com pletely reconfigured each time any change o f the hardw are is required. In this case, system execution stops during reconfiguration. A dynam ic reconfigurable system (D RS) allows parts o f the system, referred to as reconfigurable m odules, be m odified, w hile the rest o f the system continues to operate [50]. In this research the intent is to apply dynam ic partial reconfiguration for fault injection into a portion o f a circuit. T herefore, certain portions o f the device can be reconfigured while the rest o f the deviee rem ains operational. These portions are referred to as reconfigurable modules. Styles and features o f partial reconfiguration will be discussed as well as the m ethod o f applying m odule-based partial reconfiguration for fault injection into FPGA. In addition, a presentation o f the autom ated process o f synthesizing system VHDL codes for the partial reconfiguration o f FPG A s w ill follow.

67

7.1 Partial Reconfiguration
By definition partial reconfiguration or local run-time reconfiguration is a form of reconfiguration which allows that only a portion of a system (e.g. DR FPGA device) to be reconfigured. A partial reconfiguration can be non-disruptive, i.e. the portions of the system, which are not being reconfigured remain fully operational during the entire reconfiguration cycle or disruptive, i.e. partial reconfiguration affects other portions of the system - typically need for a clock hold. Non-disruptive partial reconfiguration is often shorted to partial reconfiguration, as this form is more practical and common in today's DR FPGAs [51]. One o f the features o f partially reconfigured FPGAs is that the size o f the bitstream is proportional to the size of the reconfigured resources. Thus, as the size of the bitstream decreases, the speed o f the reconfiguration increases. This feature further clarifies why, in Chapter 6, we have concentrated on the unbalanced partitioning methodology to reduce the size o f the fault injected partition as much as possible. This partition has to be reconfigured each time after injecting a new fault. Therefore, its size has an important impact on the speed of fault injection. There are two main styles of partial reconfiguration; module-based and difference-based. The difference-based method of partial reconfiguration is accomplished by making a small change to a design, and then generating a bitstream based only on the differences between the two designs. This method is undesirable for injecting faults into a large circuit because after a small change in the initial structural VHDL code the whole circuit has to be re-synthesized, which is time-consuming. The module-based method is based on dividing a design into modules and reconfiguring only a few modules while the rest o f the design remains in active operation. The height o f an FPGA is predefined. In this method, the reconfigurable module height is always the full height o f the device and its width ranges from a minimum of four slices to a maximum o f the full-device width [29]. Thus, if a partition of a circuit assigned to a reconfigurable module does not fill the entire module predefined space the device resources will be wasted. Dividing the system into small partitions can also be a waste of resources.

68

To help m inim izing problem s related to design complexity, the num ber o f m odules should be m inim ized, so that less bus m acros are defined, leading to a m ore optim ized routing. T he reason is that as the location o f the bus macros are fixed, if a signal traversing the reconfigurable m odule to the other m odules is not near the location o f the bus m acros the com plexity o f routing w ill increase. This m ethod is w ell-m atched to our w ork because only the partition w here faults are injected is reconfigured. It has to be m entioned that due to unbalanced partitioning the m odule sizes are not equal. This m eans there will not be many small partitions, and thus we w ill avoid w asting the device resources. M odule-based partial reconfiguration flow is based on the m odular design m ethodology. Consequently, in order to clarify the m odule-based partial reconfiguration this m ethodology w ill be studied.

7.2 M odular Design
M odular design provides a divide-and-conquer im plem entation approach to m ulti-m illion gate F P G A designs available. Partitioning a design into smaller functional m odules reduces the com plexities o f design, im plem entation and verification. These sm aller m odules can then be brought th ro u g h the design flow independently. Once com pleted, a m odule's

im plem entation is preserved, guaranteeing the tim ing in the finished device. In other words, the basic idea underlying m odular design is to organize a com plex system (such as a large program or an electronic circuit) as a set o f distinct components that can be developed independently and then plugged together. M o d u lar design requires up-front planning to ensure that the design is partitioned properly. It also requires ensuring that partitions w ork together during the final assem bly phase. T his b reakthrough technology is em ployed in this research to utilize partitioned V H D L codes from th e database in Chapter 6 as a design entry, synthesize them and generate proper bitstream s for injection into the FPGA. T he M o d u lar D esign flow consists o f the follow ing phases:

69

7.2.1 Modular Design Entry and Synthesis Phase In this phase the module designs using HDL are created and synthesized individually. In this research the VHDL code of each module can be obtained from the full binary tree database explained in Chapter 6. Then the related VHDL code from the database must be synthesized. During synthesis, behavioural information in the HDL file is translated into a structural netlist and the design is optimized for a Xilinx device. A state of the art synthesis engine is required to produce highly optimized results with a fast compilation and quick turnaround time. To meet this requirement, the synthesis engine needs to be tightly integrated with the physical implementation tool and have the ability to proactively meet the design timing requirements by driving the placement within the physical device. In addition, cross probing between the physical design report and the HDL design code will further enhance the turnaround time [52]. Our experimental device in this project is Xilinx Virtexll (XC2V1000). To synthesize the VHDL codes we can use either Xilinx-supported third-party tools, which produce a design file in third-party netlist formats, the Xilinx synthesis tool, or Xilinx Synthesis Technology (XST) that produces a netlist in NGC format. In this work the XST synthesis engine is chosen. The reason is that XST progresses in each release, improving clock frequencies and decreasing area, as well as reducing run time and memory utilization. XST has been tuned to Virtex architectures, inferring many o f the architecture's specific primitives. Users have extensive control over inference capabilities and optimization techniques via global options and local attributes. Xilinx estimates the current language support covers at least 95% o f the constructs supported by other synthesis tools. Many of the unsupported constructs are infrequently used and/or have simple work-arounds. Also, many o f these constructs are not handled consistently by each synthesis tool. One tool may accept a construct in one way, another in a different way, and a third may flag a parsing error. In some situations, XST is actually more precise than other tools, requiring exact, complete descriptions when others allow incomplete or vague code. These are very common issues when moving code from one synthesis tool to another [53].

70

F or our purpose, X ST reads the entry file in VHDL format and creates an N G C file. N G C file is a netlist that contains both logical design date and constraints and can be read directly by N G D B uild. Figure 28 illustrates m odular design entry and synthesis flow.

Circuits VH DL D atabase Synthesis Libraries

VH D L

Synthesis (XST)

NGC (X ST netlist)

Figure 28: M odular Design E ntry and Synthesis Flow

7.2.2 M od u lar D esign Im plem entation Phase M odular design im plem entation includes the three phases described below. A fter th e final phase is com plete, the im plem ented design can be used to generate a bitstream [54]. 1. Initial budgeting phase: In this phase, the top level logic for the design is positioned. Properly positioning the logic in this phase is critical. Repositioning top-level logic later in the design process requires rerunning each phase o f the M odular design flow, in a time consum ing process. The objectives o f the initial budgeting phase are to position global logic, size and position each m odule on the target chip, position the input and output ports for each m odule, and budget initial tim ing constraints.

71

The first step in this phase is to run NGDBuild in initial budgeting mode. NGDBuild generates an NGD file with all o f the instantiated modules represented as unexpanded blocks. This NGD file cannot be mapped but can be used with the Constraints Editor, PACE or Floorplanner. The Constraints Editor is employed to assign timing constraints to the top-level design. PACE can position the I/O ports for the design on the targeted device. Floorplanner can be used to assign pin location constraints for the design. 2. Active module implementation phase; In this phase NGDBuild has to be run for each module. NGDBuild reads a netlist file in NGC format and creates a NGD file that contains both a logical description o f the design reduced to Xilinx Native Generic Database (NGD) primitives and a description o f the original hierarchy expressed in the input netlist. After generating a NGD file, it can be mapped, placed and routed. When a module is fully placed and routed and meets the desired timing constraints, it is published back for inclusion in the final design 3. Final Assembly phase: In this phase, the modules are assembled into one design by running NGDBuild in final assembly mode. NGDBuild creates a fully expanded design file that can be used for mapping, placing, and routing. After the design is completely routed, it is necessary to configure the device so that it can execute the desired function. This is done using files generated by BitGen, the Xilinx bitstream generation program. BitGen takes a fully routed file as input and produces a configuration bitstream, a binary file with a .bit extension. The BIT file contains all of the configuration information that defines the internal logic and interconnections o f the FPGA, plus device-specific information from other files associated with the target device. The binary data in the BIT file is then downloaded into the FPGAs memory cells, or used to create a PROM file.

72

7.3 Autom ating the Synthesis Procedure of Module-based Fault Injection M ethod
A s introduced in previous chapters, in order to inject faults into FPGAs, the initial circuit V H D L description m ust be divided into unbalanced partitions w ith respect to the full binary tree features. A ll fault free and faulty V HDL partitions o f a circuit are generated and saved in a database. E ach V H D L partition can be considered as a module entry to our m odular design. It m u st be noted that in m odular design, each m odule has its ow n directory. Synthesis o f each m o d u le entry has to take place in its m odule directory. Therefore, there will be as many m odule directories as there are partitions. For example, if one circuit is divided into five partitions, five directories w ill be generated. The VHDL code o f each partition will be copied from th e database to its respective directory. W e have used Perl scripts, developed in U nix OS, to autom ate the process o f generating directories, getting the appropriate V H D L entries from the database and applying XST on them . In this w ork the autom ation o f the synthesis procedure o f m odular design is im plem ented. In general, the Perl autom ated program has the follow ing steps:

S te p 1: A t the com m and line, get a circuit name from the user w hich is assigned to $ circuit_nam e variable. Figure 29 shows this part o f the Perl program.

print

"Enter a circuit name for injecting faults :\n

#assign entered circuit name to circuit_name variable. $ c i r c u it _n am e = <STDIN>;

Figure 29: C ircuit Nam e Assignm ent

S tep 2 ; C om pare $circuit_nam e variable with all circuit nam es w hose V H D L code already ex ist in the database. I f the entered circuit name does not exist in the database the error m essag e is printed and the u ser has to enter another circuit nam e supported by the

73

database. Circuits supported in this work are nine combinational and sequential benchmarks with difterent sizes and characteristics. These nine benchmarks are: CV7, ^27, C2670. ^j37g, C 7 % ^^73207, ancf^28^77.

Should the entered circuit name be among our nine benchmark circuits, the depth level of the full binary tree of the circuit will be printed on the screen and the user will be asked to choose a partition for fault injection. The selected partition is then assigned to $entered_branch variable. For example, assume the entered circuit name is S1238. The depth level of this circuit is equal to four. Figure 30 shows Step 2 of the Perl program for S1238.

i f ($circuit_name eq $sl238)

{
print "This circuit depth level is four. \n"; print "Please enter one of the tree branches where you want to inject faults.\n Example: LLLR \n $entered_branch = <STDIN>; $depth_level = 4 ;

}
Figure 30: S1238 Step 2 Step 3: As mentioned before, the depth level o f each circuit depends on the circuit size and bus macro limitation o f the FPGA device. The proper depth level for each circuit was determined during the database generation. In this step the $entered_branch variable is verified and expected to match the circuit depth level. Note that $entered_branch represents one o f the lowest level branches of the full binary tree. For instance, an error message is printed for SI 23 8 with depth level o f four, if the entered branch for injecting faults is "LLR" or "LLLLR". The reason is that "LLR" is one of the last branches o f the full binary tree with depth level o f three and "LLLLR" is one o f the last

74

branches o f the full binary tree w ith depth level o f five. Therefore, for S I 238 the length o f the entered bran ch is exactly four. Figure 31 show s this part o f the program for S1238.

while

(length^ $entered_branch
{

!= $depth_level)

print "What you have entered doesn't m atch the circuit depth level.\n";

print

"The circuit depth level is Please enter again: \n ";

($depth_l e v e 1 ) .

$entered_branch = <STDIN>;
}

Figure 31: V erifying the Entered Branch Length

Step 4: In this step the $entered branch is com pared to our branch nam es convention (the length o f $entered_branch was verified in Step 3). Each branch in the full binary tree can be addressed by som e "L " and "R " strings depending on its location. However, if the specified branch has characters other than "L" or "R " an error m assage will be printed. Figure 32 show s this kind o f verification.

@branch= s pl i t ^ (//,$entered_branch); $len= length $entered_branch; # for loop executed till final entered b r a n c h f o r ( $x=0;
{

is v a l i d ,

$x<$len;

$x++

)

$path= $ b r a n c h [$ x ] ; if
{

(($path ne "L")&&

($path ne "R"))

print

" this is not a valid branch.\n";

^ L e n g th is a fu n ctio n o f P erl lan g u a g e. It sim p ly returns th e num ber o f characters in a strin g variable. ^ S p lits u p a strin g an d p la c e s it in to an array.

75

print "

yor branch

name has to contain only \n";

'L' or 'R' characters. Please enter again: $entered_branch= <STDIN>; 0branch= split(//,$entered_branch); $x=(-l); # makes the for loop start form the

# beginning to verify the new entered branch
}

Figure 32: Verifying the Entered Branch Characters Step 5: Make a directory for the specified circuit. Step 6: Extract other partition names (fault free partitions) by using $enterd_branch variable, (entered branch variable represents a partition where faults are injected. Other partition names have to be extracted from the entered branch so that an unbalanced partition in the system is created. These partition names are assigned to @partition_names array. For example, if the entered partition for S I238 is "LLLR" the other partition names to create an unbalanced partitioning will be; "LLLL", "LLR", "LR", and "R". Figure 25 shows how this selection is determined. Step 7: Make a sub-directory inside the circuit directory (created in Step 5) for each member o f @partition_names array.

system ("mkdir -p $circuit_name/$directory_name"); Figure 33: Making a Partition Directory inside the Circuit Directory Step 8: Copy the related VHDL code of each partition from the database to the partition sub-directory.

system ("cp /opt/research/fault_injection/per1/VHDLcodes/$circuit name/$di rectory_name.vhd^

Database location o f the partition V H D L code

76

/opt/research/f ault_inj ect ion/peri/ $circuit_naitie/$directory na me/$directory_name,vhd") ;

F igure 34: Copy a Partition VH D L Code to Its Directory

Step 9: M ake sub-directories for a faulty partition according to the user fault list and copy th e related V H D L code inside each sub-directory (Step 7 and 8 are based on the fault free p artition directories). The fault list o f the user is read and different sub-directories are generated for the faulty partition based on the num ber o f faults. For exam ple. Figure 35 illustrates a fau lt list for partition "LLLR" o f S I 238. The list contains five different faults to be injected into the "LL LR " partition. Therefore, five sub-directories with different nam es have to be generated. In a m odule-based partial reconfiguration one o f these faulty sub directories are used at a tim e along w ith all other fault free sub-directories.

0 R 2 _ 8 7 \ 0 R 2 ^ FIO^, F25 AND3_22,AND3, F15, F32 I_2 02,INV,F4

Figure 35: An Exam ple o f Fault List for S1238

In this exam ple th e total num ber o f sub-directories in S I 238 circuit directory is nine. Four sub-directories are for fault free partitions ("LLLL", "LL R ", "LR ", and "R ") and five sub-directories for five existing faults in the fault list. The S I 238 directory is show n in Figure 36. . . /S1238/ S1238_Partition_LLLL/ S1238_Partition_LLR/ S1238_Partition_LR/ S1238 Partition R/
* In stan tiation o f th e O R 2 g a te in th e S 1238 _ P artition _L L L R .vh d . ^ G ate ty p e . ^ W an ted fa u lt fo r in je c tio n

77

S1238_OR2_87_F10/ S1238_0R2_87_F25/
S 12 3 8_AND3_2 2 _ F 1 5 /

S1238_AND3_22_F32/ S1238_I_202_F4/

Figure 36: S1238 Circuit Directory Step 10: Create a project file (.prj) inside each faulty and fault free sub-directories. This project file contains a list o f all components used inside a particular partition. By running XST for system synthesis, the project file will be used for adding the entire listed components in the project file to WORK library. This issue is discussed in Section 4.3.3. Step 11: To synthesize each sub-directory's VHDL code, XST can be run either in command line mode or from the Process window in Project Navigator. Due to the automated synthesis procedure, the command line mode is chosen here. To make the process completely automatic we create a script file (.scr) inside each sub-directory to store all required commands. The commands are extracted from the XST user guide [55] based on our requirements. For example, the script file for partition "LLLL" in S I238 is shown in Figure 37.

run -ifn* sl238_PARTITION_LLLL.prj -ifint^ mixed -ofh^ sl238_PARTITION_LLLL.ngc -ofmt" NGC -p^ xc2vl000-fg456-4

Input/Project file name Input project format. X ilin x suggests using m ixed form at w hether it is a real m ixed language project or not. Output file name Output file format Target technology

78

-top' s 1238_PA R T IT I0N _L L L L -iobuf ^ N o

Figure 37: S1238 Partition_L LL L XST Script File

A ll th e required files for synthesizing the circuit are now available in each partition sub directory. F igure 38 shows all available files inside S1238_Partition_LLLL sub-directory after running the Perl program . The Perl Program organizes and creates the necessary files inside each directory in the above steps.

../S1238/S1238_Partition_LLLL/ S1238_Partition_LLLL.vhd S1238_Partition_LLLL.prj x s t .scr

Figure 38: S1238 Partition LLLL Directory Files

T he X S T has to be executed in each sub-directory to synthesize the design. U sing a batch file w e o b tain th e xst. scr file as an input from each sub-directory o f the specified circuit. T hen a N G C file {.ngc) and a synthesis report in ` `` ' .lo g " form at is generated. The executed com m and is th e follow ing;

XST -ifn x s t .scr -ofn Synthesis_report.log

Figure 39: Executing the Script File (xst.scr) W e n o te th at at this stage all the faulty and fault free VHDL codes have been synthesized successfully. T he N G C files can be used to generate bitstreams in the second phase o f m odular design. T he synthesis report show s all details and considerations during the

'Top l e v e lblock name ^Add I/O buffers

79

synthesis process. It also shows the CPU time for synthesizing each partition. The experimental results o f nine benchmark synthesis procedures are presented in the next section.

7.4 Experimental Results
In order to observe the synthesis results o f classical and non-classical transistor fault models mapped to gate level for FPGA fault injection, nine combinational and sequential benchmark circuits with different sizes and characteristics have been selected. As mentioned previously, these circuits are: C17, S27, S298, S1238, C2670, S5378, C7552, S I 3207, and S3 8417. Figure 40 illustrates the total number o f gates for each circuit.

a No. gates
23815
24000 H

22000 20000
8 « " 18000 16000 14000

2 5
E Z

12000 10000
8000 6000 4000

11547

2000

13

133

0

Figure 40: Size of Circuits The unbalanced partitioning approach based on full binary tree characteristic is applied to these circuits. To determine the full binary tree depth level for each circuit, two factors are taken into account: the size of the last branches and the number o f inter-module connection signals. In this experiment, our target device is the Xilinx Virtexll (XC2V1000) FPGA. With this FPGA, the maximum number of signals that can traverse from the reconfigurable

80

partitio n to th e rest o f the circuit is 160 signals. The depth level o f each circuit full binary tree is show n in Figure 41. C ircuits C l 7 and S27 circuits are too small (less than 15 gates) and therefore do not require partitioning. Thus, their full binary tree depth level is zero, i.e. their respective full binary tree consists only o f one node. A lthough S298 is not a big circuit either, the num ber o f inter-m odule signals exceeds 160 signals for depth levels less than two. For other circuits we first decided to have the size o f last branches partitions less than 200 gates to have a small and acceptable re-synthesis tim e and then verified that the inter-m odule signals are less than 160 as discussed in C hapter 6. In m ost cases the num ber o f signals going from the reconfigurable m odule to the rest o f the circuit exceeds the limitation. Hence w e increase the depth level to satisfy all constraints.

a Depth level
10 9 8

_©

5

7 6 5 4 3 2 1 0

B Q. a >
O

Figure 41: Full Binary Tree Depth Level o f Circuits A fter finalizing the depth level o f each circuit full binary tree, the V H D L database for each b in ary tree is generated and saved. For fault injection, one partition {Pj) from the last branches o f each circuit's full binary tree is selected and its faulty V H D L codes are fetched from the database according to a provided fault list. The results o f re-synthesis tim e o f the

81

selected partition where faults are injected into the FPGA for each circuit are monitored (see Figure 42). It has to be mentioned that all timings in this research are calculated based on the CPU time. We found that the re-synthesis time is constant for all circuits. The reason is that sizes o f last branches o f full binary tree partitions in all the circuits are almost the same based on their decided depth level. For example, last branches full binary tree partition size for S38417 is 46 gates with the depth level o f 9. This size is equal to 45 gates for S I3207 with depth level o f 8. It can be concluded that the depth level of the full binary tree with respect to its limitations can be determined based on the desired re-synthesis time.

Re-synthesis time of Pf

u o o .E t« w < D £ c > » «? o q :
*2.

c o

0 C17 Re-synthesis time of Pf 4.58 827 4.56 8298 4.76 81238 4.74 C2670 4.78 S5378 4.69 C7552 813207 838417 4.76 4.71 4.86

Figure 42: Re-synthesis Time of the Faulty Partition To configure the FPGA all partitions must be synthesized. Figure 43 shows the added synthesis time of all partitions in each circuit. It can be seen that the synthesis time increases linearly as a function o f circuit size, whereas by applying the unbalanced partitioning approach the whole circuit is not re-synthesized when faults are injected only to one portion. For instance, by adding the synthesis times of all partitions in S I3207, we have found that synthesizing the whole circuit takes 165.85 seconds. However reconfiguring the device for injecting faults requires only 4.7 seconds re-synthesis time.

82

900

800 700 600 Î2. 0 > 500 E F 400
(0

i

'8 300
to

>. 200 100
0

0

5000

10000

15000
Size of Circuit

20000

25000

30000

F ig u re 43: B en c h m a rk s S ynthesis T im e

F igure 44 show s the synthesis tim e o f each partition in circuit S3 8417 as a function o f partition size. A ssum e faults are going to be injected in to the "LLLLLLLLR" partition o f a full binary tree w ith depth level o f nine. Therefore, to establish an unbalanced partitioning, specific branches o f th e full binary tree m ust be selected. This selection is shown in Figure 45. T able 25 gives the approxim ate size o f each partition.

83

Synthesis time 600 500 400 300
200
100

2000

4000

6000

8000

10000

12000

14000

Size of Partition

Figure 44: S38417 Partition synthesis time

R LR LLR LLLR LLLLR LLLLLR LLLLLLR LLLLLLLR LLLLiLLLLL LLLLLLLLR

Figure 45: Partition Selection of a Full Binary Tree (Depth level = 9)

84

Partition Name R LR LLR LLLR LLLLR LLLLLR LLLLLLR LLLLLLLR LLLLLLLLR LLLLLLLLL

N um ber of Gates 11908 5954 2977 1488 744 372 186 93 46 46

T able 25: S38417 Partition Size I f w e w anted to o btain the sam e re-synthesis tim e through balanced partitioning partitions w ould be required, w hereas, for unbalanced partitioning only {depth level -- 1) partitions w ould be necessary. The total num ber o f partitions for the balanced and unbalanced partitioning is show n in Figure 46.

600 1 g 500 o i 400 -No. balanced · No. Unbalanced
-

< D a
3 z 200

E

I

100

-

0

5000

10000

15000

20000

25000

Size of Circuit

F igure 46: U nbalanced Versus Balanced Partitioning

85

It can be seen that the complexity o f modular design increases when a balanced partitioning is applied as discussed in Chapter 6. The minimum cost function (y) of unbalanced partitioning approach depends on the size o f the partition S(P^, and the total number o f partitions {N). The minimum cost function can be summarized in (7.1) where K is a constant.

(7.1)

The synthesis analysis o f classical and non-classical transistor fault models is done in a timely manner by using the proposed partitioning approach.

86

Chapter 8 Conclusion
In recen t years, there has been a grow ing interest in techniques for validating the fault tolerance properties o f safety and m ission critical system s and for an evaluation o f their reliability. F ault injection is a validation technique o f fault tolerance system s, in w hich the observation o f the system behaviour in the presence o f faults is explicitly forced by the introduction o f faults. W ith the advent o f system -on-chip, it is crucial to perform a thorough analysis o f the failure m odes o f the circuit before manufacturing. To inject faults into a system an accurate fault m odel, a proper approach for injecting faults, and adequate test patterns to observe the system b ehaviour is required.

8.1 Research Contribution
The transistor fault m odel is m ore accurate than the gate level fault model. Hence, to obtain an accurate fault m odel our intent was to use the transistor level fault model. The transistor level fault m odel how ever cannot be synthesized in FPGA chips. Therefore, we have opted for the solution where all classical and non-classical faults o f static CM OS cells are m apped to gate level. A specific fault pattern for each prim itive gate was determ ined during th e m apping. To access these m apped faults a user-defined library was defined and used in structural V H D L code. By replacing a fault free com ponent with a faulty one from the user-defined library in a structural V H D L code, faults were injected into the system V H D L code.

87

To reduce the re-synthesis time after injecting each fault, an unbalanced partitioning approach based on the full binary tree was introduced in this research. In this approach the re-synthesis time is reduced because the size of the partition where faults are injected is reduced by the partitioning. However, other fault free partitions have larger sizes since they do not need to be re-synthesized after each fault injection. In this case, the total number of partitions in a system is much less than balanced partitioning method. Therefore, the complexity o f module-based partial reconfiguration is reduced. Module-based partial reconfiguration was applied in the process of fault injeetion into FPGAs. We have also automated the generation of all required files prior to synthesis as well as the synthesis procedure itself. Although the VHDL code database, wherein faulty and fault free VHDL partition codes reside, takes a large memory space, the experimental results have shown that unbalanced partitioning approach saves time and FPGA resources in module-based partial

reconfiguration. We have shown that the re-synthesis time can be kept quasi constant in all circuits o f different sizes if the sizes of the partitions where faults are injected {Pj) are the same. Whereas, the synthesis time o f the whole circuit grows linearly as the size o f the circuit is increased. We have compared the unbalanced and balanced partitioning approaches and shown that the former leads to a more cost-efficient fault injection method.

8.2 Future Work
More research is needed to include dynamic CMOS faults in the user-defined library. To reduce the memory space taken by the database, partitioned VHDL codes will have to be generated based on the selection o f binary tree branches. Also, the implementation phase o f the module-based partial reconfiguration and downloading bitstreams into FPGA will have to be automated. The actual behaviour of faulty circuits can be studied in the application environment by applying adequate test vectors.

88

Appendices
Appendix A: ORn Complete Fault List Pattern
· In p u t/O u tp u t Stuck-at Faults
In pu t/oiitp ut stuck-at-faults
li : stu ck -a t-0 li : stu c k -a t-1 O : stu ck -a t -0 (fo r an y input co m b in a tio n s) O : stu ck -a t - 1 (fo r an y input co m b in a tio n s)

Faulty Ôûtput fO y
O R ( lu 12 ··*» li-U 1 0 1

In )

T able 26: O Rn Input/O utput Stuck-at-faults

vcc

Di-1

VCC

O'p

'n+1

O'n
Q n+1 IIN -----Sn +i
Qn-ti ··· InN

Figure 47: ORn Transistor Level

89

·

Short Faults
Short faults
0 (D,,) > G (ground) 0 ' ( D ,, ) ^ ^ VCC D j G ( 1< i< n -l)

Inputs conditions
For any input combinations For any input com binations For any input com binations lj= 0 V l < j < n (m eans all inputs from Ii to I,, are low )

Faulty output (0 )
1 0 1 0

D , < r^ VCC ( 1 < i <n-l)

Ij = 0 ( V i + l < j <n) &

Stuck-On 1 0 X 1 !Ii 1 NOT(Ii) 1 0 Stuck-On 1 0 Stuck-On 1 li

1, 1 1 12II...II

I i -1 For the rest o f input com binations

l i =0 V 1< ) <n Ij Ik where l < k < n and k 7 ^ i lj= 0 ( V & l < k <n and j 7 ^ i, j T^k)

li © Ik=l For the rest o f input com binations li > Dk ( i< k < n-l) (l<i<n-l) li ^ Dn (l<i<n) li 4 - ^ D k ( 1 < k < i - l ) lj=<0|l> Vl<j<k, li=0 Vk+l<j<n For the rest o f input com binations For all input com binations For any input com binations l i = 0 V l< i< n D i ^ ^ Dk ( l < k < n - l andk^fi): Ij=0(V & l< j< i and m < j <n ( i + l < m < n - l ) )

Ill|l2ll-.||Ii=l For the rest o f input com binations F,=0 V l< i< n Ij = 0 ( V l < j < i ) &

D i ^ ^ D,,( 0 ') ( 1 < i< n -l)

b + l II Ii+2 I I - - - I I l n = l
For the rest o f input com binations

li 0 ( 1 < i < n) 0 ( 1 < i< n -l)

For all input com binations (Ij=0 ( V i+ l<k^)& (I.||l2l|...||Ii=l))

II
(lj=0 V l< i< n ) For the rest o f input com binations

Stuck-On 1 N O R (I,, I2    , In)

0 '( D .) < - ^ 0

N /A

Table 27: O R n Short Faults

90

O pen Faults

O p e n f a u lts liP : op en ( 1 < i < n) Si: o p e n ( 1 = 1 ) Di: op en ( 1 < i < n) liN : o p e n ( 1 < i < n) li : op en ( 1 < 1 < n) Si: o p en (n+1 < i < 2 n ) Di: o p en (n+1 < i < 2 n ) O 'p: op en Si: o p e n ( i = 2 n + l ) Di: o p e n ( i = 2 n + l ) O 'n : op en Si: o p en ( i = 2 n + 2 ) Di: op en ( i = 2 n + 2 ) 0 ':open O:open

L o g ic a l f a u l # # # lip: stu c k -a t-1

liN: stuck-at-0

O 'p: stuck-at - 1

O ' n : stuck-at-0 Z Z

T a b le 28: O R n O p en F au lts C ategories

L ogical fault type o f open faults lip: stu c k -a t-1

Inputs conditions
l j = 0 ( V 1< J <n) F or all other input co m b in a tio n l j = 0 V 1 < i <n

Faulty ou fb ut (O )

Z
1 0

liN: stu ck -a t-0

Ij = 0 ( V 1< k <n and &

)

z
1
0

Ii=l For the rest o f input co m b in a tio n s O 'p: stu c k -a t-1 O 'n -' stu ck -a t-0 l i = 0 ( V 1< j <n) For the rest o f input co m b in a tio n s h = 0 ( V 1< i <n) F or the rest o f input co m b in a tio n s F or any in pu t co m b in a tio n s

z z
1

Z

z

T a b le 29: O R n O p en F au lts

The general form ula for total num ber o f faults for ORn is:
n-\

2 ^ ( n - J ) + n^ + 1 2 n + l l
y= i

(A T )

91

Appendix B: ANDn Fault Pattern
· Input/Output Stuck-at Faults
In p u t/ou tp u t stu ck -a t-fa u lts Ij : stuck-at-0 Ij ; stuck-at-1 0 ; stuck-at-0 (for any input com binations) 0 : stuck-at-1 (for any input com binations) F a u lty o u tp u t (O ) 0 A N D (Ii, 0 1 li-i, In)

Table 30: ANDn Input/Output Stuck-at-faults

VCC

vcc
Sn-i-i

m +
Dn+1

!n+ :
Dn+i

C bn+2

+

2

S i- 1

liN -------

Qi

S n-1

InN

HE?

Figure 48: ANDn Transistor Level

92

·

Short Faults
S h o r t f a u lts O ' <--> G O' VCC F a u lt y 1 0 I S tu ck -O n 0 0 1 X 0 0 N O T (li) 0 I S tu ck -O n 0 1 S tu ck -O n 0 li NOT(li)

F or an y input co m b in a tio n s For an y input co m b in a tio n s Ij=l V l < j <n Ij = 1 ( V l < j <i) & (li+l & Ii+2& ...& In=0) F or the rest o f input co m b in a tio n s F or any input co m b in a tio n s I j = l V 1< j < n

Sj <--> G ( 1 < i< n -l)

Si

V C C (1 < i < n - l )

li <--> Ik w h ere 1 < k < n an d k 4^ i

Ij=l ( V l < k < n a n d j ^ i,j v ^ k ) & h © Ik=l F or th e rest o f input com b in ation s

li

^ Sk ( i < k < n - l )

For an y input co m b in a tio n s Ij=l V l< j< k , l j = < 0 | l > V k + 1 < j <n F or all other input co m b in a tio n s Ii = l V l < j < n Ij= 1 ( V l < j < i and m < j <n ( i + l < m < n - l ) ) & (Ij+i & Ii+2&.. .&Im" 0) F or the rest o f input co m b in a tio n s Ii = l V l< j< n

li Sk ( 1 < k < i-l)

Si Sk ( l < k < n - l and k ^ i):

S i< e-» O ' ( 1 < i < n -1)

Ij = 1 V ( i + l < j <n) & (Il & I 2 & . ..& Ii = 0) For the rest o f input co m b in a tio n s F or all input co m b in a tio n s For all input co m b in a tio n s (Ij- 1 ( V l < j < i ) & ( l i + , & I i + 2 & - - - & I n = 0 ))

Ij ^ ^ O ( 1 < i< n ) li O' ( 1 < i < n) Si ^--> O ( 1 < i< n -l)

S tu ck -O n ( I i= I V I < i <n) F or the rest o f input co m b in a tio n s F or an y input co m b in a tio n s 0 N A N D ( I |, I 2 In )

O'

O

T a b le 3 1 : A N D n S h o r t F a u lts

93

Open Faults

Open faults
liP ; open ( 1 < i < n) li : open ( 1 < i < n) S{: open (n+1 < i < 2n) D{: open ( n+1 < i < 2 n ) liN : open ( 1 < i < n) Si: open (1 < i < n ) Di: open (i = 1) O 'p: open S|: open ( i = 2 n + l) Di: open ( i = 2 n + l ) O 'n : open Sj: open ( i = 2 n+ 2 ) Dj: open ( i =2n+2) 0 ':open 0 : open

Logical fault type
lip: stuck-at-1

liN: stuck-at-0

O 'p: stuck-at - 1

O 'n : stuck-at-0 Z Z

Table 32: ANDn Open Faults Categories

Logical fault type o f open faults

Inputs conditions
lj=l V l < j <n Ij=l ( V l < j < n and j?^i) & li= 0 For the rest o f input com binations lj=l V l < j <n For the rest o f input com binations f = l ( V l < j <n) For the rest o f input com binations 1|=1 ( V l < j <n) For the rest o f input com binations For any input com binations

Faulty output (O)
1 Z 0

lip: stuck-at-1

liN: stuck-at-0
O 'p: stuck-at - 1

z
0

z
0 1

O'n: stuck-at-0
Z

z z

Table 33: ANDn Open Faults

The general formula for total number of faults for ANDn is: j ) + ' ^ ( n - k ) + n^ +13n + 10
y=i fc=2

(B.l)

94

Appendix C: Buffer Fault list
· Input/O utput Stuck-at Faults
Thput/output stuck-at faults I: stuck-at-0 I : stuck-at-1 0 : stuck-at-0 O: stuck-at-1 Faulty output ( 0 ) 0 1 0 1

T able 34: Buffer Input/O utput Stuck-at-faults Short Faults Short faults
0 '< r ^ I O X -A O vcc 0 G O

Faulty output
NOT(I) NOT(I) 0 1 I

Table 35: B uffer Shore Faults

VCC

vcc
O'p

O'n

Figure 49: B uffer T ransistor Level

95

Open Faults
O pen fau lts I: open Ip: open In ; open D,: open Dj! open D3; open D4; open S].- open S2: open S3: open S4: open O ': open In p u t con d ition s F a u lty o u tp u t

N/ A 1= 0
1= 1

Z Z

1=0 1 =1 1=0 1=1 1=0 1=1
1= 1= 1= 1= 1= 1= 1= 1= 1= 0 1 0 1 0 1 0

n0
z
z

1

1

0 z 0 z z
1

z
1

1
0

0 z 0

1=1 1= 0
1=1

z z
1

For any I
1= 0 1=1 1= 0 1=1

z
0

O'p: open
O 'n : open 0 : open

z z
1

For any I

z

Table 36: Buffer Open Faults The total number o f faults for buffer is: 24

96

Bibliography
[1] M .A bram ovici, M .A. Brener, A.D. Friedm an, Digital System Testing A nd Testable D esign, R evised Edition, IEEE Press, 1990.

[2]

C.W .

W u,

Lab

for

Reliable

Com puting (LaRC),

EE,

N TH U ,

(http://larc.ee.nthu.edu.tw /~cw w /n/625/6250/02.pdf), 2002.

[3] J. A lt, U. M ahlstedt, Sim ulation o f N on-classical Faults on the Gate Level M odeling, 11* V LSI Test Sym posium , A pril 1993, pp. 351-354.

-- Fault

[4] R .D . Eldred, Test Routines B ased on Sym bolic Logical Statements, Journal A C M , V ol.6, N o .l, 1959, pp.33-36.

[5] S.A. A rian, D.P. A graw al, Physical Failure and Fault M odel o f CM OS Circuits, IEEE T ransactions on C ircuit and System s, Vol. CAS-34, No. 3, M arch 1987, pp. 269-279.

[6] J. G alaiy, Y. Crouzet, M. V ergniault, Pphysical Versus Logical Fault M odels M GS LSI circuits: Im pact on their Testability, IEEE Transactions on computers. Vol. C-26, June 1980, pp. 527-531.

[7] S.D . Brow n, Z.G. V ranesic, Fundam entals o f Digital Logic w ith VH D L Design, M cG raw -H ill, 2000.

[8] J.F. W akerly, D igital D esign Principles & Practices, Third Edition, Prentice Hall, 2002.

[9] http://tech-w w w .inform atik.uni-ham burg.de/applets/cm os/cm osdem o.htm l

[10] Z. N abavi, V H D L A nalysis and M odeling o f Digital Systems, Second Edition, M cG raw H ill, 1998.

97

[11] G.D. Micheli, Synthesis and Optimization o f Digital Circuits, McGraw-Hill, 1994.

[12] R. Leveugle, Fault Injection in VHDL Descriptions and Emulation, Proceedings o f the IEEE International Symposium on Defect and Fault Tolerance, Oct. 2000, pp. 414-419.

[13] S. Svensson, J. Karlsson, Dependability Evaluation o f the THOR Microprocessor Using Simulation-Based Fault Injection, Technical report NO. 295, Chalmers University of Technology, Department o f Computer Engineering, Sweden, 1997.

[14] E. Jenn et al. Fault Injection into VHDL models; the MEFISTO tool, FTCS, 1994, pp.66-75.

[15] E.Bohl, W. Harter, M.Trunzer, Real Time Effect Testing of Processor Faults, 5th IEEE International On-Line Testing Workshop, July 1999, pp. 39-43.

[16] R.Leveugle, Towards Modeling for Dependability of Complex Integrated Circuits, IEEE International On-Line Testing Workshop, Rhdes, Greece, July 1999, pp. 194-198.

[17] H.R. Zarandi, S.G. Miremadi, A. Ejlali, Dependability Analysis Using a Fault Injection Tool Based on Synthesizability o f HDL Models, Proceedings of the 18th IEEE International Symposium Defect and Fault Tolerance in VLSI System, pp. 485-492, 2003.

[18] T.A. Delong, B.W. Johnson, J.A. Profeta III, A Fault Injection Technique for VHDL Behavioral-Level Models, IEEE Design and Test of Computers, Vol. 13, Winter 1996, pp. 24-33.

[19] E. Jenn, J. Arlat, M. Rimen, J. Ohlsson, J.Karlsson, Fault Injection into VHDL Models: The MEFISTO Tool, 24* Symposium on Fault-Tolerant Computing (FTCS), 1994, pp. 6675.

98

[20] J.B oue, P. Petillon, Y. Crouzet, M EFISTO-L: A V H D L-B ased Fault Injection Tool for the E xperim ental A ssessm ent o f Fault Tolerance, 28^*' Sym posium on Fault-Tolerant C om puting (FTCS), 1998, pp. 168-173.

[21] K.T. C heng, S.Y. Huang, W.J. Dai, Fault Emulation: A N ew M ethodology for Fault G rading, IE E E Transactions on C om puter-A ided Design, Vol. 18, No. 10, 1999, pp. 14871495.

[22] R .W . W id e r, Z, Zhang, R.D. M cLeod, Em ulating Static Faults Using a X ilinx Based E m ulator, IEEE Sym posium on FPGAs for Custom Com puting M achines, February 1995, pp. 110-115.

[23] L. A ntoni, R. Leveugle, B. Feher, U sing Run-Tim e Reconfiguration for Fault Injection in H ardw are Prototypes, IEEE International Sym posium on Defect and Fault Tolerance in V L SI System s, Y am anashi, Japan, October 2000, pp.405-413. IEEE Com puter Society Press, 2000,

[24] L. A ntoni, R. Leveugle, B. Feher, U sing Run-Tim e R econfiguration for Fault Injection in H ardw are Prototypes, the 17*'' IEEE International Sym posium on Defect and Fault T olerance in V L SI System s, Vancouver, Canada, 2002, IEEE C om puter Society Press, 2002, pp. 242-249.

[25] P. C ivera, L.M acchiarulo, M. Rebaudengo, M. Sonza Reorda, M. Violante, Exploiting F P G A fo r A ccelerating Fault Injection Experim ents, 7*'' IEEE International On-Line Testing W orkshop, Taorm ina, Italy, July 2001, pp.9-13.

[26] P. C ivera, L.M acchiarulo, M. Rebaudengo, M. Sonza Reorda, M. Violante, Exploiting F P G A -B ased Techniques for Fault Injection Cam paigns on VLSI Circuits, IEEE

International Sym posium on D efect and Fault Tolerance in VLSI Systems, San Francisco, C alifornia, U SA , O ctober 2001, IEEE C om puter Society Press, 2001, pp. 250-258.

99

[27] P. Civera, L.Macchiarulo, M. Rebaudengo, M. Sonza Reorda, M. Violante, FPGABased Fault Injection for Microprocessor Systems, Asian Test Symposium, November 2001, pp.304-309.

[28] R. Leveugle, A Low-Cost Hardware Approach to Dependability Validation of IPs, IEEE International Symposium on Defect and Fault Tolerance in VLSI Systems, San Francisco, California, USA, October 2001, IEEE Computer Society Press, 2001, pp. 242-249.

[29] Two Flow for Partial Reconfiguration: Module Based or Difference based. Application Note: Virtex, Virtex-E, Virtex-II, Virtex-II Pro Families, XAPP290 (v l.l), Xilinx, 2003.

[30] S.M. Sait, H. Youssef, VLSI Physical Design Automation Theory and Practice, World Scientific, 1999.

[31] T.H. Cormen, C.E. Leiserson, R.L. Rivest, C. Stein, Introduction to Algorithm, Second Edition, Me Grow Hill, 2002.

[32] M.E. Zaghloul, D. Gobovic, Fault Modeling for Physical Failure for CMOS Circuits, IEEE International Symposium on Circuits and Systems, ISCAS'88, June 1988, pp. 677-680.

[33] P. Dahlgren, P. Liden, A Fault Model for Switch-Level Simulation of Gate-to-Drain Shorts, 14^'' Proceedings of VLSI Test Symposium, 1996, pp.414-421.

[34] M.E. Zaghloul, D. Gobovic, Fault Modeling of Physical Failure in CMOS VLSI Circuits, IEEE Transactions on Circuits and Systems, Vol. 37, No. 12, December 1990, pp. 1528-1543.

[35] M.L. Flottes, C. Landrault, S. Pravossoudovitch, Fault Modeling and Fault Equivalence in CMOS technology, Proceedings of the European Design Automation Conference, ED AC, March 1990, pp. 407-412.

100

[36] D .P. M ilovanovic, V.B. Litovski, Fault M odels o f CM OS Circuits, M icroelectronics R eliability Journal, Vol. 34, N o. 5, 1994, pp. 883-896.

[37] V .Sieh, O. Tschache, F. Balbach, VERIFY; Evaluation o f Reliability U sing VFIDLM odels w ith Em bedded Fault D escription, Proceedings o f 27^"' International Sym posium on Fault-T olerant Com puting, 1997, pp. 32-36.

[38] P. Folkesson, S. Svensson, J. Karlsson, A Com parison o f Sim ulation Based and Scan chain Im plem ented Fault Injection, Proceedings o f 28* International Sym posium on FaultT olerant C om puting, 1998, pp.284-293.

[39] P.C ivera, L.M acchiarulo, M . Rebaudengo, M .Sonza Reorda, M .V iolante, Exploiting C ircuit E m ulation for Fast H ardness Evaluation, IEEE Transaction N uclear Science 48, 2001, p p .2 2 10-2216.

[40] R. Leveugle, B ehavior M odeling o f Faulty Com plex VLSIs: W hy and H ow ?, Baltic E lectronics Conf. Tallinn, E s to n ia ,, O ctober 1998, pp. 191-194.

[41] R .sedaghat-M am an, Fault Em ulation with O ptim ized A ssignm ent o f Circuit N odes to F ault Injectors, Proceedings o f the 1998 IEEE International Sym posium on Circuit and System s, ISC A S '9 8 , 1998, pp.135-138.

[42] R. Sedaghat-M am an, E. Barke, A N ew A pproach to Fault Em ulation, Proceedings o f 8* IEE E International W orkshop on R apid System Prototyping, June 1997, pp. 173-179.

[43] J.H . H ong, S.A. H w ang, C.W W u, A n FPGA-Based Hardware Em ulator for Fast Fault E m ulation, IEE E 39* M idw est Sym posium on Circuit and Systems, Vol. 1, A ugust 1997, pp.345-348.

101

[44] T J. Chakraborty, C.H. chiang, A Novel Fault Injection Method for System Verification Based on FPGA Boundary Scan Architecture, Proceedings of International Test Conference, 2002, pp.923-929.

[45] S.A. Hwang, J.H. Hong, C.W. Wu, Sequential Circuit Fault Simulation Using Logic Emulation, IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems 17, 1998, pp. 724-736.

[46] R. Sedaghat-Maman, E. Barke, Real Time Fault Injection Using Logic Emulators, Proceedings Asia and South Pacific Design Automation Conference, 1998, pp.475-479.

[47] L.Antoni, R.Leveugle, B.Feher, Using Run-time Reconfiguration for Fault Injection Applications, IEEE Transactions on Instrumentation and Measurement, Vol. 52, No. 5, October 2003, pp. 1468-1472.

[48] A. Ejlali, S.G. Miremadi, FPGA-Based Fault Injection into Switch Level Models, Elsevier Microprocessors and Microsystems journal, 2004, pp.317-327.

[49] www.eg3.com/eCLIPS/desc/soc_vhdl_blank.html

[50] F. Moraes, N. Calazans, L. Mbller, E. Briao, E. Carvalho, Chapter 1: Dynamic and Partial Reconfiguration in FPGA SoCs: Requirements Tool and a Case Study, Pontificia Universidade Catôlica do Rio Grande do Sul (PUCRS), Brazil.

[51] http://dec.bournemouth.ac.uk/drhw_lib/terminology.html

[52]

W W W . Xilinx.com/products/design_resources/design_tool/grouping/synthesis.htm

(Xilinx: Synthesis)

[53] www.xilinx.com/xlnx (Techtips: xilinx synthesis technology)

102

[54] X ilinx D evelopm ent System Reference Guide, (http://toolbox.xilinx.eom /docsan/xilinx6/books/data/docs/dev/dev0001_L htm l)

[55] X ilinx X S T U ser G uide, http://toolbox.xilinx.eom /docsan/xilinx6/books/data/docs/xst/xst0001_l.htm l

Publications: 1. R. A bedi, R. Sedaghat, Transistor-level to G ate-level Com prehensive Fault Synthesis for «-Input Prim itive G ates, A ccepted w ith R evision by M icroelectronics Reliability Journal, ELSEV IER. 2. R. A bedi, R. Sedaghat, Synthesis o f Transistor Level Fault Em ulation, Subm itted to M icroelectronics Journal, ELSEVIER. 3. R. A bedi, R. Sedaghat, Classical and N on-classical Transistor Level Fault Injection into FPG A , Subm itted to W SEA S Journal. 4. R. A bedi, R. Sedaghat, Synthesis o f Exhaustive CM OS Transistor Fault M odel at G ate Level for «-Input Prim itive Gates, Subm itted to A SP-D A C Conference.

103


