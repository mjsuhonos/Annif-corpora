DOMINATION NUMBER WITHIN ON-LINE SOCIAL NETWORKS

by Marc Lozier Bachelor of Engineering in Computer Engineering, Ryerson University, 2013

A thesis presented to Ryerson University in partial fulfillment of the requirements for the degree of Master of Science in the Program of Applied Mathematics

Toronto, Ontario, Canada, 2015

c Marc Lozier 2015

Author's Declaration I hereby declare that I am the sole author of this thesis. This is a true copy of the thesis, including any required final revisions, as accepted by my examiners. I authorize Ryerson University to lend this thesis to other institutions or individuals for the purpose of scholarly research. I further authorize Ryerson University to reproduce this thesis by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research. I understand that my thesis may be made electronically available to the public.

ii

Domination Number within On-line Social Networks Master of Science, 2015 Marc Lozier Applied Mathematics, Ryerson University

Abstract There is particular interest in on-line social networks (OSNs) and capturing their properties. The memoryless geometric protean (MGEO-P) model provably simulated many OSN properties. We investigated dominating sets in OSNs and their models. The domination numbers were computed using two algorithms, DS-DC and DS-RAI, for MGEO-P samples and Facebook data, known as the Facebook 100 graphs. We establish sub-linear bounds on the domination numbers for the Facebook 100 graphs, and show that these bounds correlate well with bounds in graphs simulated by MGEO-P. A new model is introduced known as the Distance MGEO-P (DMGEO-P) model. This model incorporates geometric distance to influence the probability that two nodes are adjacent. Domination number upper bounds were found to be well-correlated with the Facebook 100 graphs.

iii

Acknowledgements I would first like to take this opportunity to extend my thanks and obligation to those people whose help and active guidance were critical in the completion of the thesis. I am foremost indebted to my supervisor Dr. Anthony Bonato for the wealth of knowledge he has provided. His support and guidance has been invaluable to both my research and future endeavors. I would like to offer my profound thanks to Dr. Dejan Delic and Dr. Laleh Samarbaksh for their participation as my defense committee. I would also like to thank Dr. Sebastian Ferrando for encouraging me to pursuit my Masters in Applied Mathematics. Collectively, I would like to thank the entire Department of Mathematics at Ryerson University for the great experience as a Masters student and Graduate Assistant. Lastly, I would like to thank my family -- my mother and father Judy and Michel, and my brothers Matthew and Michael -- and my friends for their support, encouragement and understanding.

iv

Contents List of Figures Chapter 1. Introduction 1.1. Motivation 1.2. Graph Theory 1.3. Properties of On-line Social Networks 1.4. Probability 1.5. Dominating On-line Social Networks 1.6. Outline of Thesis Chapter 2. Memoryless Geometric Protean Model 2.1. Background 2.2. The Model 2.3. Simulations Chapter 3. Domination Number in Facebook 100 and the MGEO-P Model 3.1. Facebook 100 3.2. Domination Number within Facebook 100 3.3. Domination Number within MGEO-P Chapter 4. Distance Memoryless Geometric Protean Model
v

vii 1 1 2 6 14 19 21 23 23 24 25

31 31 32 34 39

4.1. Motivation 4.2. The Model 4.3. Domination Number of the DMGEO-P Model Chapter 5. Conclusions and Future Directions 5.1. Summary 5.2. Open Problems Appendix A. Data Tables A.1. MGEO-P Data Tables A.2. Facebook 100 Data Tables A.3. DMGEO-P Data Tables Appendix B. Program Code B.1. JUNG Code (Java) B.2. SNAP Code (C++) Bibliography

39 40 45 49 49 50 53 53 68 81 91 91 164 219

vi

List of Figures 1.1 An example of a simple graph. 1.2 A graph and one of its dominating sets (represented by the white vertices). 1.3 The 1-core, 2-core and 3-core of a random graph. 1.4 Dominating sets generated by the algorithms DS-DC and DS-RAI. 1.5 General shape of a power-law distribution. 1.6 A log-log plot for Facebook friendships [43]. 1.7 Log-log plots for Flickr, LiveJournal, Orkut and Youtube demonstrating the existence of power law degree distribution [35]. 1.8 Sample graph from G(n, p) where n = 10 and p = 0.5. 1.9 General shape of a binomial distribution. 2.1 Time steps of a MGEO-P(3, 2, 0.17, 0.27) sample. 2.2 Samples of the MGEO-P(n, m, , , p) model, with various choices of parameters. 2.3 Degree distribution of MGEO-P(n, 4, 0.17, 0.27, 1) samples and G(n, p) model. 2.4 Log-log plots of MGEO-P(n, 4, 0.17, 0.27, 1) samples and G(n, p) model.
vii

3

4 5 7 11 11

12 17 18 26

27

30

30

3.1 Domination number upper bounds of the Facebook 100 graphs. 3.2 Domination number upper bounds of the Facebook 100 graphs with Theorem 1.1 upper bound ( = 5), presenting a significant overestimation. 3.3 Domination number upper bounds of MGEO-P samples corresponding to the Facebook 100 graphs. 3.4 Domination number upper bounds of MGEO-P samples corresponding to the Facebook 100 graphs with Theorem 1.1 upper bound ( = 5). 3.5 Domination number upper bounds of the Facebook 100 graphs with Theorem 3.1 upper bound, showing a very close correlation. 4.1 Time steps of a DMGEO-P(3, 2, 0.17, 0.27) sample. 4.2 Samples of the DMGEO-P(n, m, ,  ) model, with various choices of parameters. 4.3 Degree distribution of DMGEO-P(n, 4, 0.17, 0.27) samples for n = 1, 000, 5, 000, 10, 000 and 50, 000. 4.4 Log-log plots of DMGEO-P(n, 4, 0.17, 0.27) samples for n = 1, 000, 5, 000, 10, 000 and 50, 000. 4.5 Domination number upper bounds of DMGEO-P samples corresponding to the Facebook 100 graphs using the DS-RAI algorithm.
viii

33

34

35

36

36 42

43

43

44

45

4.6 Domination number upper bounds of DMGEO-P samples corresponding to the Facebook 100 graphs and FB100. 4.7 Domination number upper bounds of DMGEO-P samples corresponding to the Facebook 100 graphs with Theorem 1.1 upper bound ( = 5). 4.8 Domination number upper bounds of DMGEO-P samples corresponding to the Facebook 100 graphs with Theorem 1.1 upper bound ( = 5). 47 47 46

ix

CHAPTER 1

Introduction 1.1. Motivation Over the last decade, research on on-line social networks (or OSNs), such as Facebook and Twitter, has been increasing within the network science community. There is particular interest in these networks and capturing their properties. A few of the commonly observed properties of OSNs and other complex networks are power-law degree distributions [5] and the small world property [44] (constant or shrinking diameter with network size and high local clustering) [25]. These properties will be defined in Section 1.3. Graph theorists have the challenge to come up with a model that can mimic these properties asymptotically with high probability, and which correlate well with real-world data sets. Modelling allows mathematicians to uncover the underlying mechanisms behind the network, predict its future, and reveal any hidden reality of the network; see [8]. Graphs capture relationships between objects. A graph is called a network when it is represented by real-world interactions, such as the web graph, biological networks, or social networks. The friendship graph, collaboration graph and actor graphs are examples of social networks. These graphs are structured differently when compared to the web graph: the web graph is organized by link structure, while social networks are governed by social
1

interactions between people. On-line networks have their data more readily accessible and measurable than offline social networks (where the data is noisier and harder to gather). Hence, there is an increasing interest for a rigorous model to capture OSN's evolutionary properties. However, some models are more difficult to analyze than others. While some may fit naturally and realistically with real world data, they are often challenging to analyze.

1.2. Graph Theory Some knowledge of graph theory is necessary before discussing OSNs and their models. A graph G consists of a non-empty set of vertices, denoted E (G), and an edge set, denoted E (G), which consists of pairs of vertices. A graph is directed if each edge has an orientation. Otherwise, it is known as an undirected graph. When two nodes are joined by an edge, they are adjacent to each other or called neighbours. For simplicity, we will only consider simple graphs (see Figure 1.1): graphs that do not contain loops or multiple edges. The order of a graph is its number of vertices (that is, |V (G)|), while its size is the number of edges (that is, |E (G)|). In OSNs, vertices correspond to people, and edges correspond to their friendship relationships. A subgraph of graph G is a graph H where V (H )  V (G) and E (H )  E (G). An induced subgraph of graph G is a graph S , where V (S )  V (G) and each vertex is adjacent to each other only if they are adjacent in G. A path is said to exist between two distinct vertices when there is a sequence of edges that connect a sequence of non-repeated vertices to them. A graph is
2

connected when for each pair of distinct vertices, there exist a path between them.

Figure 1.1. An example of a simple graph.

The neighbour set of a given vertex u, denoted by N (u), consists of the set of vertices adjacent to u. The degree of a vertex, written deg(u), is the cardinality of its neighbour set |N (u)|. The minimum degree of a graph G is denoted as  (G). A familiar global measure for distances in a graph is its diameter. The diameter of a graph G, written diam(G), is the length of the longest shortest path. The distance between two vertices is the length of the shortest path between them, known as d(u, v ). 1.2.1. Dominating Sets. Dominating sets in graphs were first intro-

duced by Ore in 1962 [37]. A dominating set S  V (G) has the property that each vertex not in S is adjacent to some vertex in S. The domination number, written  (G), is the minimal cardinality of a dominating set. It is difficult to compute the exact value of  (G) when given a large order graph G. In particular, computing the domination number is known to be a NP-complete problem [19]. In order to obtain a value for  (G), heuristic algorithms are
3

used. One proof for the upper bounds of the domination number of any given graph was given using the probabilistic method by Alon and Spencer in [3], stated as Theorem 1.1. Figure 1.2 shows an example of a dominating set. Theorem 1.1. [3] If given any graph G with a minimum degree  > 1, then  (G)  n 1 + log( + 1) . +1 (1.1)

Figure 1.2. A graph and one of its dominating sets (represented by the white vertices).

The domination set is quite sensitive to vertices with low degrees. During simulations, the k-cores (where 1  k  5) for the graphs were used to test
4

how sensitive their domination sets were. The k-core of a graph is the largest induced subgraph in which its minimum degree is at least k . Figure 1.3 shows an example of the 1-, 2-, and 3-core of a graph.

1-core

2-core

3-core

Figure 1.3. The 1-core, 2-core and 3-core of a random graph.

There were two main algorithms used to provide results. Additional algorithms were used but not described in detailed in the thesis (as they were outperformed by other algorithms). Some of these include DS-RANDOM (adding random vertices to the dominating set), DS-GREEDY (adding the highest degree vertices to the dominating set recursively until entire graph is covered), and DS-RANK (adding vertices with the highest rank recursively, MGEO-P model only). The first main algorithm used in the thesis is known as DS-RAI. It is the fastest performing algorithm based on heuristic evidence from our experiments and provides a good upper bound (but not the best in our experiments). The algorithm works as described in Algorithm 1 (where {} denotes an empty set). The second main algorithm used is known as DS-DC. Despite
5

INPUT: Graph data - set of nodes V with degrees; OUTPUT: Dominating set array - DS; initialization: DS = {}, coveredSet = {}, sort nodes V in descending order by degree; while not at end of V do v  V; if v is not in coveredSet then add v to DS; add v to coveredSet; add neighbours of v to coveredSet; end end Algorithm 1: Dominating set algorithm DS-RAI from [39].

it performing slower than DS-RAI, it provides a better upper bound. The algorithm is stated in Algorithm 2.
INPUT: Graph data - set of nodes V with degrees; OUTPUT: Dominating set array - DS; initialization: DS = V, sort nodes V in ascending order by degree; while not at end of V do v  V; remove v from DS; if DS is not dominating then add v to DS; end end Algorithm 2: Dominating set algorithm DS-DC from [33].

1.3. Properties of On-line Social Networks Emergent topological properties have been observed with the available real world data from large-scale on-line social networks. Some observed properties of OSNs are the following. (1) Large scale and on-line. OSNs are massive networks that have their order (number of users) and size (number of relationships) in the millions, even billions. There
6

DS-DC Algorithm

DS-RAI Algorithm

Figure 1.4. Dominating sets generated by the algorithms DS-DC and DS-RAI.

also exist some users with abnormally high degrees. The order of these networks is also dynamic: users are being removed and added all the time (this is known as the on-line property ). (2) Small world property and shrinking distance. A famous chain letter experiment carried out by Stanley Milgram in 1967 [34] examined the average path length for the social networks of people in the United States. The experiment consisted of giving several letters to random people in different states addressed to a Boston stockbroker. The person would then be asked to send the letter onto other people whom they think who might know the stockbroker. Although only 20% of the letters were able to reached the stockbroker, on average, they took 6 steps through the social network. This was the beginning of the concept of the small world structure within networks.
7

The result of this experiment is known as the six degrees of separation. It is the theory that it is possible for a connection to be made between highly disparate social populations in a small number of steps. After many years, the small-world property is well-studied, and appears in the literature of many disciplines such as sociology, biology, physics, and information technology; see Chapter 2 of [8]. The study of small-world property within complex networks was first introduced by Watts and Strogatz in 1998 [44]. Networks with this property were noted to have a low diameter of O(log n) (or average distance of O(log log n)) and a high clustering coefficient (higher than a random binomial distributed graph with the same number of nodes and average degree). A more mathematical definition of clustering coefficient and random graphs will be presented in the next section. In the papers [1, 2, 23, 26, 35], the small-world property have been observed (in Cyworld, Flickr, LiveJournal, MySpace, Orkut, Twitter and YouTube). Twitter has been observed to have a high clustering coefficient and a low diameter of 6 in [23, 26]. In addition, it has been found in Cyworld [2], Flickr and Yahoo!360 [25] that their diameter shrinks over time. (3) Power-law degree distributions. Power laws were first studied in 1896 in Pareto's work [38] on income distribution. The power law degree distributions represents an undemocratic nature. There will be many people with low number of
8

friends and a few people with a significantly higher number of friends. It has been reported that the power law in- and out-degree distribution exist for Flickr, LiveJournal, Orkut, YouTube [35] and Twitter [23]. Golder et al. [20] analyzed 4.2 million users from Facebook and found that it follows a power law. In addition, the degree distributions amongst the social networks studied in [35] were found to be similar. A definition of power law degree distributions will be given in Subsection 1.3.1. (4) Densification power law. This occurs when the average degree of the network grows to infinity as the order of the network increases. A graph G follows a densification power law if there exist a constant a  (1, 2) such that |E (G)| is proportional to |V (G)|a . In [2], it was documented that Cyworld (a South Korean social network) exhibit this densification power law. (5) Bad spectral expansion. OSNs are often divided into clusters. A common trait about them is that they contain communities, which is a characteristic of social organization [36]. In these tightly knit clusters, the number of links within them are significantly higher than the links between other groups or clusters. Because of this structure, these networks have bad spectral expansion properties due to small gaps between the first and second eigenvalues of their adjacency matrices [18].
9

(6) Component structure. In [25], Kumar et al. classified users of Flickr and Yahoo!360 into three categories: singletons (isolated nodes), the giant component (dense core of low (shrinking) diameter) and the middle region (isolated communities with star-like structure). Two main properties that are particularly interesting are the power-law degree distributions and small world-property. A detailed description of each follows. 1.3.1. Power Law Degree Distribution. Let G be a graph and k

a positive integer. The number of vertices of degree k in G is defined as: Nk,G = |{x  V (G) : degG (x) = k }|. Since real-world complex networks are dynamic, for simplicity, we let |V (G)| = t (this allows us to remember that the number of vertices within a system changes with time). A graph follows a power-law degree distribution if each degree k ,
Nk,G t

 k - , for a fixed real constant  > 1. Here,  is called

the power law exponent. Since the function f (k ) = k - decays to 0 as k tends to  polynomially (not exponentially), the power law degree distribution is also known as a heavy-tailed distributions. See Figure 1.5 for a visualization of the general shape of a power law distribution. A graph for which the power law holds is known as a power law graph. By taking the logarithms of the degree distribution, we will obtain an approximate straight line with slope - . The power law usually exists for a
10

Figure 1.5. General shape of a power-law distribution.

specific interval of degrees with some deviation for nodes with small or large degrees. See Figure 1.6 and 1.7 for real-world examples of log-log plots. log(Nk,G )  log(t) -  log(k ).

Figure 1.6. A log-log plot for Facebook friendships [43].

1.3.2. Small World Property.

Small world graphs were first intro-

duced in [44] where Watts and Strogatz defined the average distance (characteristic path length) that measured global distances in a graph and the measure for "cliquishness" of neighbourhoods. Small world graphs with order t satisfy the following bound: diam(G) = (log(t)). However, when there
11

Figure 1.7. Log-log plots for Flickr, LiveJournal, Orkut and Youtube demonstrating the existence of power law degree distribution [35].

is an isolated vertex in a graph, this causes its diameter to be infinite. Thus, another measurement for global distance is necessary. The average distance for a connected graph with order n, G, is defined as: d(u, v ) L(G) = =
u,v V (G) n 2

n2

2 -n

d(u, v ).
u,v V (G)

Watts and Strogatz [44] reported the small world property requires L(G) to be much smaller than the graph's order. It is demanded that L(G) = (log log n). A measurement that measures local density is the clustering coefficient. This coefficient should be larger relative to a random graph with the same order and size. Given a graph G with order n and x  V (G), define:
12

E N (x) C (x) =
deg(x) 2

2 E N (x) = deg(x)(deg(x) - 1) . The clustering coefficient of a graph G, C (G), is the average of all the clustering coefficients over all the vertices, which equates to: C (G) = 1 n C (x)
xV (G)

2 = n

E N (x)
xV (G)

deg(x)(deg(x) - 1)

.

The value of the clustering coefficient is a rational number within [0, 1]. Complete graphs (that is, ones that contain all possible edges) will have a clustering coefficient of 1, while graphs without triangles have a clustering coefficient of 0.

1.3.3. Modelling On-line Social Networks.

There have been at-

tempts to design a mathematically rigorous model that can simulate observed properties of OSNs. A model is said to simulate a property when a graph generated by the model satisfies the property, with high probability. We provide here a brief list of some of these models and their properties. The preferential attachment (PA) model [5, 7] (satisfying properties 1 to 3), the geo-protean (GEO-P) model [11] (satisfying properties 1 to 4), the iterated local transitivity (ILT) model [10] (satisfying properties 1, 2, 4,
13

5 (but not 3 and 6)), a model based on affiliation graphs [29] (satisfying properties 1 to 4), component structure model [25] (satisfying only property 6), the Forest Fire model, and Kronecker multiplication models [27, 28] (satisfying properties 1 to 4).

1.4. Probability A few concepts of probability are needed in the thesis such as expectation and concentration. A discrete probability space S contains the following triplet, (S, F , P). The sample space, denoted S , is a non-empty and finite countable set. Set F is a collection of all possible subsets of S , these are called events. Finally, the function P : F  R is known as the probability measure. The probability measure has the following properties: (1) For all events A, P(A)  [0, 1], and P(S ) = 1. (2) If F is countable (Ai : i  I ) and the events are pairwise disjoint, then P
iI

Ai

=
iI

P(Ai ).

Since F is considered to be the power set of S , it does not need to be specified. An example of a probability space is the uniform probability space on S with P(A) =
| A| n .

The set S is defined as being a finite set with n > 0

elements. An element is chosen uniformly at random (or u.a.r.) when all elements have the same probability of being chosen. Like in this case, every element has probability of
1 n

to be chosen from S .
14

A discrete random variable, denoted X , is a function X : S  R whose inputs are a sample space S on the probability space S . Some information about binomial distribution is required for this thesis. The probability mass function (p.m.f.), f : R  [0, 1], of X is defined by f (x) = P(X = x). Given a x  R, we compute

P(X = x) =
sS, X (s)=x

P({s}).

The first moment of a random variable or its expectation, written E(X ), is defined as

E(X ) =
sS

X (s)P({s}).

If S is finite, then E(X ) will also be finite.

When taking the expectation of multiple random variables, one property that will provide significant help is stated in Theorem 1.2.

Theorem 1.2. [21] If the random variables X, Y, andXi where 1  i  n, are defined on a probability space, then the following holds. Linearity of Expectation. If ci is any real number constant where 1  i  n, then
n n

E
i=1

ci X i

=
i=1

ci E(Xi ).

15

A binomial random variable X has parameters n and p and has the p.m.f. P(X = i) =
n i

pi (1 - p)n-i while its expectation is np and its variance

np(1 - p). This simply counts the number of successes in n independent trails with a probability of p success. We state the following concentration inequality. Theorem 1.3. [21, 22] (Chernoff bounds) If X is a binomial random variable, the following holds. P(X  E(X ) + t)  exp(-E(X ))(t/E(X )). P(X  E(X ) - t)  exp(-E(X ))(-t/E(X )). where (x) = (1 + x) log(1 + x) - x for x  -1, and (x) =  for x < -1. If   3/2, then 1 P(|X - E(X )|  E(X ))  2 exp - 2 E(X ) . 3

We say an event An holds asymptotically almost surely (a.a.s.) if it holds with probability tending to 1 as n tends to infinity. 1.4.1. Random Graphs. Let n be a positive integer, and let p be

a real number in [0, 1]. The space of random graphs of order n with edge probability p is denoted as G(n, p). Random graphs were first studied by Paul Erd os and Alfred R´ enyi in 1959 [17]. They are graphs that have a
n binomial degree distribution which follows P(G) = p|E (G)| (1 - p)( 2 )-|E (G)| .

16

These are graphs with a fixed vertex set V and varying number of edges (two vertices are adjacent independently with probability p). The number of edges follows a binomial distribution and has expectation
n 2 n 2

p, as there are

many possible edges each occurring with probability p. Although G(n, p)

represents a probability space of graphs, we abuse language and refer to it as the random graph with order n and edge probability p. See Figure 1.8 for an example of a randomly drawn graph.

Figure 1.8. Sample graph from G(n, p) where n = 10 and p = 0.5.

If we let the random variable X to be the degree of any particular vertex, then it follows a binomial distribution. A binomial distribution histogram approximates a bell curve shape with a concentration around its expected value when p is fixed and n  . The random variable X is defined as the sum of random variables that follow a Bernoulli distribution (that is, it counts
n

the number of vertices adjacent to the particular node): X =
i=1

Yi . Note

that a Bernoulli distribution is a simple distribution that allows a random
17

variable to take the value of 1 with probability q (in other terms, 0 with probability q = 1 - p). Thus, the expected value of a Bernoulli distribution is simply p:
n

E (X ) = E (
i=1 n

Yi )

=
i=1 n

E (Yi )

=
i=1

p

= np, where the seconds equality follows by the Linearity of Expectation (Theorem 1.2). Concentration on the expected degree follows by use of the Chernoff bounds; see Theorem 1.3. Figure 1.9 is the expected shape of a binomial distribution.

Figure 1.9. General shape of a binomial distribution.

18

1.5. Dominating On-line Social Networks One key property that is noticed in social networks is that people tend to have characteristics or attributes similar to their friends. The reason for this is because of social influence (adopting behaviours through word-ofmouth or imitation) and selection (forming relationships with people similar to you) [16]. The structure of these networks will vary due to these two forces. However, in the end, this causes people to have relationships with similar people. Social influence produces a network-wide uniformity while selection drives the network to smaller clusters [16]. An example of social influence was presented by Kramer et al. in 2014 [24] where they provided evidence of emotional contagion by manipulating the news feed for nearly 700,000 Facebook users. With over a billion users and 70 billion friendships, Facebook is the world's largest on-line social network. In 2012, it was computed that Facebook had an average of 4 degrees of separation amongst their users [4]. This brings up an important popular subject of on-line social networks: information diffusion or the spread of (social) influence. Researchers worldwide have been drawn to try and model these processes along with their dynamic relationships. The spread of influence can take in many forms: a computer virus, a marketing ad, a disease, or even social influences (such as emotional states [24]). A good indicator of how susceptible a social network is to the spread of influence is the number of users required such that for every user not in this set is adjacent to at least one user in the set (that is, a dominating set).
19

In Section 1.2.1, we defined the minimum cardinality of the domination set as the domination number of the network. These are the agents that potentially have the most influence in the network. By sending a message, a virus, an emotion, through these users, that information gets rapidly spread out to the entire network. Other various of applications that uses this domination concept are: efficient data routing [40], detecting highly significant optimized subsets of proteins in protein-protein interaction networks (PPIs) [33], and developing a dynamic backbone for Mobile Ad-Hoc Networks (MANETs) for routing and broadcasting [45]. Domination also plays a role in distributed computing and network controllability [15]. In addition, other concepts have been studied to determine how sensitive a graph is to influence like social elites [14]. Using the domination number to analyze a network only allows us to potentially capture such agents in the network. A more sophisticated measurement would be required to analyze graph sensitivity to influence. The paper published by Kramer et al. [24] in 2014 provided empirical evidence of emotional contagion by manipulating the Facebook news feed of over 600,000 Facebook users. The researchers did not change the content of what the users were posting but only restricted what they saw based on keyword analysis. They found that users who were subject to more positive posts tend to post more positive content. Similarly the users subject to negative content were more likely to post something negative. This brings up an important fact that we as humans do not required human-human interactions in order to be influenced. A good way to see the significance of
20

a dominating set in this example is to imagine such a set existed with a size of say, 1,000. That means if these 1,000 users were to post positive content, then the entire networks (potentially consisting of millions of users) would be influenced. 1.6. Outline of Thesis In Chapter 2, the MGEO-P model will be introduced with a brief background of its development from the GEO-P model, and how it relates to the concept of Blau space and its properties. Some simulations are presented. Within Chapter 3, upper bound domination numbers are computed for the Facebook 100 (also known as FB100) graphs and corresponding MGEO-P samples. In Chapter 4, a new variation of the MGEO-P model is introduced and analyzed: the Distance MGEO-P model. And finally in Chapter 5, we summarize our findings and present open problems and directions for future work.

21

CHAPTER 2

Memoryless Geometric Protean Model 2.1. Background The memoryless geometric protean model (MGEO-P) was first introduced by Bonato et al. in 2014 [9]. This is a variation on the geometric protean model (GEO-P) that allows us to approximate the GEO-P model without costly sampling. The MGEO-P model has its edges arrive based on a given distance metric in m-dimensional Euclidean space Rm . This space closely mirrors Blau space [13], a construction in the social sciences. It is a multidimensional coordinate system where the dimensions are defined by social demographic variables. The relative position of the vertices within Blau space are guided by the principle of homophily [14]. That is, vertices that are closer to each other tend to have similar socio-demographic characteristics. Examples of Blau space dimension variables are age, sex, location, education and income. The sociologist Peter Blau introduced this notion which bears his name. He was the first to take individuals in a social network and abstract them to nodes in a multi-dimensional space. He had the idea that "social forces" are the overlaps of social demographic characteristics and that population structure can influence human behaviour [6]. It was later on more fully developed by Miller McPherson [30, 31, 32].

23

2.2. The Model The MGEO-P model consists of five parameters MGEO-P(n, m, , , p): the number of nodes n, the dimension m, the attachment strength parameter 0 <  < 1, the density parameter 0 <  < 1 -  and the probability of connection 0 < p  1. Here, the parameters n and m are positive integers that are greater than 0 and , , p are real numbers. The network starts out empty. During each iteration of the process, a new vertex is added to the network. There will be a total of n steps resulting in a graph of order n. For each of the n steps, a vertex v is created and given a random rank rv and random position qv  Rm within the unit-hypercube [0, 1]m . The random rank is chosen from the unused remaining ranks from 1 to n. A unit-hypercube side has length one unit with 2m vertices in Rm with coordinates {0, 1}m . The
- - volume of space that a node influences is rv n . The radius of a node can

be obtained by taking the mth-root of the volume of the node and dividing it by two. Thus, each vertex has a radius of influence given by: 1 - - 1/m I (rv ) = (rv n ) . 2 An undirected edge is created between v and any preexisting vertex u with probability p, if D(v, u)  I (ru ). The distance is computed using the infinitynorm. The infinity-norm is defined as ||x|| = max{|x1 |, |x2 |, ..., |xm |}. The distance used in the model is computed as follows:

D(u, v ) = min {||qv - qu - z || : z  {-1, 0, 1}m }.
24

The z term within the distance formula allows the geometric space to be symmetric and "wrap" around like a torus. This process is repeated until all the vertices have been placed within the unit-hypercube. 2.3. Simulations Figure 2.1 demonstrates the process of simulating MGEO-P(3,2,0.17,0.27,1) which we explain here. For simplicity, we assume that the probability of connection p for the MGEO-P model is 1. In reality, we know this is not the case. A more realistic value would be less than 0.5. The network initially starts out empty. In the first step, a node is placed with the coordinates (0.1894, 0.1284) and a radius of 0.431081. There are no pre-existing nodes to check for any edges. During the second step, another node is generated at (0.7439, 0.7232) and a computed radius of 0.406416. The procedure continues with checking if the distance between the current generated node and any pre-existing node is less than the pre-existing node's radius. In this case, D(u, v ) = D(1, 2) = 0.445500 0.431081. Therefore, an edge is not placed

between these two nodes. Finally, the third node is placed in the space at (0.4200, 0.9213) with radius 0.392648. Repeating the process, computing the distance of nodes one and three D(1, 3) = 0.2306  0.431081 tells us an edge is placed. Likewise, for nodes two and three D(2, 3) = 0.3239  0.406416, thus, an edge is placed. Figure 2.2 shows visual representations of graphs generated by the MGEOP model using JUNG 2.0.1 (Java Universal Network/Graph) framework which was released in early 2010. In the original GEO-P model, the process does
25

(a)

(b)

(c)

(d)

(e)

(f)

Figure 2.1. Time steps of a MGEO-P(3, 2, 0.17, 0.27) sample. The unit square is given
by the black interior rectangle from 0 to 1. The broken blue circles are copies of nodes illustrating the torus metric. (A) Time step 1: First node is added to the network. (B) Time step 2: Second node is added to the network. No nodes are overlapping, thus no edges. (C) Time step 3: Third node is added to the network. Overlaps with node one and two. (D) An edge is placed in between nodes one and three. (E) An edge is placed in between nodes two and three. (F) Final graph without node radii.

26

not end there. The procedure is repeated until a random stop time, where in each step the least-recently added vertex will be removed and a new one inserted.

MGEOP(50,3,0.17,0.27,1)

MGEOP(100,3,0.17,0.27,1)

MGEOP(150,3,0.17,0.27,1)

MGEOP(50,4,0.17,0.27,1)

MGEOP(100,4,0.17,0.27,1)

MGEOP(150,4,0.17,0.27,1)

Figure 2.2. Samples of the MGEO-P(n, m, , , p) model, with various choices of parameters.

As mentioned in Chapter 3 (Domination Number in Facebook 100 and the MGEO-P Model), the MGEO-P parameters were computed for Facebook 100 data [12]. Tables A.1, A.2, A.3 show a preliminary analysis of the MGEO-P samples using the Facebook 100 parameters. The tables provide graph properties such as number of nodes, number of edges, average degree, maximum
27

degree and density. Density is simply a measurement of how many edges there are relative to the maximum number of edges. It is defined as: D= 2E . V (V - 1)

Therefore, complete graphs have a density of 1 and graphs with no edges a density of 0. A complete graph for the MGEO-P model would have a attachment strength parameter and density parameter of 0 to keep each nodes radius of influence uniform. These results will be used to make comparisons between the MGEO-P model, the modified MGEO-P model, and the Facebook data to draw any conclusions. The following theorems about the MGEO-P model appear in [9] along with their proofs. We omit the proofs here as they are beyond the scope of this thesis. A useful result that follows from Theorem 2.1(1) is that a.a.s. the minimum degree  is at least (1 + o(1))pn1-- .

Theorem 2.1. [9] Asymptotically almost surely, the following properties hold for graphs generated by MGEO-P. (1) If v is a node of a MGEO-P(n, m, , , p) sample with rank R and age i, then i-1 p deg(v ) = n1-- + (n - i)pR- n- n - 11 -  log2 (n) n1--

1+O

.

28

(2) The average degree of a vertex of MGEO-P(n, m, , , p) is p d= n1-- 1 + O 1- log2 (n) n1--
1

.

(3) The diameter of MGEO-P(n, m, , , p) is n( m ) . (4) If k is chosen such that n1-- log 2 (n)  k  n1- 2 - log-2-1 (n), then MGEO-P(n, m, , , p) satisfies Nk = 1 + O log- 3 (n)
1 (1- ) 1 1  p  n  k-  , 1+ 1 

where the number of vertices of degree at least k is denoted by Nk . These theorems demonstrate that the model a.a.s. exhibits a power-law degree distribution. A few samples of the model were simulated with their histogram and log-log plot computed to provide evidence that a power-law distribution appears in graphs generated by the model. See Figure 2.3 and Figure 2.4. As expected, the MGEO-P model follows a power-law degree distribution and has a linear slope in its log-log plot, while G(n, p) follows more of a binomial degree distribution with a noisy log-log plot.

29

Figure 2.3. Degree distribution of MGEO-P(n, 4, 0.17, 0.27, 1) samples and G(n, p) model for n = 100, 1000, 5000, 10, 000 and 50, 000. Note that p was chosen in G(n, p) so that the graphs sampled have the approximate same average degree as the corresponding MGEO-P samples. The size of each bin were automatically computed using MATLAB's automatic binning algorithm.

Figure 2.4. Log-log plots of MGEO-P(n, 4, 0.17, 0.27, 1) samples and G(n, p) model for n = 100, 1000, 5000, 10, 000 and 50, 000. Note that p was chosen in G(n, p) so that the graphs sampled have the approximate same average degree as the corresponding MGEO-P samples.

30

CHAPTER 3

Domination Number in Facebook 100 and the MGEO-P Model 3.1. Facebook 100 To investigate the domination number and its values on social networks, we need a data set that resembles a natural on-line social network. We randomly generate MGEO-P samples since they follow most OSN properties. However in [9], the parameters of a Facebook dataset were computed for the MGEO-P model. Using these parameters, model samples can be simulated and tested. The social network data used are known as the Facebook 100 (or FB100) graphs. They were distributed and anonymized by Mason Porter who worked at Facebook. It contains 100 Facebook network samples from 100 universities from the United States in September 2005 [41] as separate networks. Their order and size vary from 700 users to 42,000 users and 16,000 friendships to 1,590,655 friendships. For this thesis, the data that was used were the friendship networks of each institution as separate graphs. These graphs provide a single snapshot of subgraphs of the Facebook network. The Facebook 100 data represents an historical snapshot of agents joining the network over time that can describe different stages of institutions within the network. For example, some users might have joined the network earlier or later. The original released data that has been analyzed in [41] contains

31

additional information such as gender, class year, major, high-school and residence. Before investigating the domination sets within the FB100, some preliminary analysis should be done to indicate any significant properties about these social networks. It should be noted that the minimum degree for each dataset in the Facebook 100 network is 1 and is excluded from the tables. Tables A.16, A.17, A.18 provides the preliminary analysis of FB100.

3.2. Domination Number within Facebook 100 Given the FB100 graphs, the dominating set algorithms DS-RAI and DS-DC (as described in Chapter 1) were executed multiple times to provide an idea of what the upper bounds of the domination number of on-line social networks could be. Tables A.19, A.20, A.21, A.22 and A.23 in the Appendix, show the results of the DS-RAI algorithm for the k -cores, where 1  k  5. The 0-core (that is, the original graph) was not accounted for because the Facebook 100 graphs do not have any isolated vertices thus, making the 0-core graphs equivalent to the 1-core graphs. The DS-RAI algorithm performs the fastest and provides a good indication of what the upper bounds are for the Facebook 100 graphs. The DS-DC algorithm improves on these upper bounds at the cost of a longer execution time. The following Tables A.24, A.25, A.26, A.27 and A.28 in the Appendix, provides the dominating set size achieved by the DS-DC algorithm for the k -cores, where 1  k  5. The DS-DC algorithm provides upper bounds
32

Figure 3.1. Domination number upper bounds of the Facebook 100 graphs.

that are approximately 75% of the order of the dominating sets obtained via DS-RAI. The data represented in the plot Figure 3.1 are the dominating set sizes for the Facebook 100 graphs with DS-DC and DS-RAI relative to the graph order. Since our graphs are quite small when considering asymptotic bounds, the data progression can be consider either linear or sub-linear. The general upper bound mentioned in Theorem 1.1 suggests that the upper bound is potentially linear. Comparing the theoretical and computed bounds shows that the upper bound mentioned by Alon and Spencer in [3] is quite significantly higher than the computed bounds for the FB100 graphs. The comparison plot is shown in Figure 3.2, where the minimum degree  used was considered to be 5 since we took up to the 5-core.
33

Figure 3.2. Domination number upper bounds of the Facebook 100 graphs with Theorem 1.1 upper bound ( = 5), presenting a significant overestimation.

3.3. Domination Number within MGEO-P MGEO-P samples generated from the Facebook 100 parameters in [9] were used to provide an upper bound of the domination number for the model. For simplicity, when the samples were generated the probability parameter p was considered to be 1. To obtain an appropriate MGEO-P sample for the FB100, percolation must be done. This is the process of randomly removing edges until the graph has a set number of edges. For graphs with less edges than those in the data set, they are left intact. Just like in [9], our samples were percolated to match the number of edges of the Facebook data. Intuitively, one would expected that the graphs generated using the process of
34

Figure 3.3. Domination number upper bounds of MGEO-P samples corresponding to the Facebook 100 graphs.

percolating to be quite similar than the original data. This is indeed true and is seen when comparing the preliminary analysis of Table A.1, A.2, A.3 and Table A.16, A.17 and A.18. A noticeable difference is the maximum degree of the samples. One should expect a larger dominating set for the MGEO-P samples because their maximum degrees are lower than the original data. The upper bound of the domination number is shown in Figure 3.3. A recent finding in [12], provides a theorem regarding the domination number of the MGEO-P(n, m, , , p) model. The theorem poses that a sublinear bound exist on the domination number for OSNs. Theorem 3.1. [12] A.a.s the MGEO-P(n, m, , , p) model domination number satisfies  (G) = (C -m/(1-) n+ ) and  (G) = O(n+ log n),
35

Figure 3.4. Domination number upper bounds of MGEO-P samples corresponding to the Facebook 100 graphs with Theorem 1.1 upper bound ( = 5).

Figure 3.5. Domination number upper bounds of the Facebook 100 graphs with Theorem 3.1 upper bound, showing a very close correlation.

where C is any constant greater than 6 and m = o(log n). Particularly, a.a.s.  (G) = n+ +o(1) .
36

Based on a comparison of the plots, there is a high correlation between the theoretical MGEO-P upper bound and the domination number of the FB100 graphs. For the 100 samples, there is a noticeable pattern emerging. This provides empirical evidence that on-line social networks domination numbers follow sub-linear growth; more precisely:

 (G) = O(n+ log n). By incorporating a sub-linear line of best fits using MATLAB, we will be able to see how well the data fits this type of growth. For simplicity, we ignore the constant in front of the big Oh term. From these trend lines, we can determine how correlated the sub-linear fit is with the data. Table 3.1 provides the coefficient of determination; that is, how close the data fits with the regression line. There are high correlations even when taken the 5-core. The theoretical upper bound occurs asymptotically almost surely. As our data sets are relatively small order (that is, orders in the thousands rather than millions or billions), the asymptotic results predicted in Theorem 3.1 may not be fully evident in the MGEO-P samples. As more experiments are done with larger orders, we hope that their domination number demonstrates a more clear sub-linear growth and that the data fits more tightly.

37

k x 1 0.509 2 0.492 3 0.4818 4 0.4741 5 0.4677 x Table 3.1. Fitting y = n log n to the FB100, where 1  k  5.

R2 0.8472 0.8292 0.8179 0.8093 0.803 domination number of the k-cores of

38

CHAPTER 4

Distance Memoryless Geometric Protean Model 4.1. Motivation The MGEO-P model has a probability parameter p which was considered 1 during our simulations of the Facebook 100 graphs. Recall that Blau space predicts that agents with similar attributes are closer in the space. We abstract this to a new paradigm in the setting of MGEO-P, where vertices are adjacent in a region of influence with probability given by the function f (D(u, v )), with u and v distinct vertices. That is, f is a function which depends on the metric distance between u and v . The distance D(u, v ) is defined below. In particular, vertices have a higher probability of being adjacent to other vertices in their radius of influence which are closer. An example of this is friendships within a community. A person will more likely be friends with someone who lives geographically closer to them. A larger scale example would be Facebook friendships between two people from different countries, where one may suspect that such people have a lower probability of being friends. This allows distance to play the role of the probability parameter. The model that uses this as the function of p is known as the distance memoryless geometric protean model, written DMGEO-P. This is new model will be the focus of this chapter. We define the model below in Section 4.2, and then give the results of simulations of the model in Section 4.3.
39

4.2. The Model The DMGEO-P model is defined in a similar way to the MGEO-P model, except instead of five parameters there are four parameters DMGEOP(n, m, ,  ). The parameters are exactly like the MGEO-P model: the number of nodes n, the dimension m, the attachment strength parameter 0 <  < 1 and the density parameter 0 <  < 1 - . The process is the exact same as the original MGEO-P model, however edges are added based on the following rule. An undirected edge is created between v and any pre-existing vertex u with probability f (D(u, v )), if D(v, u)  I (ru ). The distance and probability of adjacency, respectively are computed as follows:

D(u, v ) = min {||qv - qu - z || : z  {-1, 0, 1}m },

f (D(u, v )) = 1 - where || · || is the infinity-norm.

D(u, v ) , I (ru )

Figure 4.1 demonstrates the process of simulating DMGEO-P(3,2,0.17,0.27) which we explain here. The network initially starts out empty. In the first step, a node is placed with the coordinates (0.1894, 0.1284) and a radius of 0.431081. There are no pre-existing nodes to check for any edges. During the second step, another node is generated at (0.7439, 0.7232) and a computed radius of 0.406416. The procedure continues with checking if the
40

distance between the current generated node and any pre-existing node is less than the pre-existing node's radius. In this case, D(u, v ) = D(1, 2) = 0.445500 0.431081. Therefore, an edge is not placed between these two

nodes. Finally, the third node is placed in the space at (0.4200, 0.9213) with radius 0.392648. Repeating the process, computing the distance of nodes one and three D(1, 3) = 0.2306  0.431081 tells us an edge is placed with a probability of f (D(1, 3)) = 0.203034. Likewise, for nodes two and three D(2, 3) = 0.3239  0.406416, thus, an edge is placed with a probability of f (D(2, 3)) = 0.465065. Figure 4.2 shows visual representations of graph samples generated by the DMGEO-P model. Like the MGEO-P samples, simulations were generated and a preliminary analysis was done. Tables A.29 A.30, A.31 provides us with the minimum degree, average degree, maximum degree and density of DMGEO-P samples analogous to the Facebook 100 graphs. When comparing these samples with the real data, the model tends to generate more sparse graphs with much less density and maximum degree. One might expect a domination number that is higher than the Facebook data. More nodes would be required to completely cover the network because the maximum degree is low. However, there are less graph samples with a minimum degree of one as in the Facebook data. And as in mentioned in Chapter 1, the domination set is sensitive to low degrees. We hope to see less "shifts" (that is, changes) in the domination set upper bound when taking the k -core of the DMGEO-P model. There is a higher probability of the low degree nodes being adjacent to at least one
41

(a)

(b)

(c)

(d)

(e)

(f)

Figure 4.1. Time steps of a DMGEO-P(3, 2, 0.17, 0.27) sample. The unit square is
given by the black interior rectangle from 0 to 1. The broken blue circles are copies of nodes illustrating the torus metric. The images demonstrate the concept that the closer a node is to another in geometric space, there is a higher probability of adjacency. This is seen in the difference of probability between the two edges shown. (A) Time step 1: First node is added to the network. (B) Time step 2: Second node is added to the network. No nodes are overlapping, thus no edges. (C) Time step 3: Third node is added to the network. Overlaps with node one and two. (D) An edge is placed in between nodes one and three with probability of 0.203034. (E) An edge is placed in between nodes two and three with probability of 0.465065. (F) Final graph without node radii.

42

DMGEOP(50,3,0.17,0.27)

DMGEOP(100,3,0.17,0.27)

DMGEOP(150,3,0.17,0.27)

DMGEOP(50,4,0.17,0.27)

DMGEOP(100,4,0.17,0.27)

DMGEOP(150,4,0.17,0.27)

Figure 4.2. Samples of the DMGEO-P(n, m, ,  ) model, with various choices of parameters.

agent in the dominating set since the maximum degree of the samples are also quite low relative to the order of the graphs.

Figure 4.3. Degree distribution of DMGEO-P(n, 4, 0.17, 0.27) samples for n = 1, 000, 5, 000, 10, 000 and 50, 000.

43

Figure 4.4. Log-log plots of DMGEO-P(n, 4, 0.17, 0.27) samples for n = 1, 000, 5, 000, 10, 000 and 50, 000.

44

4.3. Domination Number of the DMGEO-P Model Tables A.32, A.33, A.34, A.35, A.36, A.37 present the results of the DS-RAI algorithm for DMGEO-P samples that correspond to the FB100 network for their k -cores, where 1  k  5. See Figure 4.5 for the plot of the dominating set size relative to the graph's order. Notice, as expected, the k -cores are all very similar; there is hardly any noticeable changes in domination set size. The DMGEO-P model appears to generate samples that are not as sensitive to domination noise (that is, the effect of having a higher domination number due to nodes with low degrees) than the MGEO-P model.

Figure 4.5. Domination number upper bounds of DMGEO-P samples corresponding to the Facebook 100 graphs using the DS-RAI algorithm.

Figure 4.6 compares the domination size of the DS-RAI algorithm for both DMGEO-P samples and the FB100 data. They appear to be relative close in size. It is interesting to observe the Facebook 100 graphs are more dense and should require less nodes in its domination set. As opposed to the DMGEO-P
45

model where graphs are less dense and should require more nodes to cover the graph completely. However, both contains domination sets around the same size. Due to the higher minimum degree in the DMGEO-P model, there are a lower number of nodes with low degrees (when comparing the FB100 data). It would be advantageous to calculate the clustering coefficient of the Facebook 100, MGEO-P and DMGEO-P domination set nodes to see if any pattern or observations can be made about such nodes. We leave this for future work but hope to expect that these agents have a higher than average clustering coefficient.

Figure 4.6. Domination number upper bounds of DMGEO-P samples corresponding to the Facebook 100 graphs and FB100.

Using the same Theorem 1.1 with the minimum degree of 5, Figure 4.7 shows its large overestimation on the domination size. All of our results are the same for Theorem 1.1. It shows a linear growth in domination number with order. Let us compare the MGEO-P theoretical domination number upper bound mentioned within [12] and the DMGEO-P domination size in
46

Figure 4.7. Domination number upper bounds of DMGEO-P samples corresponding to the Facebook 100 graphs with Theorem 1.1 upper bound ( = 5).

Figure 4.8. The resulting plots are similar in shape but not order. One should notice however that we only have the results of the DS-RAI algorithm. The DS-DC algorithm will result in a smaller set. An open question now is, does the DMGEO-P model follow Theorem 3.1? In particular, does the DMGEOP model follow a sub-linear domination number upper bound?

Figure 4.8. Domination number upper bounds of DMGEO-P samples corresponding to the Facebook 100 graphs with Theorem 1.1 upper bound ( = 5).

47

CHAPTER 5

Conclusions and Future Directions 5.1. Summary In Chapter 2, we investigated the MGEO-P model for properties found in OSNs. Theorems were stated for the model's average degree, diameter, and power-law degree distribution. We simulated graphs for the model, and confirmed experimentally that these satisfy power-law degree distributions. In Chapter 3, we began with some brief background and analysis of the Facebook 100 dataset, and then went on to computing domination sets for the k -core, where 1  k  5, using the DS-DC and DS-RAI algorithms. In [9], they investigated the FB100 graphs and computed matching MGEOP parameters for each institution within the set. With these parameters, MGEO-P samples were generated with their domination set computed using the DS-RAI and DS-DC algorithms. Recent theoretical results have suggested a sub-linear upper bound on the domination number in MGEO-P samples. We plotted the theoretical bound for the MGEO-P model using the parameters in [9], and the best estimation we have of the domination number for FB100 (from the DS-DC results). There is a correlation of the domination number of real Facebook datasets and graphs simulated from MGEO-P. In our simulations of MGEO-P, we noticed that our samples did follow the theoretical bounds on the domination number. As mentioned in Chapter 3,
49

the constant term of the big Oh bound was not considered in our plots. Also, we used the parameters for the MGEO-P matching the datasets found in [9], and then percolated our graphs to match the number of edges of the dataset. This possibly explains why our generated samples are more dense and why our domination sets are smaller than the plotted function f (n) = n+ . In Chapter 4, the MGEO-P model was modified to incorporate a more geometric view, better approximating Blau space. Here we found that these sample's domination number follow closely along with the actual Facebook data and MGEO-P theoretical domination number upper bound. Some investigation should be done to explain why the DMGEO-P model is generating less dense graphs yet have a domination number that more closely resembles dense OSNs such as FB100. 5.2. Open Problems There is much more work to be done in this area of research. Completing the DS-DC algorithm for the DMGEO-P samples will help us deduce if the model follows OSNs domination numbers. One can perform additional domination set algorithms to find the actual domination number of the Facebook 100 dataset. The ultimate goal would be to apply an algorithm for computing the exact domination number of OSNs (such algorithm is mentioned in [42]). One can look into elite members (that is, influential members in the social network) of networks and see what role they play in dominating sets. In addition, dominating sets can be widely used in "directors network" as a niche area in Corporate Finance. The PageRank of each network should
50

be computed, and the agents of the institution's domination set should be crossed referenced to see if there is any correlation with the agents of high PageRank and agents within the domination set. As mentioned in Chapter 4, the clustering coefficients for each graph should be computed and analyzed to see any patterns between the dominating agents and their clustering coefficient. Another, possibly more complex problem that should be studied, is to consider models where the sphere of influence is not a ball in the corresponding metric space. The idea behind this is agents do not have a uniform radius of influence in m-dimensions, and the radius would depend on what dimension is being considered (for example, socio-demographic characteristics) for that agent. For example, if one dimension was income and another community impact, there can be many users with low level of income and high community impact, and vice versa. Another important consideration to consider is the domination number in other OSNs datasets. Data from other on-line social networks (such as LinkedIn and Twitter) should all be studied to determine if they follow the theoretical MGEO-P domination number upper bound. If this is true, then the MGEO-P model will be a sound model to simulate both OSN properties and the domination number. Another question is to determine why agents belong to dominating sets. There might be unique properties about these agents which can play an important role in OSNs. Learning and understanding how agents join or
51

leave dominating sets may allow us to control future network behaviour. These agents are informally the glue of the network, they have the most spread and value in network information diffusion. In summary, the MGEO-P follows properties of OSNs and follows their domination number upper bound. Work in the thesis provides experimental evidence that MGEO-P samples do follow theoretical predicted values of dominating sets, and that OSNs follow the MGEO-P sub-linear domination number bound. In addition to introducing a modified model of the MGEO-P, samples of the DMGEO-P model possesses domination number with order similar to that found in OSNs.

52

APPENDIX A

Data Tables A.1. MGEO-P Data Tables
Dataset Name Nodes Caltech36 769 Reed98 962 Haverford76 1446 Simmons81 1518 Swarthmore42 1659 Amherst41 2235 Bowdoin47 2252 Hamilton46 2314 Trinity100 2613 USFCA72 2682 Williams40 2790 Oberlin44 2920 Smith60 2970 Wellesley22 2970 Vassar85 3068 Middlebury45 3075 Pepperdine86 3445 Colgate88 3482 Santa74 3578 Wesleyan43 3593 Mich67 3748 Bucknell39 3826 Brandeis99 3898 Howard90 4047 Rice31 4087 Rochester38 4563 Lehigh96 5075 Johns-Hopkins55 5180 Wake73 5372 American75 6386 MIT8 6440 Table A.1. General Facebook 100. Edges Min Degree Avg Degree Max Degree Density 16656 1 43 120 0.056 18812 0 39 228 0.041 59589 0 82 205 0.057 32988 0 43 195 0.029 61050 1 74 298 0.044 90954 1 81 333 0.036 84387 1 75 282 0.033 96394 1 83 429 0.036 111996 0 86 311 0.033 65252 0 49 378 0.018 112986 1 81 368 0.029 89912 0 62 339 0.021 97133 1 65 234 0.022 94899 0 64 340 0.022 119161 1 78 355 0.025 124610 0 81 291 0.026 152007 0 88 386 0.026 155043 1 89 409 0.026 151747 0 85 375 0.024 138035 0 77 427 0.021 81903 1 44 228 0.012 158864 0 83 354 0.022 137567 0 71 368 0.018 204850 0 101 382 0.025 184828 0 90 400 0.022 161404 0 71 275 0.016 198347 1 78 351 0.015 186586 0 72 363 0.014 279191 1 104 447 0.019 217662 0 68 561 0.011 251252 0 78 379 0.012 graph properties computed for MGEO-P samples of

53

Dataset Name Nodes William77 6472 UChicago30 6591 Princeton12 6596 Carnegie49 6637 Tufts18 6682 UC64 6833 Vermont70 7324 Emory27 7460 Dartmouth6 7694 Tulane29 7752 WashU32 7755 Villanova62 7772 Vanderbilt48 8069 Yale4 8578 Brown11 8600 UCSC68 8991 Maine59 9069 Georgetown15 9414 Duke14 9895 Bingham82 10004 Mississippi66 10521 Northwestern25 10567 Cal65 11247 BC17 11509 Stanford3 11621 Columbia2 11770 Notre-Dame57 12155 GWU54 12193 Baylor93 12803 USF51 13377 Syracuse56 13653 Temple83 13686 UC61 13746 Northeastern19 13882 JMU79 14070 UPenn7 14916 UCSB37 14935 UCF52 14940 UCSD34 14948 Harvard1 15126 Table A.2. General Facebook 100.

Edges Min Degree Avg Degree Max Degree Density 266378 0 82 490 0.013 208103 0 63 508 0.010 293320 0 89 487 0.013 249967 0 75 454 0.011 249728 0 75 355 0.011 155332 0 45 205 0.007 191221 0 52 374 0.007 330014 0 88 448 0.012 304076 1 79 436 0.010 283918 1 73 291 0.009 367541 0 95 476 0.012 314989 0 81 444 0.010 427832 0 106 531 0.013 405450 1 95 547 0.011 384526 0 89 672 0.010 224584 0 50 285 0.006 243247 0 54 429 0.006 425638 0 90 619 0.010 506442 0 102 521 0.010 362894 0 73 419 0.007 610911 0 116 744 0.011 488337 1 92 435 0.009 351358 1 62 219 0.006 486967 0 85 505 0.007 568330 1 98 516 0.008 444333 1 76 804 0.006 541339 0 89 628 0.007 469528 1 77 761 0.006 679817 1 106 471 0.008 321214 0 48 351 0.004 543982 0 80 497 0.006 360795 0 53 676 0.004 442174 0 64 402 0.005 381934 0 55 482 0.004 485564 0 69 548 0.005 686501 0 92 536 0.006 482224 0 65 386 0.004 428989 0 57 318 0.004 443221 0 59 392 0.004 824617 0 109 608 0.007 graph properties computed for MGEO-P samples of

54

Dataset Name Nodes Edges Min Degree Avg Degree Max Degree Density MU78 15436 649449 0 84 456 0.005 UMass92 16516 519385 0 63 521 0.004 UC33 16808 522147 0 62 381 0.004 Tennessee95 16979 770659 0 91 779 0.005 UVA16 17196 789321 1 92 549 0.005 UConn91 17212 604870 0 70 469 0.004 Oklahoma97 17425 892528 0 102 656 0.006 USC35 17444 801853 0 92 467 0.005 UNC28 18163 766800 0 84 901 0.005 Auburn71 18448 973918 0 106 581 0.006 Cornell5 18660 790777 0 85 730 0.005 BU10 19700 637528 0 65 360 0.003 UCLA26 20467 747613 0 73 448 0.004 Maryland58 20871 744862 0 71 628 0.003 Virginia63 21325 698178 0 65 501 0.003 NYU9 21679 715715 0 66 1173 0.003 Berkeley13 22937 852444 0 74 916 0.003 Wisconsin87 23842 835952 0 70 841 0.003 UGA50 24389 1174057 1 96 572 0.004 Rutgers89 24580 784602 0 64 459 0.003 FSU53 27737 1034802 0 75 526 0.003 Indiana69 29747 1305765 0 88 620 0.003 Michigan23 30147 1176516 0 78 633 0.003 UIllinois20 30809 1264428 0 82 459 0.003 Texas80 31560 1219650 0 77 603 0.002 MSU24 32375 1118774 0 69 616 0.002 UF21 35123 1465660 0 83 680 0.002 Texas84 36371 1590655 0 87 802 0.002 Penn94 41554 1362229 0 66 986 0.002 Table A.3. General graph properties computed for MGEO-P samples of Facebook 100.

55

0-core 0-core 0-core 0-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 769 74 4563 376 10004 903 17196 1420 962 117 5075 394 10521 809 17212 1613 1446 98 5180 427 10567 717 17425 1493 1518 171 5372 419 11247 874 17444 1079 1659 149 6386 609 11509 919 18163 1435 2235 208 6440 516 11621 885 18448 1292 2252 206 6472 559 11770 515 18660 1457 2314 206 6591 644 12155 1068 19700 1751 2613 200 6596 547 12193 835 20467 1870 2682 343 6637 582 12803 908 20871 1832 2790 248 6682 576 13377 1531 21325 2165 2920 304 6833 697 13653 1111 21679 2348 2970 302 7324 774 13686 1423 22937 2307 2970 253 7460 620 13746 1371 23842 2231 3068 254 7694 663 13882 1599 24389 1665 3075 257 7752 614 14070 1182 24580 2187 3445 311 7755 559 14916 1267 27737 2252 3482 276 7772 641 14935 1327 29747 2225 3578 284 8069 598 14940 1338 30147 2894 3593 359 8578 630 14948 1347 30809 2613 3748 429 8600 804 15126 1160 31560 2119 3826 363 8991 995 15436 1066 32375 2987 3898 359 9069 777 16516 1749 35123 3007 4047 325 9414 824 16808 1769 36371 3320 4087 308 9895 686 16979 1348 41554 4116 Table A.4. Dominating set sizes from the DS-RAI algorithm for the 0-core of MGEO-P samples of the Facebook 100 network.

56

1-core 1-core 1-core 1-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 769 74 4562 375 10001 900 17196 1410 961 119 5075 398 10520 808 17201 1615 1445 97 5179 421 10567 730 17422 1484 1517 170 5372 419 11247 882 17443 1076 1659 149 6384 603 11508 922 18160 1441 2235 210 6439 507 11621 884 18446 1292 2252 210 6471 552 11770 499 18658 1465 2314 206 6590 641 12151 1051 19696 1748 2612 199 6595 550 12193 835 20459 1857 2679 339 6635 580 12803 908 20866 1815 2790 257 6680 571 13374 1538 21316 2152 2919 305 6828 695 13650 1110 21674 2335 2969 301 7323 775 13682 1418 22930 2299 2970 253 7456 618 13738 1366 23828 2202 3068 256 7694 663 13874 1586 24389 1666 3074 258 7752 603 14064 1177 24577 2160 3444 299 7754 547 14908 1257 27733 2241 3482 276 7771 642 14930 1316 29740 2215 3577 281 8066 603 14938 1337 30135 2880 3592 356 8578 630 14944 1347 30799 2616 3748 434 8595 799 15121 1157 31558 2127 3825 359 8988 986 15435 1078 32369 2995 3894 355 9065 770 16508 1734 35115 3006 4045 323 9411 819 16801 1760 36361 3315 4085 314 9893 684 16977 1345 41538 4107 Table A.5. Dominating set sizes from the DS-RAI algorithm for the 1-core of MGEO-P samples of the Facebook 100 network.

57

2-core 2-core 2-core 2-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 766 72 4547 361 9967 868 17126 1536 957 115 5063 385 10504 793 17152 1361 1443 95 5162 409 10544 693 17375 1437 1509 162 5358 410 11218 850 17415 1046 1653 145 6366 589 11479 898 18102 1384 2227 200 6426 495 11584 845 18418 1274 2248 203 6442 525 11759 487 18607 1409 2306 198 6555 607 12117 1019 19620 1678 2607 194 6575 524 12170 812 20376 1770 2662 323 6618 565 12778 878 20792 1763 2783 244 6661 553 13280 1450 21223 2070 2902 289 6793 653 13608 1356 21551 2230 2960 293 7276 724 13617 1073 22839 2205 2961 244 7433 596 13697 1327 23723 2110 3054 242 7667 626 13799 1522 24334 1610 3069 249 7735 591 14008 1117 24476 2061 3433 288 7738 531 14870 1264 27648 2152 3472 266 7745 619 14872 1220 29678 2152 3563 267 8047 577 14885 1281 30020 2775 3578 344 8554 759 14886 1292 30707 2510 3719 405 8559 615 15086 1122 31493 2056 3813 348 8947 961 15394 1029 32256 2906 3877 339 9035 750 16428 1668 34989 2908 4032 311 9385 793 16709 1685 36233 3185 4080 302 9868 659 16938 1312 41344 3928 Table A.6. Dominating set sizes from the DS-RAI algorithm for the 2-core of MGEO-P samples of the Facebook 100 network.

58

3-core 3-core 3-core 3-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 761 67 4537 351 9938 844 17045 1470 947 105 5047 371 10472 764 17101 1318 1442 94 5148 394 10512 679 17323 1386 1494 150 5345 394 11184 818 17387 1015 1649 142 6337 568 11445 859 18043 1331 2222 195 6412 488 11555 820 18377 1225 2239 197 6424 511 11756 479 18561 1374 2298 193 6518 573 12080 995 19558 1619 2605 192 6552 508 12151 793 20314 1722 2632 296 6594 543 12752 858 20700 1684 2771 229 6634 533 13197 1376 21109 1953 2887 275 6764 640 13527 1278 21424 2100 2945 284 7249 700 13575 1039 22717 2090 2948 231 7420 586 13639 1280 23624 2022 3039 226 7641 614 13709 1448 24298 1568 3057 237 7715 577 13965 1085 24400 2027 3419 288 7722 522 14811 1219 27555 2066 3462 257 7724 595 14820 1175 29600 2094 3552 257 8030 566 14826 1234 29913 2680 3563 332 8527 735 14840 1249 30601 2422 3695 381 8545 599 15049 1093 31438 1995 3806 342 8891 906 15356 1006 32119 2784 3856 320 8999 713 16356 1605 34878 2792 4021 300 9358 770 16635 1611 36107 3070 4071 303 9850 643 16897 1278 41137 3747 Table A.7. Dominating set sizes from the DS-RAI algorithm for the 3-core of MGEO-P samples of the Facebook 100 network.

59

4-core 4-core 4-core 4-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 756 66 4518 336 9901 812 16981 1428 935 99 5033 361 10446 742 17056 1279 1442 94 5132 381 10491 647 17276 1353 1484 149 5335 386 11164 797 17359 999 1638 132 6316 540 11410 832 17994 1282 2210 183 6392 471 11522 783 18336 1205 2233 194 6406 499 11748 478 18517 1330 2292 185 6493 554 12034 941 19486 1567 2598 186 6537 489 12117 759 20238 1650 2607 276 6574 525 12721 831 20620 1595 2761 229 6611 513 13103 1304 21025 1892 2864 258 6733 605 13465 1240 21317 2031 2935 273 7204 668 13541 1006 22602 2002 2939 222 7401 566 13586 1237 23528 1956 3029 219 7620 590 13618 1370 24247 1527 3043 230 7693 570 13907 1038 24310 1916 3409 281 7694 559 14756 1165 27465 2013 3455 254 7702 506 14768 1134 29519 2027 3547 253 8013 549 14774 1211 29798 2582 3550 320 8501 714 14793 1216 30504 2331 3669 354 8523 579 15020 1065 31371 1947 3789 327 8842 863 15322 969 31985 2634 3847 313 8966 686 16276 1535 34788 2731 4014 293 9325 738 16529 1530 35994 2967 4060 294 9832 630 16836 1228 40947 3576 Table A.8. Dominating set sizes from the DS-RAI algorithm for the 4-core of MGEO-P samples of the Facebook 100 network.

60

5-core 5-core 5-core 5-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 751 61 4503 324 9872 794 16907 1364 931 98 5015 346 10426 722 17006 1250 1437 89 5117 373 10475 631 17230 1313 1476 140 5323 383 11124 766 17337 973 1629 125 6290 519 11378 799 17942 1249 2203 177 6375 451 11487 760 18298 1176 2222 181 6382 482 11746 495 18472 1297 2289 185 6466 539 11992 906 19431 1530 2581 257 6520 479 12092 742 20174 1596 2589 179 6552 507 12703 810 20551 1552 2755 215 6590 497 13029 1267 20931 1818 2850 246 6698 587 13384 1180 21207 1947 2923 210 7163 643 13496 973 22509 1930 2926 267 7380 552 13524 1195 23437 1861 3015 207 7595 569 13539 1316 24196 1484 3032 225 7668 549 13866 999 24200 1864 3399 270 7670 534 14704 1131 27381 1948 3448 237 7686 492 14719 1161 29439 1955 3530 302 7999 537 14721 1152 29680 2480 3537 245 8474 688 14727 1090 30405 2259 3649 342 8497 553 14984 1022 31303 1895 3772 306 8787 817 15294 950 31845 2557 3827 299 8934 666 16180 1451 34668 2617 4005 286 9293 713 16443 1474 35851 2849 4048 281 9805 600 16785 1178 40769 3450 Table A.9. Dominating set sizes from the DS-RAI algorithm for the 5-core of MGEO-P samples of the Facebook 100 network.

61

0-core 0-core 0-core 0-core Nodes DS-DC Nodes DS-DC Nodes DS-DC Nodes DS-DC 769 49 4563 216 10004 524 17196 814 962 69 5075 241 10521 423 17212 942 1446 62 5180 254 10567 411 17425 788 1518 115 5372 234 11247 561 17444 664 1659 85 6386 333 11509 525 18163 820 2235 104 6440 291 11621 505 18448 717 2252 118 6472 313 11770 276 18660 832 2314 112 6591 373 12155 576 19700 1054 2613 119 6596 297 12193 470 20467 1084 2682 190 6637 320 12803 511 20871 1092 2790 137 6682 343 13377 894 21325 1185 2920 175 6833 441 13653 647 21679 1245 2970 151 7324 436 13686 823 22937 1211 2970 170 7460 341 13746 783 23842 1276 3068 151 7694 374 13882 885 24389 981 3075 150 7752 360 14070 719 24580 1331 3445 165 7755 318 14916 714 27737 1385 3482 160 7772 362 14935 791 29747 1287 3578 171 8069 337 14940 821 30147 1577 3593 199 8578 360 14948 820 30809 1494 3748 257 8600 445 15126 647 31560 1324 3826 186 8991 585 15436 656 32375 1701 3898 209 9069 520 16516 959 35123 1646 4047 181 9414 457 16808 979 36371 1785 4087 176 9895 404 16979 751 41554 2263 Table A.10. Dominating set sizes from the DS-DC algorithm for the 0-core of MGEO-P samples of the Facebook 100 network.

62

1-core 1-core 1-core 1-core Nodes DS-DC Nodes DS-DC Nodes DS-DC Nodes DS-DC 769 48 4562 215 10001 525 17196 812 961 68 5075 240 10520 424 17201 932 1445 60 5179 256 10567 413 17422 785 1517 115 5372 235 11247 559 17443 660 1659 85 6384 332 11508 521 18160 818 2235 104 6439 290 11621 505 18446 715 2252 118 6471 313 11770 276 18658 835 2314 112 6590 372 12151 571 19696 1050 2612 118 6595 300 12193 472 20459 1082 2679 188 6635 319 12803 509 20866 1088 2790 137 6680 341 13374 890 21316 1173 2919 174 6828 442 13650 647 21674 1238 2969 168 7323 439 13682 819 22930 1208 2970 153 7456 336 13738 773 23828 1253 3068 151 7694 376 13874 875 24389 980 3074 152 7752 361 14064 709 24577 1328 3444 164 7754 319 14908 705 27733 1382 3482 161 7771 362 14930 787 29740 1280 3577 170 8066 335 14938 824 30135 1568 3592 195 8578 358 14944 813 30799 1480 3748 257 8595 438 15121 639 31558 1327 3825 184 8988 580 15435 653 32369 1695 3894 205 9065 519 16508 950 35115 1630 4045 178 9411 454 16801 974 36361 1772 4085 171 9893 404 16977 748 41538 2252 Table A.11. Dominating set sizes from the DS-DC algorithm for the 1-core of MGEO-P samples of the Facebook 100 network.

63

2-core 2-core 2-core 2-core Nodes DS-DC Nodes DS-DC Nodes DS-DC Nodes DS-DC 766 49 4547 203 9967 501 17126 882 957 66 5063 232 10504 414 17152 791 1443 61 5162 247 10544 398 17375 763 1509 106 5358 228 11218 546 17415 646 1653 81 6366 319 11479 510 18102 783 2227 100 6426 283 11584 489 18418 696 2248 117 6442 297 11759 269 18607 802 2306 106 6555 347 12117 554 19620 1001 2607 114 6575 280 12170 466 20376 1024 2662 179 6618 312 12778 497 20792 1051 2783 133 6661 328 13280 842 21223 1134 2902 163 6793 420 13608 782 21551 1178 2960 164 7276 414 13617 622 22839 1155 2961 150 7433 326 13697 750 23723 1202 3054 147 7667 359 13799 838 24334 947 3069 147 7735 353 14008 684 24476 1270 3433 160 7738 310 14870 748 27648 1335 3472 149 7745 349 14872 689 29678 1246 3563 162 8047 321 14885 797 30020 1501 3578 188 8554 411 14886 785 30707 1421 3719 241 8559 353 15086 615 31493 1288 3813 180 8947 555 15394 640 32256 1626 3877 197 9035 507 16428 897 34989 1579 4032 171 9385 441 16709 936 36233 1714 4080 172 9868 388 16938 727 41344 2139 Table A.12. Dominating set sizes from the DS-DC algorithm for the 2-core of MGEO-P samples of the Facebook 100 network.

64

3-core 3-core 3-core 3-core Nodes DS-DC Nodes DS-DC Nodes DS-DC Nodes DS-DC 761 45 4537 203 9938 493 17045 849 947 65 5047 225 10472 402 17101 768 1442 60 5148 235 10512 384 17323 730 1494 95 5345 219 11184 531 17387 633 1649 80 6337 306 11445 495 18043 745 2222 97 6412 276 11555 472 18377 676 2239 111 6424 283 11756 269 18561 781 2298 103 6518 325 12080 541 19558 975 2605 113 6552 274 12151 453 20314 988 2632 158 6594 300 12752 481 20700 1005 2771 126 6634 312 13197 812 21109 1074 2887 155 6764 402 13527 740 21424 1113 2945 159 7249 405 13575 610 22717 1090 2948 144 7420 325 13639 726 23624 1151 3039 140 7641 345 13709 786 24298 938 3057 139 7715 346 13965 660 24400 1231 3419 155 7722 301 14811 728 27555 1281 3462 145 7724 334 14820 668 29600 1208 3552 154 8030 314 14826 772 29913 1442 3563 180 8527 397 14840 763 30601 1369 3695 227 8545 345 15049 596 31438 1260 3806 178 8891 528 15356 616 32119 1566 3856 191 8999 486 16356 864 34878 1516 4021 161 9358 423 16635 896 36107 1646 4071 170 9850 377 16897 717 41137 2045 Table A.13. Dominating set sizes from the DS-DC algorithm for the 3-core of MGEO-P samples of the Facebook 100 network.

65

4-core 4-core 4-core 4-core Nodes DS-DC Nodes DS-DC Nodes DS-DC Nodes DS-DC 756 50 4518 199 9901 471 17056 743 935 58 5033 215 11164 525 16981 819 1484 90 5132 231 10491 379 17276 712 1442 60 5335 216 11410 471 17359 621 1638 74 6493 311 10446 388 17994 718 2607 147 6316 300 11748 263 18517 751 2233 106 6392 262 12117 443 18336 662 2210 94 6574 294 11522 462 19486 937 2292 102 6406 277 12034 517 20238 959 2598 109 6537 266 12721 472 21025 1038 2864 144 6733 391 13103 762 20620 968 2939 137 7204 381 13465 708 21317 1056 2935 152 6611 306 13541 586 22602 1044 2761 121 7694 350 13618 751 23528 1103 3669 220 7620 334 13586 703 24247 912 3029 135 7401 311 13907 629 24310 1192 3043 130 7693 321 14774 745 27465 1242 3550 168 7702 290 14756 702 29798 1411 3409 152 8013 310 14768 647 29519 1175 3547 153 8523 337 14793 740 31371 1232 3455 143 8842 510 15020 592 30504 1343 3847 188 8966 473 16529 853 31985 1519 3789 171 8501 381 16276 837 34788 1476 4060 166 9325 404 15322 595 35994 1611 4014 159 9832 365 16836 693 40947 1966 Table A.14. Dominating set sizes from the DS-DC algorithm for the 4-core of MGEO-P samples of the Facebook 100 network.

66

5-core 5-core 5-core 5-core Nodes DS-DC Nodes DS-DC Nodes DS-DC Nodes DS-DC 751 47 4503 196 9872 457 16907 786 931 57 5015 209 10426 378 17006 721 1437 56 5117 224 10475 374 17230 694 1476 89 5323 208 11124 516 17337 605 1629 67 6290 289 11378 456 17942 698 2203 91 6375 256 11487 439 18298 646 2222 105 6382 265 11746 262 18472 741 2289 99 6466 304 11992 499 19431 918 2581 137 6520 258 12092 428 20174 941 2589 106 6552 290 12703 464 20551 944 2755 116 6590 298 13029 741 20931 1013 2850 140 6698 379 13384 673 21207 1019 2923 133 7163 365 13496 575 22509 1012 2926 150 7380 302 13524 690 23437 1068 3015 128 7595 331 13539 726 24196 897 3032 124 7668 310 13866 617 24200 1148 3399 146 7670 337 14704 684 27381 1213 3448 140 7686 284 14719 721 29439 1141 3530 157 7999 301 14721 717 29680 1357 3537 144 8474 373 14727 621 30405 1304 3649 205 8497 324 14984 572 31303 1199 3772 168 8787 491 15294 584 31845 1474 3827 185 8934 461 16180 812 34668 1415 4005 158 9293 394 16443 820 35851 1550 4048 160 9805 347 16785 665 40769 1892 Table A.15. Dominating set sizes from the DS-DC algorithm for the 5-core of MGEO-P samples of the Facebook 100 network.

67

Dataset Name Nodes Edges Average Degree Maximum Degree Density Caltech36 769 16656 43 248 0.056 Reed98 962 18812 39 313 0.041 Haverford76 1446 59589 82 375 0.057 Simmons81 1518 32988 43 300 0.029 Swarthmore42 1659 61050 74 577 0.044 Amherst41 2235 90954 81 467 0.036 Bowdoin47 2252 84387 75 670 0.033 Hamilton46 2314 96394 83 602 0.036 Trinity100 2613 111996 86 404 0.033 USFCA72 2682 65252 49 405 0.018 Williams40 2790 112986 81 610 0.029 Oberlin44 2920 89912 62 478 0.021 Smith60 2970 97133 65 349 0.022 Wellesley22 2970 94899 64 746 0.022 Vassar85 3068 119161 78 482 0.025 Middlebury45 3075 124610 81 473 0.026 Pepperdine86 3445 152007 88 674 0.026 Colgate88 3482 155043 89 773 0.026 Santa74 3578 151747 85 1129 0.024 Wesleyan43 3593 138035 77 549 0.021 Mich67 3748 81903 44 419 0.012 Bucknell39 3826 158864 83 506 0.022 Brandeis99 3898 137567 71 1972 0.018 Howard90 4047 204850 101 1215 0.025 Rice31 4087 184828 90 581 0.022 Rochester38 4563 161404 71 1224 0.016 Lehigh96 5075 198347 78 973 0.015 Johns-Hopkins55 5180 186586 72 886 0.014 Wake73 5372 279191 104 1341 0.019 American75 6386 217662 68 930 0.011 MIT8 6440 251252 78 708 0.012 William77 6472 266378 82 1124 0.013 UChicago30 6591 208103 63 1624 0.010 Princeton12 6596 293320 89 628 0.013 Carnegie49 6637 249967 75 840 0.011 Tufts18 6682 249728 75 827 0.011 UC64 6833 155332 45 660 0.007 Vermont70 7324 191221 52 864 0.007 Emory27 7460 330014 88 1095 0.012 Table A.16. General graph properties computed for Facebook 100.

A.2. Facebook 100 Data Tables
68

Dataset Name Nodes Edges Average Degree Maximum Degree Density Dartmouth6 7694 304076 79 948 0.010 Tulane29 7752 283918 73 1188 0.009 WashU32 7755 367541 95 1794 0.012 Villanova62 7772 314989 81 1183 0.010 Vanderbilt48 8069 427832 106 2041 0.013 Yale4 8578 405450 95 2517 0.011 Brown11 8600 384526 89 1075 0.010 UCSC68 8991 224584 50 454 0.006 Maine59 9069 243247 54 1011 0.006 Georgetown15 9414 425638 90 1235 0.009 Duke14 9895 506442 102 1887 0.010 Bingham82 10004 362894 73 553 0.007 Mississippi66 10521 610911 116 1691 0.011 Northwestern25 10567 488337 92 2105 0.009 Cal65 11247 351358 62 415 0.006 BC17 11509 486967 85 1377 0.007 Stanford3 11621 568330 98 1172 0.008 Columbia2 11770 444333 76 3375 0.006 Notre-Dame57 12155 541339 89 1344 0.007 GWU54 12193 469528 77 2002 0.006 Baylor93 12803 679817 106 2109 0.008 USF51 13377 321214 48 897 0.004 Syracuse56 13653 543982 80 1340 0.006 Temple83 13686 360795 53 1394 0.004 UC61 13746 442174 64 687 0.005 Northeastern19 13882 381934 55 968 0.004 JMU79 14070 485564 69 3274 0.005 UPenn7 14916 686501 92 1602 0.006 UCSB37 14935 482224 65 810 0.004 UCF52 14940 428989 57 4765 0.004 UCSD34 14948 443221 59 2165 0.004 Harvard1 15126 824617 109 1183 0.007 MU78 15436 649449 84 653 0.005 UMass92 16516 519385 63 3684 0.004 UC33 16808 522147 62 1415 0.004 Tennessee95 16979 770659 91 4943 0.005 UVA16 17196 789321 92 3182 0.005 UConn91 17212 604870 70 1709 0.004 Oklahoma97 17425 892528 102 2568 0.006 USC35 17444 801853 92 4459 0.005 Table A.17. General graph properties computed for Facebook 100 (continued).

69

Dataset Name Nodes Edges Average Degree Maximum Degree Density UNC28 18163 766800 84 3795 0.005 Auburn71 18448 973918 106 5160 0.006 Cornell5 18660 790777 85 3156 0.005 BU10 19700 637528 65 1819 0.003 UCLA26 20467 747613 73 1180 0.004 Maryland58 20871 744862 71 3784 0.003 Virginia63 21325 698178 65 7206 0.003 NYU9 21679 715715 66 2315 0.003 Berkeley13 22937 852444 74 3434 0.003 Wisconsin87 23842 835952 70 3484 0.003 UGA50 24389 1174057 96 2926 0.004 Rutgers89 24580 784602 64 1642 0.003 FSU53 27737 1034802 75 2555 0.003 Indiana69 29747 1305765 88 1358 0.003 Michigan23 30147 1176516 78 2031 0.003 UIllinois20 30809 1264428 82 4632 0.003 Texas80 31560 1219650 77 1796 0.002 MSU24 32375 1118774 69 5267 0.002 UF21 35123 1465660 83 8246 0.002 Texas84 36371 1590655 87 6312 0.002 Penn94 41554 1362229 66 4410 0.002 Table A.18. General graph properties computed for Facebook 100 (continued).

70

1-core 1-core 1-core 1-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 769 131 4563 610 10004 1405 17196 2442 962 150 5075 579 10521 1392 17212 2505 1446 143 5180 842 10567 1503 17425 2549 1518 221 5372 573 11247 1672 17444 2679 1659 187 6386 989 11509 1524 18163 2660 2235 240 6440 1118 11621 1967 18448 2310 2252 254 6472 774 11770 1972 18660 2628 2314 242 6591 1144 12155 1495 19700 2984 2613 267 6596 904 12193 1816 20467 3437 2682 458 6637 1056 12803 1598 20871 3183 2790 285 6682 951 13377 2670 21325 3275 2920 422 6833 1334 13653 1801 21679 3631 2970 378 7324 1182 13686 2658 22937 3739 2970 348 7460 1086 13746 2367 23842 3376 3068 321 7694 1364 13882 2263 24389 3017 3075 394 7752 1186 14070 1861 24580 4077 3445 466 7755 974 14916 2246 27737 4215 3482 348 7772 1051 14935 2388 29747 3972 3578 427 8069 979 14940 2534 30147 4719 3593 386 8578 1218 14948 2545 30809 4103 3748 650 8600 1186 15126 2513 31560 4678 3826 368 8991 1468 15436 1926 32375 4785 3898 475 9069 1508 16516 2500 35123 4919 4047 534 9414 1227 16808 2757 36371 5231 4087 494 9895 1369 16979 2370 41554 6755 Table A.19. Dominating set sizes from the DS-RAI algorithm for the 1-core of Facebook 100 graphs.

71

2-core 2-core 2-core 2-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 734 102 4484 535 9800 1231 16801 2084 927 127 4979 678 10270 1265 16832 2174 1428 126 5001 506 10356 1245 16942 2259 1468 185 5291 504 10996 1456 17032 2232 1644 176 6129 873 11087 1554 17799 2364 2199 210 6194 840 11185 1561 18138 2216 2214 227 6318 938 11253 1311 18187 2068 2281 216 6371 686 11842 1520 19176 2581 2575 232 6392 737 11951 1318 19818 2900 2589 379 6426 884 12636 1444 20311 2759 2743 245 6490 796 12892 2252 20789 2804 2857 349 6514 1087 13171 2255 20892 2974 2910 294 7104 996 13277 1983 22243 3164 2915 334 7260 912 13376 1564 23326 2955 3013 345 7370 1083 13511 1968 23902 3494 3034 298 7562 1041 13868 1665 23966 2644 3342 381 7570 889 14398 1816 27175 3707 3439 310 7578 826 14443 1965 29184 3483 3522 381 7903 854 14503 2177 29288 3998 3526 333 8292 996 14533 2054 30203 3592 3629 552 8380 1010 14600 2243 30898 4116 3794 398 8716 1240 15199 1730 31640 4155 3795 337 8813 1275 16168 2197 34514 4361 3956 458 9141 1019 16342 2375 35694 4614 4006 427 9621 1139 16638 2080 40458 5782 Table A.20. Dominating set sizes from the DS-RAI algorithm for the 2-core of Facebook 100 graphs.

72

3-core 3-core 3-core 3-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 699 83 4415 490 9665 1111 39703 5236 906 114 4840 587 10082 1128 16540 1910 1414 120 4945 475 10243 1144 16587 1986 1438 165 5242 467 10767 1332 16637 2013 1630 163 5953 761 10816 1345 16785 2040 2176 188 6061 746 10852 1355 17536 2164 2192 211 6153 824 11108 1215 17811 1988 2264 205 6266 924 11624 1362 18022 1939 2526 336 6275 665 11833 1224 18808 2317 2548 211 6281 784 12495 1995 19342 2566 2719 221 6308 646 12502 1345 19998 2525 2817 337 6379 725 12777 1980 20405 2652 2863 306 6964 898 12962 1743 20432 2532 2880 266 7121 811 13174 1424 21800 2841 2971 308 7180 941 13242 1777 22964 2693 3005 276 7403 922 13734 1572 23440 3158 3276 339 7444 724 14002 1649 23718 2461 3424 298 7457 808 14105 1635 26771 3344 3484 304 7802 778 14209 1974 28750 3607 3491 355 8114 871 14272 1855 28796 3197 3544 496 8250 918 14299 2036 29781 3259 3741 364 8517 1122 15031 1609 30457 3785 3774 323 8642 1157 15925 2005 31157 3773 3902 414 8984 918 16008 2110 34080 4019 3954 395 9459 1027 16408 1897 35240 4239 Table A.21. Dominating set sizes from the DS-RAI algorithm for the 3-core of Facebook 100 graphs.

73

4-core 4-core 4-core 4-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 684 75 4364 454 9555 1049 16337 1775 891 103 4765 539 9925 1034 16365 1842 1408 113 4895 439 10145 1067 16392 1866 1411 150 5203 444 10518 1186 16570 1901 1614 155 5842 689 10555 1206 17318 2008 2153 179 5954 677 10639 1247 17583 1840 2170 199 5994 740 10993 1134 17878 1837 2241 187 6070 823 11465 1255 18530 2162 2470 304 6181 604 11727 1152 18985 2345 2530 200 6189 718 12170 1815 19712 2322 2701 214 6235 603 12397 1271 20064 2436 2772 312 6291 674 12442 1769 20123 2338 2831 296 6840 812 12697 1622 21430 2620 2851 243 7020 742 12975 1619 22661 2499 2936 285 7039 849 13006 1317 23047 2916 2990 267 7286 864 13608 1487 23511 2310 3224 302 7367 754 13689 1471 26435 3145 3404 287 7372 685 13862 1468 28272 3313 3455 334 7701 719 13912 1802 28486 2971 3460 291 7970 783 14025 1704 29483 3061 3462 459 8131 840 14047 1872 30046 3537 3692 336 8351 1032 14886 1511 30750 3500 3744 300 8496 1060 15692 1863 33712 3791 3858 386 8869 848 15723 1941 34844 3977 3905 366 9291 944 16224 1769 39081 4825 Table A.22. Dominating set sizes from the DS-RAI algorithm for the 4-core of Facebook 100 graphs.

74

5-core 5-core 5-core 5-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 674 68 4319 423 9459 991 16159 1731 879 97 4687 503 9803 965 16174 1664 1392 140 4856 413 10065 1013 16228 1765 1399 106 5168 416 10297 1076 16408 1795 1603 150 5746 633 10342 1092 17108 1886 2138 162 5844 623 10470 1137 17356 1717 2154 186 5877 678 10883 1067 17746 1741 2225 176 5898 767 11318 1178 18238 1968 2424 277 6089 634 11635 1105 18662 2169 2515 195 6111 559 11848 1645 19449 2184 2676 189 6182 566 12162 1618 19716 2257 2736 291 6194 633 12308 1217 19890 2205 2792 261 6726 753 12443 1457 21077 2389 2829 234 6909 776 12733 1492 22413 2336 2905 281 6942 694 12867 1240 22679 2690 2968 248 7165 794 13424 1346 23326 2196 3193 281 7278 702 13499 1402 26107 2954 3380 267 7300 638 13654 1661 27848 3070 3387 420 7625 681 13676 1375 28221 2828 3426 316 7870 744 13782 1575 29219 2893 3427 275 8063 797 13802 1737 29683 3321 3653 314 8174 937 14769 1441 30372 3273 3715 280 8369 985 15417 1792 33323 3555 3816 356 8754 792 15502 1753 34518 3770 3867 338 9162 893 16052 1682 38475 4521 Table A.23. Dominating set sizes from the DS-RAI algorithm for the 5-core of Facebook 100 graphs.

75

1-core 1-core 1-core 1-core Nodes DS-DC Nodes DS-DC Nodes DS-DC Nodes DS-DC 769 65 4563 297 10004 754 17196 1215 962 86 5075 293 10521 671 17212 1300 1446 71 5180 455 10567 754 17425 1297 1518 123 5372 295 11247 942 17444 1336 1659 93 6386 556 11509 783 18163 1300 2235 126 6440 581 11621 1047 18448 1127 2252 125 6472 371 11770 1034 18660 1369 2314 126 6591 596 12155 724 19700 1591 2613 146 6596 474 12193 924 20467 1918 2682 267 6637 514 12803 779 20871 1679 2790 142 6682 524 13377 1465 21325 1682 2920 210 6833 775 13653 967 21679 1911 2970 187 7324 672 13686 1400 22937 1896 2970 207 7460 533 13746 1316 23842 1774 3068 176 7694 657 13882 1243 24389 1571 3075 203 7752 610 14070 970 24580 2192 3445 236 7755 507 14916 1168 27737 2155 3482 177 7772 554 14935 1308 29747 2081 3578 217 8069 511 14940 1388 30147 2476 3593 220 8578 611 14948 1401 30809 2150 3748 370 8600 621 15126 1306 31560 2515 3826 196 8991 839 15436 1017 32375 2543 3898 264 9069 806 16516 1295 35123 2509 4047 290 9414 656 16808 1495 36371 2591 4087 247 9895 684 16979 1198 41554 3506 Table A.24. Dominating set sizes from the DS-DC algorithm for the 1-core of Facebook 100 graphs.

76

2-core 2-core 2-core 2-core Nodes DS-DC Nodes DS-DC Nodes DS-DC Nodes DS-DC 734 51 4484 251 9800 661 16801 998 927 70 4979 331 10270 593 16832 1099 1428 59 5001 258 10356 580 16942 1091 1468 94 5291 251 10996 800 17032 1086 1644 82 6129 411 11087 756 17799 1092 2199 104 6194 457 11185 782 18138 1113 2214 107 6318 447 11253 644 18187 969 2281 110 6371 324 11842 771 19176 1328 2575 123 6392 362 11951 613 19818 1581 2589 221 6426 407 12636 688 20311 1387 2743 120 6490 413 12892 1218 20789 1408 2857 169 6514 622 13171 1118 20892 1520 2910 151 7104 541 13277 1062 22243 1536 2915 184 7260 440 13376 835 23326 1508 3013 163 7370 492 13511 1044 23902 1815 3034 159 7562 525 13868 850 23966 1346 3342 176 7570 443 14398 898 27175 1906 3439 151 7578 411 14443 943 29184 1789 3522 178 7903 421 14503 1170 29288 2038 3526 186 8292 477 14533 1107 30203 1829 3629 315 8380 505 14600 1222 30898 2180 3794 206 8716 698 15199 896 31640 2148 3795 176 8813 661 16168 1110 34514 2167 3956 231 9141 518 16342 1246 35694 2253 4006 218 9621 519 16638 1013 40458 2927 Table A.25. Dominating set sizes from the DS-DC algorithm for the 2-core of Facebook 100 graphs.

77

3-core 3-core 3-core 3-core Nodes DS-DC Nodes DS-DC Nodes DS-DC Nodes DS-DC 699 43 4415 225 9665 607 16540 884 906 64 4840 273 10082 508 16587 985 1414 56 4945 237 10243 536 16637 975 1438 85 5242 231 10767 635 16785 985 1630 73 5953 338 10816 741 17536 1024 2176 94 6061 401 10852 667 17811 981 2192 97 6153 392 11108 594 18022 882 2264 105 6266 515 11624 673 18808 1175 2526 193 6275 319 11833 563 19342 1365 2548 107 6281 356 12495 1054 19998 1266 2719 110 6308 298 12502 620 20405 1314 2817 156 6379 365 12777 960 20432 1258 2863 155 6964 469 12962 926 21800 1337 2880 145 7121 376 13174 752 22964 1368 2971 142 7180 407 13242 936 23440 1637 3005 146 7403 448 13734 804 23718 1235 3276 143 7444 352 14002 783 26771 1740 3424 143 7457 392 14105 779 28750 1825 3484 165 7802 374 14209 1071 28796 1610 3491 169 8114 404 14272 998 29781 1669 3544 285 8250 452 14299 1117 30457 2020 3741 183 8517 616 15031 836 31157 1949 3774 171 8642 587 15925 1007 34080 1987 3902 208 8984 463 16008 1117 35240 2059 3954 198 9459 463 16408 911 39703 2618 Table A.26. Dominating set sizes from the DS-DC algorithm for the 3-core of Facebook 100 graphs.

78

4-core 4-core 4-core 4-core Nodes DS-DC Nodes DS-DC Nodes DS-DC Nodes DS-DC 684 35 4364 208 9555 563 16337 829 891 61 4765 254 9925 442 16365 883 1408 56 4895 224 10145 495 16392 928 1411 78 5203 215 10518 562 16570 903 1614 71 5842 304 10555 580 17318 941 2153 85 5954 366 10639 675 17583 898 2170 92 5994 340 10993 548 17878 832 2241 92 6070 441 11465 604 18530 1084 2470 171 6181 294 11727 526 18985 1253 2530 103 6189 333 12170 945 19712 1166 2701 105 6235 282 12397 588 20064 1194 2772 150 6291 339 12442 848 20123 1165 2831 146 6840 432 12697 831 21430 1230 2851 132 7020 340 12975 861 22661 1262 2936 133 7039 365 13006 680 23047 1508 2990 148 7286 404 13608 745 23511 1147 3224 134 7367 362 13689 696 26435 1624 3404 136 7372 328 13862 712 28272 1650 3455 157 7701 338 13912 967 28486 1503 3460 158 7970 356 14025 886 29483 1563 3462 260 8131 412 14047 1036 30046 1902 3692 169 8351 556 14886 791 30750 1807 3744 162 8496 544 15692 931 33712 1857 3858 190 8869 430 15723 1027 34844 1916 3905 178 9291 420 16224 836 39081 2407 Table A.27. Dominating set sizes from the DS-DC algorithm for the 4-core of Facebook 100 graphs.

79

5-core 5-core 5-core 5-core Nodes DS-DC Nodes DS-DC Nodes DS-DC Nodes DS-DC 674 33 4319 191 9459 534 16159 810 879 56 4687 230 9803 407 16174 787 1392 69 4856 211 10065 472 16228 886 1399 51 5168 204 10297 491 16408 853 1603 69 5746 282 10342 523 17108 880 2138 80 5844 334 10470 624 17356 842 2154 90 5877 303 10883 509 17746 786 2225 90 5898 403 11318 562 18238 1000 2424 158 6089 307 11635 503 18662 1156 2515 96 6111 275 11848 866 19449 1078 2676 91 6182 264 12162 770 19716 1082 2736 137 6194 312 12308 547 19890 1081 2792 138 6726 403 12443 760 21077 1122 2829 125 6909 320 12733 794 22413 1190 2905 124 6942 323 12867 642 22679 1406 2968 137 7165 380 13424 630 23326 1106 3193 126 7278 338 13499 717 26107 1552 3380 126 7300 303 13654 878 27848 1536 3387 242 7625 316 13676 651 28221 1428 3426 150 7870 336 13782 822 29219 1492 3427 154 8063 390 13802 960 29683 1792 3653 155 8174 512 14769 756 30372 1679 3715 154 8369 502 15417 944 33323 1744 3816 173 8754 406 15502 865 34518 1804 3867 166 9162 381 16052 782 38475 2228 Table A.28. Dominating set sizes from the DS-DC algorithm for the 5-core of Facebook 100 graphs.

80

A.3. DMGEO-P Data Tables
Dataset Name Nodes Edges Min Degree Avg Degree Max Degree Density Caltech36 769 4142 1 11 28 0.014 Reed98 962 7564 4 16 68 0.016 Haverford76 1446 14927 8 21 52 0.014 Simmons81 1518 10300 2 14 61 0.009 Swarthmore42 1659 21837 9 26 78 0.016 Amherst41 2235 32673 9 29 130 0.013 Bowdoin47 2252 23851 8 21 86 0.009 Hamilton46 2314 30769 9 27 134 0.011 Trinity100 2613 30343 8 23 95 0.009 USFCA72 2682 22240 4 17 114 0.006 Williams40 2790 32770 8 23 112 0.008 Oberlin44 2920 28940 4 20 93 0.007 Smith60 2970 26589 3 18 68 0.006 Wellesley22 2970 29984 5 20 105 0.007 Vassar85 3068 32678 7 21 94 0.007 Middlebury45 3075 34063 6 22 71 0.007 Pepperdine86 3445 44192 8 26 112 0.007 Colgate88 3482 42672 10 25 92 0.007 Santa74 3578 42130 8 24 79 0.007 Wesleyan43 3593 43480 7 24 122 0.007 Mich67 3748 21174 1 11 52 0.003 Bucknell39 3826 46528 9 24 93 0.006 Brandeis99 3898 36284 4 19 91 0.005 Howard90 4047 56430 11 28 103 0.007 Rice31 4087 49878 9 24 84 0.006 Rochester38 4563 37545 3 16 86 0.004 Lehigh96 5075 53745 4 21 73 0.004 Johns-Hopkins55 5180 44719 4 17 102 0.003 Wake73 5372 78506 10 29 134 0.005 American75 6386 55080 2 17 115 0.003 MIT8 6440 58792 4 18 98 0.003 William77 6472 64734 5 20 91 0.003 UChicago30 6591 53290 3 16 108 0.002 Table A.29. General graph properties computed for DMGEO-P Facebook 100 samples.

81

Dataset Name Nodes Edges Min Degree Avg Degree Max Degree Density Princeton12 6596 71730 5 22 116 0.003 Carnegie49 6637 62763 5 19 131 0.003 Tufts18 6682 59879 5 18 80 0.003 UC64 6833 36166 1 11 41 0.002 Vermont70 7324 48241 1 13 93 0.002 Emory27 7460 80004 4 21 81 0.003 Dartmouth6 7694 74083 5 19 104 0.003 Tulane29 7752 63654 2 16 70 0.002 WashU32 7755 84762 6 22 139 0.003 Villanova62 7772 74730 4 19 102 0.002 Vanderbilt48 8069 104241 4 26 155 0.003 Yale4 8578 93824 6 22 102 0.003 Brown11 8600 102424 5 24 170 0.003 UCSC68 8991 55744 1 12 79 0.001 Maine59 9069 48694 1 11 61 0.001 Georgetown15 9414 107699 5 23 159 0.002 Duke14 9895 117759 6 24 108 0.002 Bingham82 10004 88035 3 18 75 0.002 Mississippi66 10521 155807 9 30 152 0.003 Northwestern25 10567 108453 4 21 123 0.002 Cal65 11247 74532 2 13 52 0.001 BC17 11509 113743 4 20 119 0.002 Stanford3 11621 134172 7 23 121 0.002 Columbia2 11770 105214 4 18 205 0.002 Notre-Dame57 12155 123570 4 20 164 0.002 GWU54 12193 104158 3 17 141 0.001 Baylor93 12803 155582 6 24 132 0.002 USF51 13377 82776 1 12 104 0.001 Syracuse56 13653 126100 4 18 88 0.001 Temple83 13686 81345 1 12 135 0.001 UC61 13746 111133 1 16 111 0.001 Northeastern19 13882 98728 2 14 134 0.001 Table A.30. General graph properties computed for DMGEO-P Facebook 100 samples (continued).

82

Dataset Name Nodes Edges Min Degree Avg Degree Max Degree Density JMU79 14070 100381 2 14 102 0.001 UPenn7 14916 173402 6 23 119 0.002 UCSB37 14935 111503 3 15 95 0.001 UCF52 14940 87574 0 12 64 0.001 UCSD34 14948 92593 0 12 89 0.001 Harvard1 15126 198767 5 26 122 0.002 MU78 15436 126959 2 16 99 0.001 UMass92 16516 123744 2 15 150 0.001 UC33 16808 122404 1 15 109 0.001 Tennessee95 16979 166551 4 20 161 0.001 UVA16 17196 173907 3 20 128 0.001 UConn91 17212 133615 2 16 107 0.001 Oklahoma97 17425 230563 7 26 169 0.002 USC35 17444 151482 3 17 82 0.001 UNC28 18163 154789 3 17 178 0.001 Auburn71 18448 202971 4 22 188 0.001 Cornell5 18660 166569 2 18 122 0.001 BU10 19700 131217 1 13 82 0.001 UCLA26 20467 163294 2 16 79 0.001 Maryland58 20871 157377 2 15 99 0.001 Virginia63 21325 161292 2 15 159 0.001 NYU9 21679 179477 2 17 243 0.001 Berkeley13 22937 206236 3 18 229 0.001 Wisconsin87 23842 186132 2 16 159 0.001 UGA50 24389 232397 2 19 108 0.001 Rutgers89 24580 162784 2 13 106 0.001 FSU53 27737 206406 1 15 83 0.001 Indiana69 29747 261927 2 18 120 0.001 Michigan23 30147 270614 3 18 139 0.001 UIllinois20 30809 269799 3 18 108 0.001 Texas80 31560 227070 1 14 95 0.000 MSU24 32375 244658 1 15 139 0.000 UF21 35123 316021 2 18 205 0.001 Texas84 36371 368676 4 20 198 0.001 Penn94 41554 288212 1 14 245 0.000 Table A.31. General graph properties computed for DMGEO-P Facebook 100 samples (continued).

83

0-core 0-core 0-core 0-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 769 153 4563 612 10004 1292 17196 2063 962 119 5075 561 10521 937 17212 2467 1446 171 5180 687 10567 1249 17425 1665 1518 214 5372 452 11247 1839 17444 2392 1659 142 6386 823 11509 1407 18163 2403 2235 180 6440 796 11621 1239 18448 2047 2252 248 6472 769 11770 1466 18660 2420 2314 209 6591 901 12155 1402 19700 3204 2613 257 6596 711 12193 1607 20467 2948 2682 337 6637 842 12803 1319 20871 3083 2790 281 6682 854 13377 2240 21325 3096 2920 325 6833 1273 13653 1760 21679 2859 2970 384 7324 1172 13686 2323 22937 2880 2970 337 7460 850 13746 1883 23842 3371 3068 337 7694 928 13882 2060 24389 3057 3075 345 7752 1081 14070 2161 24580 3973 3445 320 7755 859 14916 1598 27737 4188 3482 353 7772 955 14935 2164 29747 3943 3578 370 8069 795 14940 2622 30147 3872 3593 344 8578 946 14948 2520 30809 4123 3748 682 8600 875 15126 1458 31560 4854 3826 378 8991 1502 15436 2195 32375 4750 3898 487 9069 1748 16516 2434 35123 4551 4047 378 9414 1008 16808 2533 36371 4265 4087 413 9895 1035 16979 2030 41554 6336 Table A.32. Dominating set sizes from the DS-RAI algorithm for the 0-core of DMGEO-P Facebook 100 graphs.

84

1-core 1-core 1-core 1-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 769 153 4563 612 10004 1292 17196 2063 962 119 5075 561 10521 937 17212 2467 1446 171 5180 687 10567 1249 17425 1665 1518 214 5372 452 11247 1839 17444 2392 1659 142 6386 823 11509 1407 18163 2403 2235 180 6440 796 11621 1239 18448 2047 2252 248 6472 769 11770 1466 18660 2420 2314 209 6591 901 12155 1402 19700 3204 2613 257 6596 711 12193 1607 20467 2948 2682 337 6637 842 12803 1319 20871 3083 2790 281 6682 854 13377 2240 21325 3096 2920 325 6833 1273 13653 1760 21679 2859 2970 384 7324 1172 13686 2323 22937 2880 2970 337 7460 850 13746 1883 23842 3371 3068 337 7694 928 13882 2060 24389 3057 3075 345 7752 1081 14070 2161 24580 3973 3445 320 7755 859 14916 1598 27737 4188 3482 353 7772 955 14935 2164 29747 3943 3578 370 8069 795 14939 2621 30147 3872 3593 344 8578 946 14947 2519 30809 4123 3748 682 8600 875 15126 1458 31560 4854 3826 378 8991 1502 15436 2195 32375 4750 3898 487 9069 1748 16516 2434 35123 4551 4047 378 9414 1008 16808 2533 36371 4265 4087 413 9895 1035 16979 2030 41554 6336 Table A.33. Dominating set sizes from the DS-RAI algorithm for the 1-core of DMGEO-P Facebook 100 graphs.

85

2-core 2-core 2-core 2-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 768 152 4563 612 10004 1292 17196 2063 962 119 5075 561 10521 937 17212 2467 1446 171 5180 687 10567 1249 17425 1665 1518 214 5372 452 11247 1839 17444 2392 1659 142 6386 823 11509 1407 18163 2403 2235 180 6440 796 11621 1239 18448 2047 2252 248 6472 769 11770 1466 18660 2420 2314 209 6591 901 12155 1402 19699 3203 2613 257 6596 711 12193 1607 20467 2948 2682 337 6637 842 12803 1319 20871 3083 2790 281 6682 854 13372 2237 21325 3096 2920 325 6832 1272 13653 1760 21679 2859 2970 384 7322 1170 13681 2320 22937 2880 2970 337 7460 850 13745 1882 23842 3371 3068 337 7694 928 13882 2060 24389 3057 3075 345 7752 1081 14070 2161 24580 3973 3445 320 7755 859 14916 1598 27736 4187 3482 353 7772 955 14935 2164 29747 3943 3578 370 8069 795 14936 2619 30147 3872 3593 344 8578 946 14941 2515 30809 4123 3745 680 8600 875 15126 1458 31559 4853 3826 378 8989 1500 15436 2195 32373 4748 3898 487 9064 1745 16516 2434 35123 4551 4047 378 9414 1008 16807 2533 36371 4265 4087 413 9895 1035 16979 2030 41552 6334 Table A.34. Dominating set sizes from the DS-RAI algorithm for the 2-core of DMGEO-P Facebook 100 graphs.

86

3-core 3-core 3-core 3-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 764 149 4563 612 10004 1292 17196 2063 962 119 5075 561 10521 937 17211 2466 1446 171 5180 687 10567 1249 17425 1665 1517 214 5372 452 11245 1839 17444 2392 1659 142 6385 822 11509 1407 18163 2403 2235 180 6440 796 11621 1239 18448 2047 2252 248 6472 769 11770 1466 18659 2420 2314 209 6591 901 12155 1402 19693 3202 2613 257 6596 711 12193 1607 20466 2947 2682 337 6637 842 12803 1319 20869 3081 2790 281 6682 854 13364 2234 21324 3095 2920 325 6812 1258 13653 1760 21676 2856 2970 384 7321 1170 13670 2317 22937 2880 2970 337 7460 850 13745 1882 23838 3369 3068 337 7694 928 13878 2059 24388 3056 3075 345 7751 1084 14066 2159 24569 3966 3445 320 7755 859 14916 1598 27735 4186 3482 353 7772 955 14935 2164 29746 3942 3578 370 8069 795 14923 2611 30147 3872 3593 344 8578 946 14928 2509 30809 4123 3735 675 8600 875 15126 1458 31552 4846 3826 378 8983 1497 15435 2194 32368 4743 3898 487 9051 1739 16515 2434 35122 4551 4047 378 9414 1008 16804 2532 36371 4265 4087 413 9895 1035 16979 2030 41541 6327 Table A.35. Dominating set sizes from the DS-RAI algorithm for the 3-core of DMGEO-P Facebook 100 graphs.

87

4-core 4-core 4-core 4-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 760 147 4562 611 10003 1292 17195 2063 962 119 5075 561 10521 937 17204 2460 1446 171 5180 687 10567 1249 17425 1665 1515 213 5372 452 11233 1832 17443 2392 1659 142 6385 822 11509 1407 18159 2400 2235 180 6440 796 11621 1239 18448 2047 2252 248 6472 769 11770 1466 18655 2419 2314 209 6590 900 12155 1402 19667 3193 2613 257 6596 711 12192 1607 20462 2945 2682 337 6637 842 12803 1319 20859 3075 2790 281 6682 854 13330 2214 21315 3090 2920 325 6752 1228 13653 1760 21673 2855 2969 383 7310 1163 13623 2293 22935 2878 2970 337 7460 850 13741 1879 23828 3361 3068 337 7694 928 13863 2049 24386 3055 3075 345 7750 1084 14051 2152 24532 3951 3445 320 7755 859 14916 1598 27721 4181 3482 353 7772 955 14929 2161 29744 3940 3578 370 8069 795 14873 2589 30146 3871 3593 344 8578 946 14895 2502 30804 4119 3707 664 8600 875 15126 1458 31532 4835 3826 378 8965 1489 15434 2194 32355 4737 3898 487 8984 1709 16505 2430 35121 4550 4047 378 9414 1008 16792 2526 36371 4265 4087 413 9895 1035 16979 2030 41485 6303 Table A.36. Dominating set sizes from the DS-RAI algorithm for the 4-core of DMGEO-P Facebook 100 graphs.

88

5-core 5-core 5-core 5-core Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI Nodes DS-RAI 743 142 4559 610 10001 1290 17194 2063 960 119 5073 560 10521 937 17179 2454 1446 171 5179 687 10565 1249 17425 1665 1508 212 5372 452 11202 1820 17439 2390 1659 142 6384 821 11508 1406 18156 2399 2235 180 6439 795 11621 1239 18447 2046 2252 248 6472 769 11766 1464 18653 2419 2314 209 6587 900 12154 1401 19600 3170 2613 257 6596 711 12190 1606 20451 2936 2678 336 6637 842 12803 1319 20834 3058 2790 281 6682 854 13244 2175 21286 3079 2919 324 6609 1194 13650 1758 21652 2846 2969 383 7265 1137 13488 2253 22929 2875 2970 337 7459 851 13731 1872 23807 3355 3068 337 7694 928 13819 2027 24382 3053 3075 345 7747 1082 14029 2144 24432 3910 3445 320 7755 859 14916 1598 27677 4160 3482 353 7771 955 14904 2155 29736 3935 3578 370 8068 794 14732 2536 30140 3866 3593 344 8578 946 14782 2450 30793 4112 3647 635 8600 875 15126 1458 31460 4815 3826 378 8910 1467 15426 2192 32296 4718 3897 487 8815 1640 16475 2424 35118 4549 4047 378 9414 1008 16756 2516 36369 4263 4087 413 9895 1035 16978 2030 41305 6251 Table A.37. Dominating set sizes from the DS-RAI algorithm for the 5-core of DMGEO-P Facebook 100 graphs.

89

APPENDIX B

Program Code The following two sections describe the code used during the research of this thesis. The first section provides Java code that was used along with the JUNG 2.0.1 framework to generate visual MGEO-P and DMGEO-P samples. The second section is the C++ code used injunction with the Stanford Network Analysis Platform (SNAP). The MGEO-P simulations were generated with a Quad Core i7-4700MQ 2.40 GHz 16 GB laptop. The computation of the domination number of the data sets were done using RAMLab equipment. The hardware used during DMGEO-P experiments, simulations and domination, was a 12-core (2x 6core) Xeon X5690 3.46 GHz with 96 GB RAM workstation. An online simulator for the G(n, p), G(n, r) and MGEO-P(n, m, , , p) models were created for presentation purposes. Simulator is located at http://www.math.ryerson.ca/people/mlozier/. B.1. JUNG Code (Java) createGUI.java
1 2 3 4 5

/   @author Marc / package samplegraph ;

91

6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36

import edu . u c i . i c s . jung . a l g o r i t h m s . l a y o u t .  ; import edu . u c i . i c s . jung . graph .  ; import edu . u c i . i c s . jung . v i s u a l i z a t i o n .  ; import edu . u c i . i c s . jung . v i s u a l i z a t i o n . c o n t r o l . C r o s s o v e r S c a l i n g C o n t r o l ; import edu . u c i . i c s . jung . v i s u a l i z a t i o n . c o n t r o l . S c a l i n g C o n t r o l ; import edu . u c i . i c s . jung . v i s u a l i z a t i o n . d e c o r a t o r s . T o S t r i n g L a b e l l e r ; import edu . u c i . i c s . jung . v i s u a l i z a t i o n . r e n d e r e r s . Renderer . V e r t e x L a b e l . P o s i t i o n ; import graphpackage .  ; import j a v a . awt . BorderLayout ; import j a v a . awt . C o l o r ; import j a v a . awt . C o n t a i n e r ; import j a v a . awt . Dimension ; import j a v a . awt . GridLayout ; import j a v a . awt . P ai nt ; import j a v a . awt . e v e n t .  ; import j a v a . awt . geom . Point2D ; import j a v a . awt . image . B u f f e r e d I m a g e ; import j a v a . i o . B u f f e r e d W r i t e r ; import j a v a . i o . F i l e ; import j a v a . i o . F i l e W r i t e r ; import j a v a . i o . IOException ; import j a v a . t e x t . DateFormat ; import j a v a . t e x t . DecimalFormat ; import j a v a . t e x t . SimpleDateFormat ; import j a v a . u t i l . A r r a y L i s t ; import j a v a . u t i l . Arrays ; import j a v a . u t i l . Comparator ; import j a v a . u t i l . Date ; import j a v a . u t i l . L i s t ; import j a v a x . i m a g e i o . ImageIO ; import j a v a x . swing .  ;

92

37 38 39

import o r g . apache . commons . c o l l e c t i o n s 1 5 . Transformer ;

public c l a s s createGUI extends JApplet implements A c t i o n L i s t e n e r , MouseWheelListener {

40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62

// c o n s t a n t s f o r a c t i o n commands protected f i n a l s t a t i c int GNP GRAPH = 1 ; protected f i n a l s t a t i c int GNR GRAPH = 2 ; protected f i n a l s t a t i c S t r i n g CREATE GRAPH = " new graph " ; protected f i n a l s t a t i c S t r i n g CREATE GRAPH2 = " new graph2 " ; protected f i n a l s t a t i c S t r i n g SAVE GRAPH IMAGE = " s a v e g r a p h i m g " ; protected f i n a l s t a t i c S t r i n g EXPORT GRAPH DATA = " e x p o r t g r a p h d a t a " ; protected f i n a l s t a t i c S t r i n g GRAPH DEGREE DIST = "DEGREE DIST" ; protected f i n a l s t a t i c S t r i n g GRAPH DIAMETER = "GRAPH DIAMETER" ; protected f i n a l s t a t i c S t r i n g GRAPH DSRAI PHASE1 = "GRAPH DSRAI1" ; protected f i n a l s t a t i c S t r i n g GRAPH DSRAI PHASE2 = "GRAPH DSRAI2" ; protected f i n a l s t a t i c S t r i n g GRAPH DSRAI PHASE3 = "GRAPH DSRAI3" ; protected f i n a l s t a t i c S t r i n g GRAPH DSDC = "GRAPH DSDC" ; protected f i n a l s t a t i c S t r i n g MGEOP GRAPH = "MGEOP GRAPH" ; protected f i n a l s t a t i c S t r i n g GRAPH 1CORE = "GRAPH 1CORE" ; protected f i n a l s t a t i c S t r i n g GRAPH 2CORE = "GRAPH 2CORE" ; protected f i n a l s t a t i c S t r i n g GRAPH 3CORE = "GRAPH 3CORE" ; protected f i n a l s t a t i c S t r i n g GRAPH KCORE = "GRAPH KCORE" ; // c o n t r o l l i n g c l a s s

private s t a t i c f i n a l JFrame frame = new JFrame ( " " ) ; private s t a t i c f i n a l JFrame graphFrame = new JFrame ( " " ) ; private s t a t i c JComponent panel1 , panel2 , panel3 , panel4 , panel5 , panel6 , panel7 ;

63 64 65

private s t a t i c f i n a l JTabbedPane tabbedPane = new JTabbedPane ( ) ; private s t a t i c f i n a l createGUI g u i = new createGUI ( ) ; private s t a t i c f i n a l J T e x t F i e l d txtNodes = new J T e x t F i e l d ( " 10 " , 3 ) ;

93

66 67 68 69 70 71 72

private s t a t i c f i n a l J T e x t F i e l d txtNodes2 = new J T e x t F i e l d ( " 10 " , 3 ) ; private s t a t i c f i n a l J T e x t F i e l d txtP = new J T e x t F i e l d ( " 0 . 5 " , 3 ) ; private s t a t i c f i n a l J T e x t F i e l d txtR = new J T e x t F i e l d ( " 0 . 1 " , 3 ) ; private s t a t i c f i n a l J T e x t F i e l d txtK = new J T e x t F i e l d ( " 5 " , 3 ) ; private s t a t i c f i n a l J T e x t F i e l d txtN = new J T e x t F i e l d ( " 769 " , 3 ) ; // mgeop private s t a t i c f i n a l J T e x t F i e l d txtM = new J T e x t F i e l d ( " 4 " , 3 ) ; // mgeop private s t a t i c f i n a l J T e x t F i e l d txtAlpha = new J T e x t F i e l d ( " 0 . 1 7 " , 3 ) ; // mgeop

73

private s t a t i c f i n a l J T e x t F i e l d t x t B e t a = new J T e x t F i e l d ( " 0 . 2 7 " , 3 ) ; // mgeop

74

private s t a t i c f i n a l J T e x t F i e l d txtP MGEOP = new J T e x t F i e l d ( " 1 " , 3 ) ; // mgeop

75

private s t a t i c f i n a l J T e x t F i e l d txtE MGEOP = new J T e x t F i e l d ( " 16656 " , 8 ) ; // mgeop

76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92

public s t a t i c int graphType = GNP GRAPH; private s t a t i c JComponent graph ; private s t a t i c B u f f e r e d I m a g e image ; private s t a t i c boolean b l n L a b e l = true ; private s t a t i c boolean blnShowVisual = true ; private s t a t i c boolean blnNewWindow = true ; private s t a t i c UndirectedSparseGraph <Node , S t r i n g > g = null ; private s t a t i c L i s t <Node> d o m i n a t i n g S e t = new A r r a y L i s t <>() ;

public createGUI ( ) { // c o n s t r u c t o r }

public void createGraphWithDS ( ) { g e n e r a t e V i s u a l G r a p h ( true ) ; graphFrame . pack ( ) ; }

94

93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123

public s t a t i c void c r e a te G r a p h ( ) { // i n t maxEdgeCount = ( n  ( n -1) ) >>1; int nodes = 1 0 ; double p = 0 . 5 ; try { i f ( graphType == GNR GRAPH) { nodes = I n t e g e r . p a r s e I n t ( txtNodes2 . getText ( ) ) ; p = Double . p a r s e D o u b l e ( txtR . getText ( ) ) ; } else { nodes = I n t e g e r . p a r s e I n t ( txtNodes . getText ( ) ) ; p = Double . p a r s e D o u b l e ( txtP . getText ( ) ) ; }

} catch ( NumberFormatException e ) { // do n o t h i n g }

RandomGraphGenerator r g g = new RandomGraphGenerator ( nodes , p ) ; g = null ; i f ( graphType == GNP GRAPH) { g = r g g . generateGNPRandomGraph ( ) ; } e l s e i f ( graphType == GNR GRAPH) { g = r g g . generateGNRRandomGraph ( ) ; } System . out . p r i n t l n ( " done " ) ;

}

public s t a t i c void createAndShowGUI ( ) { frame . s e t D e f a u l t C l o s e O p e r a t i o n ( JFrame . EXIT ON CLOSE) ;

95

124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149

createGUI maingui = new createGUI ( ) ; maingui . c r e a t e T a b s ( ) ;

// D i s p l a y t h e window . frame . pack ( ) ; frame . s e t L o c a t i o n R e l a t i v e T o ( null ) ; // c e n t e r i t frame . s e t V i s i b l e ( true ) ; }

public s t a t i c void g e n e r a t e V i s u a l G r a p h ( boolean showDS ) { C o n t a i n e r contentPane = graphFrame . getContentPane ( ) ; i f ( graph != null ) { contentPane . remove ( graph ) ; }

Layout <Node , S t r i n g > l a y o u t = null ; try { l a y o u t = new C i r c l e L a y o u t <>(g ) ; } catch ( E x c e p t i o n e ) { // do n o t h i n g return ; }

l a y o u t . s e t S i z e ( new Dimension ( 8 0 0 , 8 0 0 ) ) ;

B a s i c V i s u a l i z a t i o n S e r v e r <Node , S t r i n g > vv = new B a s i c V i s u a l i z a t i o n S e r v e r <>(l a y o u t ) ;

150 151 152 153

vv . s e t P r e f e r r e d S i z e ( new Dimension ( 8 0 0 , 8 0 0 ) ) ; S c a l i n g C o n t r o l s c a l e r = new C r o s s o v e r S c a l i n g C o n t r o l ( ) ; s c a l e r . s c a l e ( vv , 1 / 1 . 1 f , vv . g e t C e n t e r ( ) ) ;

96

154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172

// Transformer maps t h e v e r t e x number t o a v e r t e x p r o p e r t y Transformer <Node , Paint > v e r t e x C o l o r ; v e r t e x C o l o r = ( Node i ) -> { i f ( showDS ) { i f ( dominatingSet . contains ( i ) ) { return C o l o r .WHITE; } else { return C o l o r .GRAY; } } else { return C o l o r .RED; } }; vv . getRenderContext ( ) . s e t V e r t e x F i l l P a i n t T r a n s f o r m e r ( v e r t e x C o l o r ) ; vv . getRenderContext ( ) . s e t V e r t e x F i l l P a i n t T r a n s f o r m e r ( v e r t e x C o l o r ) ;

i f ( blnLabel ) { vv . getRenderContext ( ) . s e t V e r t e x L a b e l T r a n s f o r m e r ( new T o S t r i n g L a b e l l e r <>() ) ;

173 174 175 176 177 178

vv . g e t R e n d e r e r ( ) . g e t V e r t e x L a b e l R e n d e r e r ( ) . s e t P o s i t i o n ( P o s i t i o n .N) ; }

Box box = Box . c r e a t e V e r t i c a l B o x ( ) ; box . add ( vv ) ; box . s e t B o r d e r ( B o r d e r F a c t o r y . createEmptyBorder ( 1 0 , 1 0 , 1 0 , 1 0 ) ) ; //Add some b r e a t h i n g room .

179 180 181 182

// Cr e a t e t h e V i s u a l i z a t i o n I m a g e S e r v e r // vv i s t h e V i s u a l i z a t i o n V i e w e r c o n t a i n i n g my graph

97

183

V i s u a l i z a t i o n I m a g e S e r v e r <Node , S t r i n g > v i s = new V i s u a l i z a t i o n I m a g e S e r v e r <>(vv . getGraphLayout ( ) , vv . getGraphLayout ( ) . getSize () ) ;

184 185 186 187 188 189 190 191 192

v i s . s e t P r e f e r r e d S i z e ( new Dimension ( 8 0 0 , 8 0 0 ) ) ; S c a l i n g C o n t r o l s c a l e r 2 = new C r o s s o v e r S c a l i n g C o n t r o l ( ) ; s c a l e r 2 . s c a l e ( vis , 1 / 1.1 f , v i s . getCenter () ) ; v i s . setBackground ( new j a v a . awt . C o l o r ( 2 5 5 , 2 5 5 , 2 5 5 ) ) ; v i s . getRenderContext ( ) . s e t V e r t e x F i l l P a i n t T r a n s f o r m e r ( v e r t e x C o l o r ) ;

i f ( blnLabel ) { v i s . getRenderContext ( ) . s e t V e r t e x L a b e l T r a n s f o r m e r ( new T o S t r i n g L a b e l l e r <>() ) ;

193 194 195 196 197

v i s . g e t R e n d e r e r ( ) . g e t V e r t e x L a b e l R e n d e r e r ( ) . s e t P o s i t i o n ( P o s i t i o n .N) ; }

// Cr e a t e t h e b u f f e r e d image image = ( B u f f e r e d I m a g e ) v i s . getImage ( new Point2D . Double ( vv . getGraphLayout ( ) . g e t S i z e ( ) . getWidth ( ) / 2 ,

198 199 200 201 202 203 204 205 206 207 208 209

vv . getGraphLayout ( ) . g e t S i z e ( ) . g e t H e i g h t ( ) / 2 ) , new Dimension ( vv . getGraphLayout ( ) . g e t S i z e ( ) ) ) ;

graphFrame . s e t V i s i b l e ( true ) ; i f ( ( blnNewWindow ) & ( ! blnShowVisual ) ) { graph = null ; box = Box . c r e a t e V e r t i c a l B o x ( ) ; box . s e t B o r d e r ( B o r d e r F a c t o r y . createEmptyBorder ( 2 0 , 7 0 0 , 2 0 , 2 0 ) ) ; contentPane . add ( box , BorderLayout .CENTER) ; } e l s e i f ( ( ! blnNewWindow ) & ( ! blnShowVisual ) ) { // n o t h i n g graphFrame . s e t V i s i b l e ( f a l s e ) ;

98

210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232

} else { graph = box ; contentPane . add ( box , BorderLayout .CENTER) ; } }

// TABS private void c r e a t e T a b s ( ) { p a n e l 1 = makeGnpPanel ( ) ; p a n e l 1 . s e t P r e f e r r e d S i z e ( new Dimension ( 5 0 0 , 1 0 0 ) ) ; tabbedPane . addTab ( "G( n , p ) " , null , panel1 , " Generate G( n , p ) g r a p h s " ) ; tabbedPane . setMnemonicAt ( 0 , KeyEvent . VK 1 ) ;

p a n e l 2 = makeGnrPanel ( ) ; tabbedPane . addTab ( "G( n , r ) " , null , panel2 , " Generate G( n , r ) g r a p h s " ) ; tabbedPane . setMnemonicAt ( 1 , KeyEvent . VK 2 ) ;

p a n e l 3 = makeMGEOPPanel ( ) ; tabbedPane . addTab ( "MGEO -P" , null , panel3 , " Generate MGEO -P g r a p h s " ) ; tabbedPane . setMnemonicAt ( 2 , KeyEvent . VK 3 ) ;

p a n e l 4 = makeDominationPanel ( ) ; tabbedPane . addTab ( " Domination " , null , panel4 , "Run domination algorithms ") ;

233 234 235 236 237 238 239

tabbedPane . setMnemonicAt ( 3 , KeyEvent . VK 4 ) ;

p a n e l 5 = makeKCoresPanel ( ) ; tabbedPane . addTab ( "K -Cores " , null , panel5 , "Run k- c o r e a l g o r i t h m s " ) ; tabbedPane . setMnemonicAt ( 4 , KeyEvent . VK 5 ) ;

99

240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270

p a n e l 6 = makeExportPanel ( ) ; tabbedPane . addTab ( " Export " , null , panel6 , " Export graph data " ) ; tabbedPane . setMnemonicAt ( 5 , KeyEvent . VK 6 ) ;

p a n e l 7 = makeOptionsPanel ( ) ; tabbedPane . addTab ( " Options " , null , panel7 , " Options " ) ; tabbedPane . setMnemonicAt ( 6 , KeyEvent . VK 7 ) ;

frame . add ( tabbedPane ) ; }

// G( n , p ) Tab protected JComponent makeGnpPanel ( ) { JPanel p a n e l = new JPanel ( f a l s e ) ; p a n e l . s e t L a y o u t ( new BoxLayout ( panel , BoxLayout . Y AXIS ) ) ; JPanel l i n e 1 = new JPanel ( f a l s e ) ; JPanel l i n e 2 = new JPanel ( f a l s e ) ; JPanel l i n e 3 = new JPanel ( f a l s e ) ; JLabel l b l N o d e s = new JLabel ( "Number o f nodes ( n ) : " ) ; JLabel l b l P = new JLabel ( " P r o b a b i l i t y o f e d g e s ( p ) : " ) ; JButton btnGenerate = new JButton ( " Generate New G( n , p ) Graph" ) ; btnGenerate . setActionCommand (CREATE GRAPH) ; btnGenerate . a d d A c t i o n L i s t e n e r ( t h i s ) ; l i n e 1 . add ( l b l N o d e s ) ; l i n e 1 . add ( txtNodes ) ; l i n e 2 . add ( l b l P ) ; l i n e 2 . add ( txtP ) ; l i n e 3 . add ( btnGenerate ) ; p a n e l . add ( l i n e 1 ) ; p a n e l . add ( l i n e 2 ) ; p a n e l . add ( l i n e 3 ) ;

100

271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301

txtNodes . addMouseWheelListener ( t h i s ) ; txtP . addMouseWheelListener ( t h i s ) ; return p a n e l ; }

// G( n , r ) Tab protected JComponent makeGnrPanel ( ) { JPanel p a n e l = new JPanel ( f a l s e ) ; p a n e l . s e t L a y o u t ( new BoxLayout ( panel , BoxLayout . Y AXIS ) ) ; JPanel l i n e 1 = new JPanel ( f a l s e ) ; JPanel l i n e 2 = new JPanel ( f a l s e ) ; JPanel l i n e 3 = new JPanel ( f a l s e ) ; JLabel l b l N o d e s = new JLabel ( "Number o f nodes ( n ) : " ) ; JLabel l b l R = new JLabel ( " Radius o f i n f l u e n c e ( r ) : " ) ; JButton btnGenerate = new JButton ( " Generate New G( n , r ) Graph" ) ; btnGenerate . setActionCommand (CREATE GRAPH2) ; btnGenerate . a d d A c t i o n L i s t e n e r ( t h i s ) ; l i n e 1 . add ( l b l N o d e s ) ; l i n e 1 . add ( txtNodes2 ) ; l i n e 2 . add ( l b l R ) ; l i n e 2 . add ( txtR ) ; l i n e 3 . add ( btnGenerate ) ; p a n e l . add ( l i n e 1 ) ; p a n e l . add ( l i n e 2 ) ; p a n e l . add ( l i n e 3 ) ; txtNodes2 . addMouseWheelListener ( t h i s ) ; txtR . addMouseWheelListener ( t h i s ) ; return p a n e l ; }

// MGEO -P Tab

101

302 303 304 305 306 307 308 309 310 311 312 313 314 315

protected JComponent makeMGEOPPanel ( ) { JPanel p a n e l = new JPanel ( f a l s e ) ; p a n e l . s e t L a y o u t ( new BoxLayout ( panel , BoxLayout . Y AXIS ) ) ; JPanel l i n e 1 = new JPanel ( f a l s e ) ; JPanel l i n e 2 = new JPanel ( f a l s e ) ; JPanel l i n e 3 = new JPanel ( f a l s e ) ; JPanel l i n e 4 = new JPanel ( f a l s e ) ; JPanel l i n e 5 = new JPanel ( f a l s e ) ; JPanel l i n e 6 = new JPanel ( f a l s e ) ; JPanel l i n e 7 = new JPanel ( f a l s e ) ; JPanel l i n e 8 = new JPanel ( f a l s e ) ; JLabel l b l N = new JLabel ( "Number o f v e r t i c e s ( n ) : " ) ; JLabel lblM = new JLabel ( " Dimension o f m e t r i c s p a c e (m) : " ) ; JLabel l b l A l p h a = new JLabel ( " Attachment s t r e n g t h parameter ( a l p h a ) : ") ;

316 317 318 319

JLabel l b l B e t a = new JLabel ( " D e n s i t y parameter ( b e t a ) : " ) ; JLabel l b l P = new JLabel ( " Connection p r o b a b i l i t y ( p ) : " ) ; JLabel l b l E = new JLabel ( " S e t Edges ( e ) : " ) ; JButton btnMGEOP = new JButton ( " Generate New MGEO -P( n , m, alpha , beta , p ) Graph" ) ;

320 321 322 323 324 325 326 327 328 329 330

JButton btnMGEOPINV = new JButton ( "INV- MGEO -P" ) ;

btnMGEOP . setActionCommand (MGEOP GRAPH) ; btnMGEOP . a d d A c t i o n L i s t e n e r ( t h i s ) ; btnMGEOPINV . setActionCommand ( "INV- MGEO -P" ) ; btnMGEOPINV . a d d A c t i o n L i s t e n e r ( t h i s ) ;

l i n e 1 . add ( l b l N ) ; l i n e 1 . add ( txtN ) ; l i n e 2 . add ( lblM ) ; l i n e 2 . add ( txtM ) ;

102

331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360

l i n e 3 . add ( l b l A l p h a ) ; l i n e 3 . add ( txtAlpha ) ; l i n e 4 . add ( l b l B e t a ) ; l i n e 4 . add ( t x t B e t a ) ; l i n e 5 . add ( l b l P ) ; l i n e 5 . add (txtP MGEOP) ; l i n e 6 . add ( l b l E ) ; l i n e 6 . add (txtE MGEOP) ; l i n e 7 . add (btnMGEOP) ; l i n e 8 . add (btnMGEOPINV) ; p a n e l . add ( l i n e 1 ) ; p a n e l . add ( l i n e 2 ) ; p a n e l . add ( l i n e 3 ) ; p a n e l . add ( l i n e 4 ) ; p a n e l . add ( l i n e 5 ) ; p a n e l . add ( l i n e 6 ) ; p a n e l . add ( l i n e 7 ) ; p a n e l . add ( l i n e 8 ) ; txtN . addMouseWheelListener ( t h i s ) ; txtM . addMouseWheelListener ( t h i s ) ; txtAlpha . addMouseWheelListener ( t h i s ) ; t x t B e t a . addMouseWheelListener ( t h i s ) ; txtP MGEOP . addMouseWheelListener ( t h i s ) ; return p a n e l ; }

// Domination Tab protected JComponent makeDominationPanel ( ) { JPanel p a n e l = new JPanel ( f a l s e ) ; p a n e l . s e t L a y o u t ( new BoxLayout ( panel , BoxLayout . Y AXIS ) ) ;

103

361

f i n a l JButton b t n D e g r e e D i s t r i b u t i o n = new JButton ( " Degree D i s t r i b u t i o n ( Histogram ) " ) ;

362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390

b t n D e g r e e D i s t r i b u t i o n . setActionCommand (GRAPH DEGREE DIST) ; btnDegreeDistribution . addActionListener ( this ) ;

f i n a l JButton btnDiameter = new JButton ( " Diameter " ) ; btnDiameter . setActionCommand (GRAPH DIAMETER) ; btnDiameter . a d d A c t i o n L i s t e n e r ( t h i s ) ;

f i n a l JButton btnDSRAI1 = new JButton ( "DS-RAI (PHASE 1 ) " ) ; btnDSRAI1 . setActionCommand (GRAPH DSRAI PHASE1) ; btnDSRAI1 . a d d A c t i o n L i s t e n e r ( t h i s ) ;

f i n a l JButton btnDSRAI2 = new JButton ( "DS-RAI (PHASE 2 ) " ) ; btnDSRAI2 . setActionCommand (GRAPH DSRAI PHASE1) ; btnDSRAI2 . a d d A c t i o n L i s t e n e r ( t h i s ) ;

f i n a l JButton btnDSRAI3 = new JButton ( "DS-RAI (PHASE 3 ) " ) ; btnDSRAI3 . setActionCommand (GRAPH DSRAI PHASE3) ; btnDSRAI3 . a d d A c t i o n L i s t e n e r ( t h i s ) ;

f i n a l JButton btnDSDC = new JButton ( "DS-DC" ) ; btnDSDC . setActionCommand (GRAPH DSDC) ; btnDSDC . a d d A c t i o n L i s t e n e r ( t h i s ) ;

f i n a l JButton btnBurning = new JButton ( " Burning " ) ; btnBurning . setActionCommand ( "BURNING" ) ; btnBurning . a d d A c t i o n L i s t e n e r ( t h i s ) ;

p a n e l . add ( b t n D e g r e e D i s t r i b u t i o n ) ; p a n e l . add ( btnDiameter ) ;

104

391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421

p a n e l . add ( btnDSRAI1 ) ; p a n e l . add ( btnDSRAI2 ) ; p a n e l . add ( btnDSRAI3 ) ; p a n e l . add (btnDSDC) ; p a n e l . add ( btnBurning ) ;

return p a n e l ; }

// KCores Tab protected JComponent makeKCoresPanel ( ) { JPanel p a n e l = new JPanel ( f a l s e ) ; p a n e l . s e t L a y o u t ( new BoxLayout ( panel , BoxLayout . Y AXIS ) ) ;

f i n a l JButton btnOneCore = new JButton ( "1- Core " ) ; btnOneCore . setActionCommand (GRAPH 1CORE) ; btnOneCore . a d d A c t i o n L i s t e n e r ( t h i s ) ;

f i n a l JButton btnTwoCore = new JButton ( "2- Core " ) ; btnTwoCore . setActionCommand (GRAPH 2CORE) ; btnTwoCore . a d d A c t i o n L i s t e n e r ( t h i s ) ;

f i n a l JButton btnThreeCore = new JButton ( "3- Core " ) ; btnThreeCore . setActionCommand (GRAPH 3CORE) ; btnThreeCore . a d d A c t i o n L i s t e n e r ( t h i s ) ;

f i n a l JButton btnKCore = new JButton ( "k-Core " ) ; btnKCore . setActionCommand (GRAPH KCORE) ; btnKCore . a d d A c t i o n L i s t e n e r ( t h i s ) ;

JLabel l b l K = new JLabel ( "K: " ) ;

105

422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452

p a n e l . add ( btnOneCore ) ; p a n e l . add ( btnTwoCore ) ; p a n e l . add ( btnThreeCore ) ; p a n e l . add ( l b l K ) ; p a n e l . add ( txtK ) ; p a n e l . add ( btnKCore ) ;

return p a n e l ; }

// Export Tab protected JComponent makeExportPanel ( ) { JPanel p a n e l = new JPanel ( f a l s e ) ; p a n e l . s e t L a y o u t ( new BoxLayout ( panel , BoxLayout . Y AXIS ) ) ; JButton btnSaveImage = new JButton ( " Save Image " ) ; JButton btnExport = new JButton ( " Export Graph Data" ) ;

btnSaveImage . setActionCommand (SAVE GRAPH IMAGE) ; btnSaveImage . a d d A c t i o n L i s t e n e r ( t h i s ) ;

btnExport . setActionCommand (EXPORT GRAPH DATA) ; btnExport . a d d A c t i o n L i s t e n e r ( t h i s ) ; p a n e l . add ( btnSaveImage ) ; p a n e l . add ( btnExport ) ;

return p a n e l ; }

// O p t i o n s Tab protected JComponent makeOptionsPanel ( ) {

106

453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479

JPanel p a n e l = new JPanel ( f a l s e ) ; p a n e l . s e t L a y o u t ( new BoxLayout ( panel , BoxLayout . Y AXIS ) ) ; f i n a l JCheckBox c h k L a b e l s = new JCheckBox ( " L a b e l s " , true ) ; c h k L a b e l s . a d d I t e m L i s t e n e r ( ( ItemEvent e ) -> { b l n L a b e l = ( e . g e t S t a t e C h a n g e ( ) == 1 ) ; }) ;

f i n a l JCheckBox chkShowVisual = new JCheckBox ( " V i s u a l " , true ) ; chkShowVisual . a d d I t e m L i s t e n e r ( ( ItemEvent e ) -> { blnShowVisual = ( e . g e t S t a t e C h a n g e ( ) == 1 ) ; i f ( blnShowVisual == f a l s e ) { C o n t a i n e r contentPane = graphFrame . getContentPane ( ) ; i f ( graph != null ) { contentPane . remove ( graph ) ; } i f ( ( blnNewWindow ) | | ( blnShowVisual ) ) { generateVisualGraph ( false ) ; graphFrame . pack ( ) ; graphFrame . s e t V i s i b l e ( true ) ; } else { graphFrame . s e t V i s i b l e ( f a l s e ) ; } } else { i f ( g . getVertexCount ( ) >= 5 0 0 ) { Object [ ] o p t i o n s = { "Yes , p l e a s e " , "No , thanks " } ; int v a l u e = JOptionPane . showOptionDialog ( frame , " There i s o v e r 500 nodes i n your c u r r e n t graph . \ n"

480 481 482

+ " Nodes : " + g . getVertexCount ( ) , " V i s u a l Graph" , JOptionPane . YES NO OPTION, JOptionPane . QUESTION MESSAGE,

107

483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513

null , options , options [ 1 ] ) ; System . out . p r i n t l n ( v a l u e ) ; i f ( v a l u e == 0 ) { i f ( ( blnNewWindow ) | | ( blnShowVisual ) ) { generateVisualGraph ( false ) ; graphFrame . pack ( ) ; graphFrame . s e t V i s i b l e ( true ) ; } else { graphFrame . s e t V i s i b l e ( f a l s e ) ; } } e l s e i f ( v a l u e == 1 ) { // do n o t h i n g } } else { i f ( ( blnNewWindow ) | | ( blnShowVisual ) ) { generateVisualGraph ( false ) ; graphFrame . pack ( ) ; graphFrame . s e t V i s i b l e ( true ) ; } else { graphFrame . s e t V i s i b l e ( f a l s e ) ; } } } }) ;

f i n a l JCheckBox chkNewWindow = new JCheckBox ( "New Window" , true ) ; chkNewWindow . a d d I t e m L i s t e n e r ( ( ItemEvent e ) -> { blnNewWindow = ( e . g e t S t a t e C h a n g e ( ) == 1 ) ; }) ;

108

514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544

p a n e l . add ( c h k L a b e l s ) ; p a n e l . add ( chkShowVisual ) ; p a n e l . add ( chkNewWindow ) ; return p a n e l ; }

protected s t a t i c JComponent makeTextPanel ( S t r i n g t e x t ) { JPanel p a n e l = new JPanel ( f a l s e ) ; JLabel f i l l e r = new JLabel ( t e x t ) ; f i l l e r . s e t H o r i z o n t a l A l i g n m e n t ( JLabel .CENTER) ; p a n e l . s e t L a y o u t ( new GridLayout ( 1 , 1 ) ) ; p a n e l . add ( f i l l e r ) ; return p a n e l ; }

protected JComponent c r e a t e B u t t o n P a n e ( ) { JPanel btmPanel = new JPanel ( ) ;

JButton button = new JButton ( " Generate New G( n , p ) Graph" ) ; JButton button2 = new JButton ( " Generate New G( n , r ) Graph" ) ; JButton btnMGEOP = new JButton ( "MGEO -P" ) ; JButton btnSaveImage = new JButton ( " Save Image " ) ; JButton btnExport = new JButton ( " Export Graph Data" ) ;

JLabel l b l N o d e s = new JLabel ( "n : " ) ; JLabel l b l P = new JLabel ( "P/R: " ) ;

button . setActionCommand (CREATE GRAPH) ; button . a d d A c t i o n L i s t e n e r ( t h i s ) ;

109

545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575

button2 . setActionCommand (CREATE GRAPH2) ; button2 . a d d A c t i o n L i s t e n e r ( t h i s ) ;

btnMGEOP . setActionCommand (MGEOP GRAPH) ; btnMGEOP . a d d A c t i o n L i s t e n e r ( t h i s ) ;

btnSaveImage . setActionCommand (SAVE GRAPH IMAGE) ; btnSaveImage . a d d A c t i o n L i s t e n e r ( t h i s ) ;

btnExport . setActionCommand (EXPORT GRAPH DATA) ; btnExport . a d d A c t i o n L i s t e n e r ( t h i s ) ;

txtNodes . addMouseWheelListener ( t h i s ) ; txtP . addMouseWheelListener ( t h i s ) ;

JPanel pane = new JPanel ( ) ; JPanel pane2 = new JPanel ( ) ; JPanel pane3 = new JPanel ( ) ; JPanel pane4 = new JPanel ( ) ; JPanel pane5 = new JPanel ( ) ;

pane . s e t B o r d e r ( B o r d e r F a c t o r y . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; pane . add ( button ) ; pane . add ( button2 ) ; pane . add (btnMGEOP) ;

pane2 . add ( l b l N o d e s ) ; pane2 . add ( txtNodes ) ; pane2 . add ( l b l P ) ; pane2 . add ( txtP ) ;

110

576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602

btmPanel . s e t L a y o u t ( new BoxLayout ( btmPanel , BoxLayout . Y AXIS ) ) ; btmPanel . add ( pane ) ; btmPanel . add ( pane2 ) ; btmPanel . add ( pane3 ) ; btmPanel . add ( pane4 ) ; btmPanel . add ( pane5 ) ;

return btmPanel ; }

@Override public void a c t i o n P e r f o r m e d ( ActionEvent e ) { S t r i n g command = e . getActionCommand ( ) ; int nodes , m; double p , alpha , b e t a ; i f ( null != command ) // Handle t h e New window b u t t o n . // Handle t h e New window b u t t o n . switch ( command ) { case CREATE GRAPH: graphType = GNP GRAPH; c r e a t eG r a p h ( ) ; i f ( blnShowVisual ) { generateVisualGraph ( false ) ; graphFrame . pack ( ) ; graphFrame . s e t V i s i b l e ( true ) ; } graphFrame . s e t T i t l e ( "G( n="+txtNodes . getText ( )+" , p="+txtP . getText ( )+" ) - " + g . getVertexCount ( ) + " nodes - " + g . getEdgeCount ( ) + " edges " ) ;

603 604

break ;

111

605 606 607 608 609 610 611

case SAVE GRAPH IMAGE: saveGraphImage ( ) ; break ; case CREATE GRAPH2: graphType = GNR GRAPH; c r e a t eG r a p h ( ) ; graphFrame . s e t T i t l e ( "G( n="+txtNodes . getText ( )+" , r="+txtR . getText ( )+" ) - " + g . getVertexCount ( ) + " nodes - " + g . getEdgeCount ( ) + " edges " ) ;

612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633

break ; case EXPORT GRAPH DATA: // exportGraphData ( ) ; exportSMATData ( ) ; break ; case GRAPH DEGREE DIST : GraphProperties . d e g r e e D i s t r i b u t i o n ( g ) ; break ; case GRAPH DIAMETER: System . out . p r i n t l n ( G r a p h P r o p e r t i e s . d i a m e t e r ( g ) ) ; break ; case GRAPH DSRAI PHASE1 : d o m i n a t i n g S e t = DominatingSet . d s r a i ( g , 1 ) ; System . out . p r i n t l n ( d o m i n a t i n g S e t . s i z e ( ) ) ; i f ( blnShowVisual ) { createGraphWithDS ( ) ; } break ; case GRAPH DSRAI PHASE2 : // d o m i n a t i n g S e t = DominatingSet . d s r a i ( g , 2 ) ; break ; case GRAPH DSRAI PHASE3 :

112

634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655

// d o m i n a t i n g S e t = DominatingSet . d s r a i ( g , 3 ) ; break ; case GRAPH DSDC: d o m i n a t i n g S e t = DominatingSet . dsdc ( g ) ; System . out . p r i n t l n ( d o m i n a t i n g S e t . s i z e ( ) ) ; i f ( blnShowVisual ) { createGraphWithDS ( ) ; } break ; case "INV- MGEO -P" : nodes = I n t e g e r . p a r s e I n t ( txtN . getText ( ) ) ; p = Double . p a r s e D o u b l e (txtP MGEOP . getText ( ) ) ; a l p h a = Double . p a r s e D o u b l e ( txtAlpha . getText ( ) ) ; b e t a = Double . p a r s e D o u b l e ( t x t B e t a . getText ( ) ) ; m = I n t e g e r . p a r s e I n t ( txtM . getText ( ) ) ; g = new MGEOP( nodes ,m, alpha , beta , p ) . g e n e r a t e I nv G r a p h ( ) ; i f ( blnShowVisual ) { generateVisualGraph ( false ) ; graphFrame . pack ( ) ; graphFrame . s e t V i s i b l e ( true ) ; } graphFrame . s e t T i t l e ( "DMGEO -P( n="+nodes+" , a l p h a="+a l p h a+" , b e t a= "+b e t a+" ,m ="+ m +" ) - " + g . getVertexCount ( ) + " nodes - " + g . getEdgeCount () + " edges " ) ;

656 657 658 659 660 661 662

break ; case MGEOP GRAPH: nodes = I n t e g e r . p a r s e I n t ( txtN . getText ( ) ) ; p = Double . p a r s e D o u b l e (txtP MGEOP . getText ( ) ) ; a l p h a = Double . p a r s e D o u b l e ( txtAlpha . getText ( ) ) ; b e t a = Double . p a r s e D o u b l e ( t x t B e t a . getText ( ) ) ; m = I n t e g e r . p a r s e I n t ( txtM . getText ( ) ) ;

113

663 664 665 666 667 668 669

g = new MGEOP( nodes ,m, alpha , beta , p ) . generateGraph ( ) ; i f ( blnShowVisual ) { generateVisualGraph ( false ) ; graphFrame . pack ( ) ; graphFrame . s e t V i s i b l e ( true ) ; } graphFrame . s e t T i t l e ( "MGEO -P( n="+nodes+" , a l p h a="+a l p h a+" , b e t a=" +b e t a+" ,m ="+ m +" , p="+p+" ) - " + g . getVertexCount ( ) + " nodes - " + g . getEdgeCount ( ) + " e d g e s " ) ;

670 671 672 673

break ; case GRAPH 1CORE: g = GraphManipulation . oneCore ( g ) ; graphFrame . s e t T i t l e ( graphFrame . g e t T i t l e ( )+" ( changed : "+ g . getEdgeCount ( ) +" ) " ) ;

674 675 676 677 678 679 680 681

i f ( blnShowVisual ) { generateVisualGraph ( false ) ; } graphFrame . pack ( ) ; break ; case GRAPH 2CORE: g = GraphManipulation . twoCore ( g ) ; graphFrame . s e t T i t l e ( graphFrame . g e t T i t l e ( )+" ( changed : "+ g . getEdgeCount ( ) +" ) " ) ;

682 683 684 685 686 687 688

i f ( blnShowVisual ) { generateVisualGraph ( false ) ; } graphFrame . pack ( ) ; break ; case GRAPH 3CORE: g = GraphManipulation . t h r e e C o r e ( g ) ;

114

689

graphFrame . s e t T i t l e ( graphFrame . g e t T i t l e ( )+" ( changed : "+ g . getEdgeCount ( ) +" ) " ) ;

690 691 692 693 694 695 696

i f ( blnShowVisual ) { generateVisualGraph ( false ) ; } graphFrame . pack ( ) ; break ; case GRAPH KCORE: g = GraphManipulation . kCore ( g , I n t e g e r . p a r s e I n t ( txtK . getText ( ) ));

697

graphFrame . s e t T i t l e ( graphFrame . g e t T i t l e ( )+" ( changed : "+ g . getEdgeCount ( ) +" ) " ) ;

698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716

i f ( blnShowVisual ) { generateVisualGraph ( false ) ; } graphFrame . pack ( ) ; break ; case "BURNING" : d o m i n a t i n g S e t = DominatingSet . b u r n i n g ( g ) ; System . out . p r i n t l n ( ( d o m i n a t i n g S e t . s i z e ( ) +1)+" rounds " ) ; System . out . p r i n t l n ( d o m i n a t i n g S e t . t o S t r i n g ( ) ) ; i f ( blnShowVisual ) { createGraphWithDS ( ) ; } break ; } }

public void saveGraphImage ( ) { DateFormat dateFormat = new SimpleDateFormat ( "yyyy- MM -dd-HHmmss" ) ; Date d a t e = new Date ( ) ;

115

717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746

S t r i n g imageDate = dateFormat . format ( d a t e ) ; i f ( graphType == GNR GRAPH) { imageDate += "-gnr " ; } e l s e i f ( graphType == GNP GRAPH) { imageDate += "-gnp" ; } F i l e o u t p u t f i l e = new F i l e ( imageDate+"-graph . png" ) ;

try { ImageIO . w r i t e ( image , "png" , o u t p u t f i l e ) ; } catch ( IOException e ) { // E x c e p t i o n h a n d l i n g } }

public s t a t i c void exportSMATData ( ) { B u f f e r e d W r i t e r w r i t e r = null ; try { // c r e a t e a temporary f i l e DateFormat dateFormat = new SimpleDateFormat ( "yyyy- MM -dd-HHmmss" ) ; Date d a t e = new Date ( ) ; S t r i n g f i l e D a t e = dateFormat . format ( d a t e ) ; i f ( graphType == GNR GRAPH) { f i l e D a t e += "-gnr " ; } e l s e i f ( graphType == GNP GRAPH) { f i l e D a t e += "-gnp" ; } F i l e f i l e = new F i l e ( f i l e D a t e+"- data . t x t " ) ; w r i t e r = new B u f f e r e d W r i t e r ( new F i l e W r i t e r ( f i l e ) ) ;

116

747

Comparator <Node> comp = ( Node arg0 , Node a r g 1 ) -> a r g 0 . compareTo ( arg1 ) ;

748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776

Node [ ] v t x s = new Node [ g . getVertexCount ( ) ] ; g . g e t V e r t i c e s ( ) . toArray ( v t x s ) ; Arrays . s o r t ( vtxs , comp ) ; f o r ( Node vtx : v t x s ) { f o r ( Node a d j : vtx . g e t A d j a c e n t ( ) ) { w r i t e r . w r i t e ( a d j . getID ( ) + " " + vtx . getID ( ) ) ; w r i t e r . newLine ( ) ; a d j . d e l e t e E d g e ( vtx ) ; } } } catch ( IOException e ) { // e . p r i n t S t a c k T r a c e ( ) ; } finally { try { writer . close () ; } catch ( IOException e ) { // e . p r i n t S t a c k T r a c e ( ) ; } }

}

public s t a t i c void exportGraphData ( ) { B u f f e r e d W r i t e r w r i t e r = null ; try { // c r e a t e a temporary f i l e DateFormat dateFormat = new SimpleDateFormat ( "yyyy- MM -dd-HHmmss" ) ; Date d a t e = new Date ( ) ; S t r i n g f i l e D a t e = dateFormat . format ( d a t e ) ;

117

777 778 779 780 781 782 783 784

i f ( graphType == GNR GRAPH) { f i l e D a t e += "-gnr " ; } e l s e i f ( graphType == GNP GRAPH) { f i l e D a t e += "-gnp" ; } F i l e f i l e = new F i l e ( f i l e D a t e+"- data . t x t " ) ; w r i t e r = new B u f f e r e d W r i t e r ( new F i l e W r i t e r ( f i l e ) ) ; Comparator <Node> comp = ( Node arg0 , Node a r g 1 ) -> a r g 0 . compareTo ( arg1 ) ;

785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806

Node [ ] v t x s = new Node [ g . getVertexCount ( ) ] ; g . g e t V e r t i c e s ( ) . toArray ( v t x s ) ; Arrays . s o r t ( vtxs , comp ) ; f o r ( Node vtx : v t x s ) { w r i t e r . w r i t e ( vtx . a d j a c e n t S t r i n g ( ) ) ; w r i t e r . newLine ( ) ; } } catch ( IOException e ) { // e . p r i n t S t a c k T r a c e ( ) ; } finally { try { writer . close () ; } catch ( IOException e ) { // e . p r i n t S t a c k T r a c e ( ) ; } } }

@Override public void mouseWheelMoved ( MouseWheelEvent e ) { JTextField source = ( JTextField ) e . getSource ( ) ; int n o t c h e s = e . getWheelRotation ( ) ;

118

807 808 809 810

DecimalFormat d f = new DecimalFormat ( "#.###" ) ; i f ( s o u r c e . e q u a l s ( txtNodes ) ) { i f ( notches < 0) { txtNodes . s e t T e x t ( I n t e g e r . p a r s e I n t ( txtNodes . getText ( ) ) + 1 + " " );

811 812

} else { txtNodes . s e t T e x t ( I n t e g e r . p a r s e I n t ( txtNodes . getText ( ) ) - 1 + " " );

813 814 815 816

} } e l s e i f ( s o u r c e . e q u a l s ( txtP ) ) { i f ( notches < 0) { txtP . s e t T e x t ( d f . format ( Double . p a r s e D o u b l e ( txtP . getText ( ) ) + 0.05) ) ;

817 818

} else { txtP . s e t T e x t ( d f . format ( Double . p a r s e D o u b l e ( txtP . getText ( ) ) - 0.05) ) ;

819 820 821 822

} } e l s e i f ( s o u r c e . e q u a l s ( txtR ) ) { i f ( notches < 0) { txtR . s e t T e x t ( d f . format ( Double . p a r s e D o u b l e ( txtR . getText ( ) ) + 0.05) ) ;

823 824

} else { txtR . s e t T e x t ( d f . format ( Double . p a r s e D o u b l e ( txtR . getText ( ) ) - 0.05) ) ;

825 826 827 828

} } e l s e i f ( s o u r c e . e q u a l s ( txtNodes2 ) ) { i f ( notches < 0) { txtNodes2 . s e t T e x t ( I n t e g e r . p a r s e I n t ( txtNodes2 . getText ( ) ) + 1 + "" ) ;

829

} else {

119

830

txtNodes2 . s e t T e x t ( I n t e g e r . p a r s e I n t ( txtNodes2 . getText ( ) ) - 1 + "" ) ;

831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846

} } e l s e i f ( s o u r c e . e q u a l s ( txtN ) ) { i f ( notches < 0) { txtN . s e t T e x t ( I n t e g e r . p a r s e I n t ( txtN . getText ( ) ) + 1 + " " ) ; } else { txtN . s e t T e x t ( I n t e g e r . p a r s e I n t ( txtN . getText ( ) ) - 1 + " " ) ; } } e l s e i f ( s o u r c e . e q u a l s ( txtM ) ) { i f ( notches < 0) { txtM . s e t T e x t ( I n t e g e r . p a r s e I n t ( txtM . getText ( ) ) + 1 + " " ) ; } else { txtM . s e t T e x t ( I n t e g e r . p a r s e I n t ( txtM . getText ( ) ) - 1 + " " ) ; } } e l s e i f ( s o u r c e . e q u a l s ( txtAlpha ) ) { i f ( notches < 0) { txtAlpha . s e t T e x t ( d f . format ( Double . p a r s e D o u b l e ( txtAlpha . getText () ) + 0.05) ) ;

847 848

} else { txtAlpha . s e t T e x t ( d f . format ( Double . p a r s e D o u b l e ( txtAlpha . getText () ) - 0.05) ) ;

849 850 851 852

} } else i f ( source . equals ( txtBeta ) ) { i f ( notches < 0) { t x t B e t a . s e t T e x t ( d f . format ( Double . p a r s e D o u b l e ( t x t B e t a . getText ( ) ) + 0.05) ) ;

853 854

} else { t x t B e t a . s e t T e x t ( d f . format ( Double . p a r s e D o u b l e ( t x t B e t a . getText ( ) ) - 0.05) ) ;

855

}

120

856 857 858

} e l s e i f ( s o u r c e . e q u a l s (txtP MGEOP) ) { i f ( notches < 0) { txtP MGEOP . s e t T e x t ( d f . format ( Double . p a r s e D o u b l e (txtP MGEOP . getText ( ) ) + 0 . 0 5 ) ) ;

859 860

} else { txtP MGEOP . s e t T e x t ( d f . format ( Double . p a r s e D o u b l e (txtP MGEOP . getText ( ) ) - 0 . 0 5 ) ) ;

861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878

} } }

public s t a t i c void main ( S t r i n g [ ] a r g s ) { JApplet a p p l e t = new createGUI ( ) ; frame . add ( a p p l e t ) ; applet . i n i t () ; applet . start () ; }

public void i n i t ( ) { j a v a x . swing . S w i n g U t i l i t i e s . i n v o k e L a t e r ( ( ) -> { createAndShowGUI ( ) ; }) ; }

}

GraphProperties.java
1 2 3 4

/  / @author Marc L o z i e r

121

5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35

package graphpackage ;

import edu . u c i . i c s . jung . graph . Graph ; import j a v a . u t i l . Arrays ; import j a v a . u t i l . Comparator ; import m a t l a b c o n t r o l . MatlabConnectionException ; import m a t l a b c o n t r o l . M a t l a b I n v o c a t i o n E x c e p t i o n ; import m a t l a b c o n t r o l . MatlabProxy ; import m a t l a b c o n t r o l . MatlabProxyFactory ; import m a t l a b c o n t r o l . MatlabProxyFactoryOptions ;

/    @author Marc / public c l a s s G r a p h P r o p e r t i e s {

public s t a t i c double d i a m e t e r ( Graph g ) { double b e s t = - 1; Node arg0 , a r g 1 ; Comparator <Node> comp = new Comparator <Node > () { @Override public int compare ( f i n a l Node arg0 , f i n a l Node a r g 1 ) { return a r g 0 . compareTo ( a r g 1 ) ; } }; Node [ ] v t x s = new Node [ g . getVertexCount ( ) ] ; g . g e t V e r t i c e s ( ) . toArray ( v t x s ) ; Arrays . s o r t ( vtxs , comp ) ; f o r ( Node s : v t x s ) { PathFinder f i n d e r = new PathFinder ( g , s ) ;

122

36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66

f o r ( Node v : v t x s ) { i f ( f i n d e r . i s R e a c h a b l e ( v ) && f i n d e r . d i s t a n c e T o ( v ) > b e s t ) { best = f i n d e r . distanceTo (v) ; } i f ( v . g e t A d j a c e n t ( ) . isEmpty ( ) ) { b e s t = Double . POSITIVE INFINITY ; } } } return b e s t ; }

public s t a t i c void d e g r e e D i s t r i b u t i o n ( Graph g ) { int s i z e = g . getVertexCount ( ) ; Node arg0 , a r g 1 ; Comparator <Node> comp = new Comparator <Node > () { @Override public int compare ( f i n a l Node arg0 , f i n a l Node a r g 1 ) { return a r g 0 . compareTo ( a r g 1 ) ; } };

Node [ ] v t x s = new Node [ s i z e ] ; g . g e t V e r t i c e s ( ) . toArray ( v t x s ) ; Arrays . s o r t ( vtxs , comp ) ; S t r i n g command = " h i s t ( [ " ; f o r ( Node vtx : v t x s ) { command += vtx . g e t D e g r e e ( )+" , " ; } command = command . s u b s t r i n g ( 0 , command . l e n g t h ( ) -1) ; command += " ] , " + s i z e+" ) " ;

123

67 68 69 70

// Cr e a t e a proxy , which we w i l l use t o c o n t r o l MATLAB try { MatlabProxyFactoryOptions o p t i o n s = new MatlabProxyFactoryOptions . B u i l d e r ( ) . s e t U s e P r e v i o u s l y C o n t r o l l e d S e s s i o n ( true ) . b u i l d ( ) ;

71 72 73 74 75 76 77 78 79 80 81 82 83 84

MatlabProxyFactory f a c t o r y = new MatlabProxyFactory ( o p t i o n s ) ; MatlabProxy proxy = f a c t o r y . getProxy ( ) ; proxy . e v a l ( command ) ; proxy . d i s c o n n e c t ( ) ; } catch ( M a t l a b I n v o c a t i o n E x c e p t i o n e ) { } catch ( MatlabConnectionException e ) {

} finally {

} }

}

GraphManipulation.java
1 2 3 4 5 6 7 8 9 10

/  / @author Marc L o z i e r

package graphpackage ;

import c e r n . c o l t . Arrays ; import edu . u c i . i c s . jung . graph . Graph ; import edu . u c i . i c s . jung . graph . UndirectedSparseGraph ; import j a v a . u t i l . A r r a y L i s t ;

124

11 12 13 14 15 16 17 18 19

import j a v a . u t i l . L i s t ; import j a v a . u t i l . Random ;

/    @author Marc / public c l a s s GraphManipulation { public s t a t i c UndirectedSparseGraph <Node , S t r i n g > oneCore ( UndirectedSparseGraph <Node , S t r i n g > oldGraph ) {

20 21 22 23 24 25 26 27 28 29 30

UndirectedSparseGraph <Node , S t r i n g > newGraph = oldGraph ; Node [ ] nodes = DominatingSet . graphToArray ( newGraph ) ; f o r ( Node v : nodes ) { i f ( newGraph . d e g r e e ( v ) == 0 ) { newGraph . removeVertex ( v ) ; } } return newGraph ; }

public s t a t i c UndirectedSparseGraph <Node , S t r i n g > twoCore ( UndirectedSparseGraph oldGraph ) {

31 32 33 34 35 36 37 38 39

UndirectedSparseGraph <Node , S t r i n g > newGraph = oldGraph ; Node [ ] nodes ; L i s t <Node> toRemove = new A r r a y L i s t <Node > () ; boolean r e p e a t = true ; while ( r e p e a t ) { toRemove . c l e a r ( ) ; repeat = false ; nodes = DominatingSet . graphToArray ( newGraph ) ; f o r ( Node v : nodes ) {

125

40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57

i f ( I n t e g e r . parseInt ( v . getDegree ( ) ) < 2) { f o r ( Node x : v . g e t A d j a c e n t ( ) ) { x . deleteEdge (v) ; toRemove . add ( x ) ; newGraph . removeEdge ( newGraph . f i n d E d g e ( x , v ) ) ; r e p e a t = true ; } f o r ( Node w : toRemove ) { v . d e l e t e E d g e (w) ; } newGraph . removeVertex ( v ) ; } } } return newGraph ; }

public s t a t i c UndirectedSparseGraph <Node , S t r i n g > t h r e e C o r e ( UndirectedSparseGraph oldGraph ) {

58 59 60 61 62 63 64 65 66 67 68 69

UndirectedSparseGraph <Node , S t r i n g > newGraph = oldGraph ; Node [ ] nodes ; L i s t <Node> toRemove = new A r r a y L i s t <Node > () ; boolean r e p e a t = true ; while ( r e p e a t ) { toRemove . c l e a r ( ) ; repeat = false ; nodes = DominatingSet . graphToArray ( newGraph ) ; f o r ( Node v : nodes ) { i f ( newGraph . d e g r e e ( v ) < 3 ) { f o r ( Node x : v . g e t A d j a c e n t ( ) ) { x . deleteEdge (v) ;

126

70 71 72 73 74 75 76 77 78 79 80 81 82 83 84

toRemove . add ( x ) ; newGraph . removeEdge ( newGraph . f i n d E d g e ( x , v ) ) ; r e p e a t = true ; } f o r ( Node w : toRemove ) { v . d e l e t e E d g e (w) ; } newGraph . removeVertex ( v ) ; } } } return newGraph ; }

public s t a t i c UndirectedSparseGraph <Node , S t r i n g > kCore ( UndirectedSparseGraph oldGraph , int k ) {

85 86 87 88 89 90 91 92 93 94 95 96 97 98 99

UndirectedSparseGraph <Node , S t r i n g > newGraph = oldGraph ; Node [ ] nodes ; L i s t <Node> toRemove = new A r r a y L i s t <Node > () ; boolean r e p e a t = true ; while ( r e p e a t ) { repeat = false ; nodes = DominatingSet . graphToArray ( newGraph ) ; f o r ( Node v : nodes ) { i f ( newGraph . d e g r e e ( v ) < k ) { f o r ( Node x : v . g e t A d j a c e n t ( ) ) { x . deleteEdge (v) ; toRemove . add ( x ) ; newGraph . removeEdge ( newGraph . f i n d E d g e ( x , v ) ) ; r e p e a t = true ; }

127

100 101 102 103 104 105 106 107 108 109 110

f o r ( Node w : toRemove ) { v . d e l e t e E d g e (w) ; } newGraph . removeVertex ( v ) ; } } } return newGraph ; }

public s t a t i c UndirectedSparseGraph <Node , S t r i n g > p e r c o l a t e E d g e s ( UndirectedSparseGraph <Node , S t r i n g > oldGraph , int e d g e s ) {

111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129

UndirectedSparseGraph <Node , S t r i n g > newGraph = oldGraph ; Node [ ] nodes = DominatingSet . graphToArray ( newGraph ) ; s h u f f l e A r r a y ( nodes ) ; Random genRandom = new Random( System . nanoTime ( ) ) ;

int toRemove = newGraph . getEdgeCount ( ) - e d g e s ; while ( toRemove > 0 ) { f o r ( Node v : nodes ) { int c u r r e n t D e g r e e = I n t e g e r . p a r s e I n t ( v . g e t D e g r e e ( ) ) ; i f ( c u r r e n t D e g r e e == 0 ) continue ; int amountDelete = genRandom . n e x t I n t ( c u r r e n t D e g r e e ) ; i f ( amountDelete == 0 ) continue ; L i s t <Node> a d j a c e n t = v . g e t A d j a c e n t ( ) ; L i s t <Node> d e l e t e d N o d e s = new A r r a y L i s t <Node > () ; while ( amountDelete > 0 ) { f o r ( Node w : a d j a c e n t ) { int t o D e l e t e = genRandom . n e x t I n t ( 2 ) ; i f ( ( t o D e l e t e == 1 ) & ( amountDelete > 0 ) ) { i f ( newGraph . f i n d E d g e (w, v ) == null ) continue ;

128

130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160

newGraph . removeEdge ( newGraph . f i n d E d g e (w, v ) ) ; amountDelete --; toRemove --; d e l e t e d N o d e s . add (w) ; i f ( toRemove == 0 ) { i f ( deletedNodes . s i z e ( ) > 0) { f o r ( Node x : d e l e t e d N o d e s ) { v . deleteEdge (x) ; x . deleteEdge (v) ; } } return newGraph ; } } e l s e i f ( amountDelete == 0 ) { break ; } } }

i f ( deletedNodes . s i z e ( ) > 0) { f o r ( Node x : d e l e t e d N o d e s ) { v . deleteEdge (x) ; x . deleteEdge (v) ; } }

i f ( toRemove == 0 ) { return newGraph ; } } }

129

161 162 163 164 165 166 167 168

while ( toRemove < 0 ) { Node nodeOne = nodes [ genRandom . n e x t I n t ( nodes . l e n g t h ) ] ; Node nodeTwo = nodes [ genRandom . n e x t I n t ( nodes . l e n g t h ) ] ;

i f ( nodeOne != nodeTwo ) { i f ( newGraph . f i n d E d g e ( nodeOne , nodeTwo ) == null ) { newGraph . addEdge ( nodeOne . getID ( ) + "-to -" + nodeTwo . getID ( ) , nodeOne , nodeTwo ) ;

169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189

toRemove++; nodeOne . addEdge ( nodeTwo ) ; nodeTwo . addEdge ( nodeOne ) ; } } } return newGraph ; }

// Implementing F i s h e r Y a t e s s h u f f l e s t a t i c void s h u f f l e A r r a y ( Node [ ] a r ) { Random rnd = new Random( System . nanoTime ( ) ) ; f o r ( int i = a r . l e n g t h - 1 ; i > 0 ; i --) { int i n d e x = rnd . n e x t I n t ( i + 1 ) ; // Simple swap Node a = a r [ i n d e x ] ; ar [ index ] = ar [ i ] ; ar [ i ] = a ; } } }

130

FileReader.java
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

/  / @author Marc L o z i e r

package graphpackage ;

import edu . u c i . i c s . jung . graph . Graph ; import edu . u c i . i c s . jung . graph . S p a r s e M u l t i g r a p h ; import edu . u c i . i c s . jung . graph . UndirectedSparseGraph ; import j a v a . i o . B u f f e r e d R e a d e r ; import j a v a . i o . B u f f e r e d W r i t e r ; import j a v a . i o . F i l e ; import j a v a . i o . F i l e I n p u t S t r e a m ; import j a v a . i o . FileNotFoundException ; import j a v a . i o . F i l e W r i t e r ; import j a v a . i o . IOException ; import j a v a . i o . InputStreamReader ; import j a v a . u t i l . A r r a y L i s t ; import j a v a . u t i l . Arrays ; import j a v a . u t i l . Comparator ; import j a v a . u t i l . L i s t ; import j a v a . u t i l . l o g g i n g . L e v e l ; import j a v a . u t i l . l o g g i n g . Logger ;

/    @author Marc / public c l a s s F i l e R e a d e r { private S t r i n g f i l e N a m e = " " ;

131

31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61

private B u f f e r e d R e a d e r r e a d e r = null ; private S t r i n g tempLine = " " ; private F i l e I n p u t S t r e a m f i l e = null ; private int k = 0 ; private UndirectedSparseGraph <Node , S t r i n g > graph = null ; private f i n a l L i s t <Node> n o d e L i s t = new A r r a y L i s t <Node > () ; private boolean mgeop = f a l s e ; private boolean p e r c o l a t e = f a l s e ;

public F i l e R e a d e r ( S t r i n g f i l e N a m e ) { this . fileName = fileName ; this . k = 0 ; }

public F i l e R e a d e r ( S t r i n g fileName , int c o r e ) { this . fileName = fileName ; this . k = core ; }

public void setMGEOP( boolean s ) { t h i s . mgeop = s ; }

public void s e t P e r c o l a t e ( boolean p ) { this . p e r c o l a t e = p ; }

public void s e t C o r e ( int c o r e ) { this . k = core ; }

132

62 63 64 65 66

private void r e a d F i l e ( ) { try { i f ( mgeop ) { if ( percolate ) { F i l e tmp = new F i l e ( f i l e N a m e . r e p l a c e ( " . smat " , " p "+k+" c o m p r e s s e d . smat " ) ) ;

67

i f ( tmp . e x i s t s ( ) && ! tmp . i s D i r e c t o r y ( ) ) { // i f compressed f i l e e x i s t - use i t

68

f i l e N a m e = f i l e N a m e . r e p l a c e ( " . smat " , " p "+k+" c o m p r e s s e d . smat " ) ;

69 70

} else { f i l e N a m e = f i l e N a m e . r e p l a c e ( " . smat " , " 0 c o m p r e s s e d . smat " ) ;

71 72 73

} } else { F i l e tmp = new F i l e ( f i l e N a m e . r e p l a c e ( " . smat " , " " + k+" c o m p r e s s e d . smat " ) ) ;

74

i f ( tmp . e x i s t s ( ) && ! tmp . i s D i r e c t o r y ( ) ) { // i f compressed f i l e e x i s t - use i t

75

f i l e N a m e = f i l e N a m e . r e p l a c e ( " . smat " , " " + k+" c o m p r e s s e d . smat " ) ;

76 77

} else { f i l e N a m e = f i l e N a m e . r e p l a c e ( " . smat " , " 0 c o m p r e s s e d . smat " ) ;

78 79 80 81

} } } else { F i l e tmp = new F i l e ( f i l e N a m e . r e p l a c e ( " . smat " , " " + k+" c o m p r e s s e d . smat " ) ) ;

82

i f ( tmp . e x i s t s ( ) && ! tmp . i s D i r e c t o r y ( ) ) { // i f compressed f i l e e x i s t - use i t

133

83

f i l e N a m e = f i l e N a m e . r e p l a c e ( " . smat " , " " + k+" c o m p r e s s e d . smat " ) ;

84 85 86 87 88 89 90

} }

f i l e = new F i l e I n p u t S t r e a m ( f i l e N a m e ) ; r e a d e r = new B u f f e r e d R e a d e r ( new InputStreamReader ( f i l e ) ) ; } catch ( FileNotFoundException ex ) { Logger . g e t L o g g e r ( F i l e R e a d e r . c l a s s . getName ( ) ) . l o g ( L e v e l . SEVERE, null , ex ) ;

91 92 93 94 95 96 97 98

} }

private void c l o s e F i l e ( ) { try { reader . close () ; } catch ( IOException ex ) { Logger . g e t L o g g e r ( F i l e R e a d e r . c l a s s . getName ( ) ) . l o g ( L e v e l . SEVERE, null , ex ) ;

99 100 101 102 103 104

} }

public void compressFileNoRead ( ) { try { UndirectedSparseGraph <Node , S t r i n g > g = new UndirectedSparseGraph < Node , S t r i n g > () ;

105 106 107 108 109

f i l e = new F i l e I n p u t S t r e a m ( f i l e N a m e ) ; r e a d e r = new B u f f e r e d R e a d e r ( new InputStreamReader ( f i l e ) ) ; try { nodeList . c l e a r () ; String f i r s t = reader . readLine () ;

134

110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125

S t r i n g [ ] t m p S p l i t = f i r s t . s p l i t ( " \\ s+" ) ; int i n t N o d e s = I n t e g e r . p a r s e I n t ( t m p S p l i t [ 0 ] ) ; Node tmp ; f o r ( int i = 0 ; i < i n t N o d e s ; i ++) { tmp = new Node ( i ) ; n o d e L i s t . add ( tmp ) ; g . addVertex ( tmp ) ; } while ( ( tempLine = r e a d e r . r e a d L i n e ( ) ) != null ) { t m p S p l i t = tempLine . s p l i t ( " \\ s+" ) ; int toNode = I n t e g e r . p a r s e I n t ( t m p S p l i t [ 0 ] ) ; int fromNode = I n t e g e r . p a r s e I n t ( t m p S p l i t [ 1 ] ) ; // i n t numEdges = I n t e g e r . p a r s e I n t ( t m p S p l i t [ 2 ] ) ; Node a = n o d e L i s t . g e t ( fromNode ) ; Node b = n o d e L i s t . g e t ( toNode ) ; i f ( ( ! g . c o n t a i n s E d g e ( a . getID ( ) + "-to -" + b . getID ( ) ) ) && ( ! g . c o n t a i n s E d g e ( b . getID ( ) + "-to -" + a . getID ( ) ) ) ) {

126 127 128

g . addEdge ( a . getID ( ) + "-to -" + b . getID ( ) , a , b ) ; a . addEdge ( b ) ; // NOTE: t h i s l i n e b e l o w i s not needed ( c o m p r e s s e s file i f omitted ) b . addEdge ( a ) ; } } exportSMAT ( g ) ; } catch ( IOException ex ) { ex . p r i n t S t a c k T r a c e ( ) ; } finally { closeFile () ; } } catch ( FileNotFoundException ex ) {

129 130 131 132 133 134 135 136 137 138

135

139

Logger . g e t L o g g e r ( F i l e R e a d e r . c l a s s . getName ( ) ) . l o g ( L e v e l . SEVERE, null , ex ) ;

140 141 142 143 144 145

} }

public void c o m p r e s s F i l e ( ) { UndirectedSparseGraph <Node , S t r i n g > g = new UndirectedSparseGraph <Node , S t r i n g > () ;

146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165

readFile () ; try { nodeList . c l e a r () ; String f i r s t = reader . readLine () ; S t r i n g [ ] t m p S p l i t = f i r s t . s p l i t ( " \\ s+" ) ; int i n t N o d e s = I n t e g e r . p a r s e I n t ( t m p S p l i t [ 0 ] ) ; Node tmp ; f o r ( int i = 0 ; i < i n t N o d e s ; i ++) { tmp = new Node ( i ) ; n o d e L i s t . add ( tmp ) ; g . addVertex ( tmp ) ; } while ( ( tempLine = r e a d e r . r e a d L i n e ( ) ) != null ) { t m p S p l i t = tempLine . s p l i t ( " \\ s+" ) ; int toNode = I n t e g e r . p a r s e I n t ( t m p S p l i t [ 0 ] ) ; int fromNode = I n t e g e r . p a r s e I n t ( t m p S p l i t [ 1 ] ) ; // i n t numEdges = I n t e g e r . p a r s e I n t ( t m p S p l i t [ 2 ] ) ; Node a = n o d e L i s t . g e t ( fromNode ) ; Node b = n o d e L i s t . g e t ( toNode ) ; i f ( ( ! g . c o n t a i n s E d g e ( a . getID ( ) + "-to -" + b . getID ( ) ) ) && ( ! g . c o n t a i n s E d g e ( b . getID ( ) + "-to -" + a . getID ( ) ) ) ) {

166

g . addEdge ( a . getID ( ) + "-to -" + b . getID ( ) , a , b ) ;

136

167 168

a . addEdge ( b ) ; // NOTE: t h i s l i n e b e l o w i s not needed ( c o m p r e s s e s f i l e omitted ) if

169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196

b . addEdge ( a ) ; } } exportSMAT ( g ) ; } catch ( IOException ex ) { ex . p r i n t S t a c k T r a c e ( ) ; } finally { closeFile () ; } }

// EXPORT SMAT FILE TYPE (COMPRESSED) public void exportSMAT ( UndirectedSparseGraph g ) { try { switch ( k ) { case 0 : // n o t h i n g break ; case 1 : g = GraphManipulation . oneCore ( g ) ; break ; case 2 : g = GraphManipulation . twoCore ( g ) ; break ; case 3 : g = GraphManipulation . t h r e e C o r e ( g ) ; break ;

137

197 198 199 200 201

default : g = GraphManipulation . kCore ( g , k ) ; break ; } S t r i n g prepend = g . getVertexCount ( ) + " " + g . getVertexCount ( ) + " " + g . getEdgeCount ( ) ;

202 203 204 205 206 207 208 209 210 211 212

Node [ ] v t x s = new Node [ g . getVertexCount ( ) ] ; g . g e t V e r t i c e s ( ) . toArray ( v t x s ) ; Arrays . s o r t ( vtxs , new Comparator ( ) { @Override public int compare ( Object o1 , Object o2 ) { return ( ( Node ) o1 ) . compareTo ( ( Node ) o2 ) ; } }) ; File filew ; if ( percolate ) { f i l e N a m e = f i l e N a m e . r e p l a c e ( " 0 c o m p r e s s e d . smat " , " " + k+" c o m p r e s s e d . smat " ) ;

213

f i l e N a m e = f i l e N a m e . r e p l a c e ( " " + k+" c o m p r e s s e d . smat " , " . smat ") ;

214

f i l e w = new F i l e ( f i l e N a m e . r e p l a c e ( " . smat " , " p " + k+" c o m p r e s s e d . smat " ) ) ;

215 216

} else { f i l e w = new F i l e ( f i l e N a m e . r e p l a c e ( " 0 c o m p r e s s e d . smat " , " "+k+ " c o m p r e s s e d . smat " ) ) ;

217 218 219 220 221 222

}

B u f f e r e d W r i t e r w r i t e r = new B u f f e r e d W r i t e r ( new F i l e W r i t e r ( f i l e w ) ) ; w r i t e r . w r i t e ( prepend ) ; w r i t e r . newLine ( ) ; f o r ( Node vtx : v t x s ) {

138

223 224 225 226 227 228 229 230 231 232 233 234 235 236 237

f o r ( Node a d j : vtx . g e t A d j a c e n t ( ) ) { w r i t e r . w r i t e ( a d j . getID ( ) + " " + vtx . getID ( ) + " 1 " ) ; w r i t e r . newLine ( ) ; a d j . d e l e t e E d g e ( vtx ) ; } } writer . close () ; } catch ( IOException ex ) { ex . p r i n t S t a c k T r a c e ( ) ; } }

// EXPORT SMAT FILE TYPE (COMPRESSED) public s t a t i c void exportSMAT ( UndirectedSparseGraph g , int k , boolean p e r c o l a t e , S t r i n g name ) {

238 239 240 241 242 243 244 245 246 247 248 249 250 251 252

try { switch ( k ) { case 0 : // n o t h i n g break ; case 1 : g = GraphManipulation . oneCore ( g ) ; break ; case 2 : g = GraphManipulation . twoCore ( g ) ; break ; case 3 : g = GraphManipulation . t h r e e C o r e ( g ) ; break ; default :

139

253 254 255 256

g = GraphManipulation . kCore ( g , k ) ; break ; } S t r i n g prepend = g . getVertexCount ( ) + " " + g . getVertexCount ( ) + " " + g . getEdgeCount ( ) ;

257 258 259 260 261 262 263 264 265 266 267 268

Node [ ] v t x s = new Node [ g . getVertexCount ( ) ] ; g . g e t V e r t i c e s ( ) . toArray ( v t x s ) ; Arrays . s o r t ( vtxs , new Comparator ( ) { @Override public int compare ( Object o1 , Object o2 ) { return ( ( Node ) o1 ) . compareTo ( ( Node ) o2 ) ; } }) ; File filew ; S t r i n g f i l e N a m e = name ; if ( percolate ) { f i l e N a m e = f i l e N a m e . r e p l a c e ( " 0 c o m p r e s s e d . smat " , " " + k+" c o m p r e s s e d . smat " ) ;

269

f i l e N a m e = f i l e N a m e . r e p l a c e ( " " + k+" c o m p r e s s e d . smat " , " . smat ") ;

270

f i l e w = new F i l e ( f i l e N a m e . r e p l a c e ( " . smat " , " p " + k+" c o m p r e s s e d . smat " ) ) ;

271 272

} else { f i l e w = new F i l e ( f i l e N a m e . r e p l a c e ( " 0 c o m p r e s s e d . smat " , " "+k+ " c o m p r e s s e d . smat " ) ) ;

273 274 275 276 277 278

}

B u f f e r e d W r i t e r w r i t e r = new B u f f e r e d W r i t e r ( new F i l e W r i t e r ( f i l e w ) ) ; w r i t e r . w r i t e ( prepend ) ; w r i t e r . newLine ( ) ; f o r ( Node vtx : v t x s ) {

140

279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308

f o r ( Node a d j : vtx . g e t A d j a c e n t ( ) ) { w r i t e r . w r i t e ( a d j . getID ( ) + " " + vtx . getID ( ) + " 1 " ) ; w r i t e r . newLine ( ) ; a d j . d e l e t e E d g e ( vtx ) ; } } writer . close () ; } catch ( IOException ex ) { ex . p r i n t S t a c k T r a c e ( ) ; } }

public UndirectedSparseGraph <Node , S t r i n g > generateGraph ( ) { graph = new UndirectedSparseGraph <Node , S t r i n g > () ; readFile () ; try { tempLine = r e a d e r . r e a d L i n e ( ) ; S t r i n g [ ] t m p S p l i t = tempLine . s p l i t ( " \\ s+" ) ; int i n t N o d e s = I n t e g e r . p a r s e I n t ( t m p S p l i t [ 0 ] ) ; createNodes ( intNodes ) ; while ( ( tempLine = r e a d e r . r e a d L i n e ( ) ) != null ) { t m p S p l i t = tempLine . s p l i t ( " \\ s+" ) ; int toNode = I n t e g e r . p a r s e I n t ( t m p S p l i t [ 0 ] ) ; int fromNode = I n t e g e r . p a r s e I n t ( t m p S p l i t [ 1 ] ) ; // i n t numEdges = I n t e g e r . p a r s e I n t ( t m p S p l i t [ 2 ] ) ; Node a = n o d e L i s t . g e t ( fromNode ) ; Node b = n o d e L i s t . g e t ( toNode ) ; i f ( ! a . i s A d j a c e n t ( b ) && ! b . i s A d j a c e n t ( a ) ) { graph . addEdge ( a . getID ( ) + "-to -" + b . getID ( ) , a , b ) ; a . addEdge ( b ) ;

141

309

// NOTE: t h i s l i n e b e l o w i s not needed ( c o m p r e s s e s f i l e omitted )

if

310 311 312 313 314

b . addEdge ( a ) ; } } } catch ( IOException ex ) { Logger . g e t L o g g e r ( F i l e R e a d e r . c l a s s . getName ( ) ) . l o g ( L e v e l . SEVERE, null , ex ) ;

315 316 317 318 319 320 321 322 323 324 325 326 327 328 329

} finally { closeFile () ; } return graph ; }

private void c r e a t e N o d e s ( int numOfNodes ) { Node tmp ; f o r ( int i = 0 ; i < numOfNodes ; i ++) { tmp = new Node ( i ) ; n o d e L i s t . add ( tmp ) ; graph . addVertex ( tmp ) ; } } }

DominatingSet.java
1 2 3 4 5 6

/  / @author Marc L o z i e r

package graphpackage ;

142

7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29

import edu . u c i . i c s . jung . graph . Graph ; import edu . u c i . i c s . jung . graph . UndirectedSparseGraph ; import j a v a . i o . B u f f e r e d R e a d e r ; import j a v a . i o . F i l e I n p u t S t r e a m ; import j a v a . i o . IOException ; import j a v a . i o . InputStreamReader ; import j a v a . u t i l . A r r a y L i s t ; import j a v a . u t i l . Arrays ; import j a v a . u t i l . Comparator ; import j a v a . u t i l . HashSet ; import j a v a . u t i l . L i s t ; import j a v a . u t i l . S e t ; import j a v a . u t i l . l o g g i n g . L e v e l ; import j a v a . u t i l . l o g g i n g . Logger ;

/    @author Marc / public c l a s s DominatingSet {

private s t a t i c boolean i s D o m i n a t i n g ( UndirectedSparseGraph g , L i s t <Node> ds ) {

30 31 32 33 34 35 36

L i s t <Node> c o v e r S e t = new A r r a y L i s t <Node > () ; f o r ( Node v : ds ) { c o v e r S e t . addAll ( v . g e t A d j a c e n t ( ) ) ; c o v e r S e t . add ( v ) ; }; Set <Node> u n i q u e C o v e r S e t = new HashSet <Node >( c o v e r S e t ) ; return u n i q u e C o v e r S e t . s i z e ( ) == g . getVertexCount ( ) ;

143

37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59

}

public s t a t i c Node [ ] graphToArray ( UndirectedSparseGraph g ) { Node [ ] v t x s = new Node [ g . getVertexCount ( ) ] ; g . g e t V e r t i c e s ( ) . toArray ( v t x s ) ; return v t x s ; } // A l g o r i t h m : RANDOM public s t a t i c L i s t <Node> dsrandom ( UndirectedSparseGraph g ) { L i s t <Node> ds = new A r r a y L i s t <Node > () ; Node [ ] vtx = graphToArray ( g ) ; GraphManipulation . s h u f f l e A r r a y ( vtx ) ; f o r ( Node v : vtx ) { ds . add ( v ) ; i f ( i s D o m i n a t i n g ( g , ds ) ) { break ; } } return ds ; }

// A l g o r i t h m : DS-Rank Improved public s t a t i c L i s t <Node> dsrankImproved ( UndirectedSparseGraph g , S t r i n g rankingFile ) {

60 61 62 63

L i s t <Node> ds = new A r r a y L i s t <Node > () ; L i s t <Node> c o v e r S e t = new A r r a y L i s t <Node > () ; try { B u f f e r e d R e a d e r br = new B u f f e r e d R e a d e r ( new InputStreamReader ( new FileInputStream ( rankingFile ) ) ) ;

64 65

String line ; Node [ ] v t x s = graphToArray ( g ) ;

144

66 67 68 69 70 71 72 73

while ( ( l i n e = br . r e a d L i n e ( ) ) != null ) { f o r ( Node v : v t x s ) { i f ( S t r i n g . v a l u e O f ( v . getID ( ) ) . e q u a l s I g n o r e C a s e ( l i n e ) ) { i f ( ! coverSet . contains (v) ) { ds . add ( v ) ; c o v e r S e t . add ( v ) ; c o v e r S e t . addAll ( v . g e t A d j a c e n t ( ) ) ; break ; // b r e a k o u t o f f o r l o o p - o n l y 1 node w i t h t h a t ID

74 75 76 77 78 79 80 81 82 83 84 85 86 87

} else { continue ; } } else { // s k i p node } } i f ( i s D o m i n a t i n g ( g , ds ) ) { break ; // l e a v e f i l e , found DS ! } } br . c l o s e ( ) ; } catch ( IOException ex ) { Logger . g e t L o g g e r ( DominatingSet . c l a s s . getName ( ) ) . l o g ( L e v e l . SEVERE, null , ex ) ;

88 89 90 91 92 93

} return ds ; }

// A l g o r i t h m : DS-Rank public s t a t i c L i s t <Node> dsrank ( UndirectedSparseGraph g , S t r i n g rankingFile ) {

145

94 95 96

L i s t <Node> ds = new A r r a y L i s t <Node > () ; try { B u f f e r e d R e a d e r br = new B u f f e r e d R e a d e r ( new InputStreamReader ( new FileInputStream ( rankingFile ) ) ) ;

97 98 99 100 101 102 103

String line ; Node [ ] v t x s = graphToArray ( g ) ; while ( ( l i n e = br . r e a d L i n e ( ) ) != null ) { f o r ( Node v : v t x s ) { i f ( S t r i n g . v a l u e O f ( v . getID ( ) ) . e q u a l s I g n o r e C a s e ( l i n e ) ) { ds . add ( v ) ; break ; // b r e a k o u t o f f o r l o o p - o n l y 1 node w i t h t h a t ID

104 105 106 107 108 109 110 111 112 113 114

} else { // s k i p node } } i f ( i s D o m i n a t i n g ( g , ds ) ) { break ; // l e a v e f i l e , found DS ! } } br . c l o s e ( ) ; } catch ( IOException ex ) { Logger . g e t L o g g e r ( DominatingSet . c l a s s . getName ( ) ) . l o g ( L e v e l . SEVERE, null , ex ) ;

115 116 117 118 119 120 121

} return ds ; }

// A l g o r i t h m : DS-DC public s t a t i c L i s t <Node> dsdc ( UndirectedSparseGraph g ) { L i s t <Node> ds = new A r r a y L i s t <Node >(g . g e t V e r t i c e s ( ) ) ; // DS = V

146

122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152

Node arg0 , a r g 1 ; Comparator <Node> comp = new Comparator <Node > () { @Override public int compare ( f i n a l Node arg0 , f i n a l Node a r g 1 ) { return a r g 0 . compareDegreeToAsc ( a r g 1 ) ; } };

Node [ ] v t x s = graphToArray ( g ) ; Arrays . s o r t ( vtxs , comp ) ; f o r ( Node v : v t x s ) { // v i s t h e minimum node ds . remove ( v ) ; i f ( ! i s D o m i n a t i n g ( g , ds ) ) { ds . add ( v ) ; } } return ds ; }

// A l g o r i t h m : DS-RAI public s t a t i c L i s t <Node> d s r a i ( UndirectedSparseGraph g , int phase ) { L i s t <Node> ds ; L i s t <Node> b l a c k = new A r r a y L i s t <Node > () ; L i s t <Node> gray = new A r r a y L i s t <Node > () ; i f ( phase == 1 ) { // p ha s e 1 Node arg0 , a r g 1 ; Comparator <Node> comp = new Comparator <Node > () { @Override public int compare ( f i n a l Node arg0 , f i n a l Node a r g 1 ) {

147

153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172

return a r g 0 . compareDegreeTo ( a r g 1 ) ; } };

Node [ ] v t x s = graphToArray ( g ) ; Arrays . s o r t ( vtxs , comp ) ; f o r ( Node v : v t x s ) { i f ( ! gray . c o n t a i n s ( v ) ) { b l a c k . add ( v ) ; f o r ( Node dominatee : v . g e t A d j a c e n t ( ) ) { gray . add ( dominatee ) ; } } } } ds = b l a c k ; return ds ; }

public s t a t i c L i s t <Node> b u r n i n g ( UndirectedSparseGraph <Node , S t r i n g > gCored ) {

173 174 175 176 177 178 179 180 181 182

L i s t <Node> b u r n i n g S e q u e n c e = new A r r a y L i s t <Node > () ; L i s t <Node> burnt = new A r r a y L i s t <Node > () ;

Node arg0 , a r g 1 ; Comparator <Node> comp = new Comparator <Node > () { @Override public int compare ( f i n a l Node arg0 , f i n a l Node a r g 1 ) { return a r g 0 . compareDegreeTo ( a r g 1 ) ; } };

148

183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213

Node [ ] v t x s = graphToArray ( gCored ) ; Arrays . s o r t ( vtxs , comp ) ; // l o o p h i g h e s t t o l o w e s t d e g r e e

// Extend b u r n i n g s e t

f o r ( int i = 0 ; i < v t x s . l e n g t h ; i ++) { i f ( ! burnt . c o n t a i n s ( v t x s [ i ] ) ) { L i s t <Node> temp = new A r r a y L i s t <Node > () ; f o r ( Node burned : burnt ) { temp . addAll ( burned . g e t A d j a c e n t ( ) ) ; } burnt . addAll ( temp ) ;

Set <Node> u n i q u e C o v e r S e t = new HashSet <Node >( burnt ) ; burnt = new A r r a y L i s t <Node >( u n i q u e C o v e r S e t ) ;

boolean f l a g = true ; while ( f l a g ) { i f ( ! burnt . c o n t a i n s ( v t x s [ i ] ) ) { burnt . add ( v t x s [ i ] ) ; b u r n i n g S e q u e n c e . add ( v t x s [ i ] ) ; flag = false ; } else { // need n e x t h i g h e r v e r t e x i ++;

} i f ( i == v t x s . l e n g t h ) { break ;

149

214 215 216 217 218 219 220 221 222 223

} } } i f ( burnt . s i z e ( ) == v t x s . l e n g t h ) { break ; } } return b u r n i n g S e q u e n c e ; } }

MGEOP.java
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19

/  / @author Marc L o z i e r

package graphpackage ;

import edu . u c i . i c s . jung . graph . Graph ; import edu . u c i . i c s . jung . graph . S p a r s e M u l t i g r a p h ; import edu . u c i . i c s . jung . graph . UndirectedSparseGraph ; import j a v a . i o . B u f f e r e d W r i t e r ; import j a v a . i o . F i l e ; import j a v a . i o . F i l e W r i t e r ; import j a v a . i o . IOException ; import j a v a . t e x t . DecimalFormat ; import j a v a . u t i l . A r r a y L i s t ; import j a v a . u t i l . Arrays ; import j a v a . u t i l . C o l l e c t i o n s ; import j a v a . u t i l . L i s t ; import j a v a . u t i l . Random ;

150

20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39

import j a v a . u t i l . l o g g i n g . L e v e l ; import j a v a . u t i l . l o g g i n g . Logger ;

/    @author Marc / public c l a s s MGEOP { private int n ; private int m = 2 ; private double a l p h a = 0 . 6 ; private double b e t a = 0 . 2 ; private double p = 0 . 5 ; public s t a t i c L i s t <Node> n o d e L i s t = new A r r a y L i s t <Node > () ; public boolean saveRank = f a l s e ; public S t r i n g d a t a S e t = " " ; public int k c o r e = 0 ; public s t a t i c f i n a l int MAX THREADS = 3 ; public s t a t i c int t h r e a d s c o u n t e r = 0 ; private s t a t i c UndirectedSparseGraph <Node , S t r i n g > g G l o b a l = new UndirectedSparseGraph <Node , S t r i n g > () ;

40 41 42 43 44 45 46 47 48 49

public MGEOP( int n , int m, double alpha , double beta , double p ) { this . n = n ; t h i s .m = m; this . alpha = alpha ; this . beta = beta ; this . p = p ; }

151

50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80

// INV- MGEO -P public UndirectedSparseGraph <Node , S t r i n g > g e n e r a te I n v G r a p h ( ) { g G l o b a l = new UndirectedSparseGraph <Node , S t r i n g > () ; createNodes () ; generateRank ( ) ; generateRadius () ; createEdgesInv () ; return g G l o b a l ; }

// MGEO -P public UndirectedSparseGraph <Node , S t r i n g > generateGraph ( ) { g G l o b a l = new UndirectedSparseGraph <Node , S t r i n g > () ; createNodes () ; generateRank ( ) ; generateRadius () ; createEdges () ; return g G l o b a l ; }

public Graph<Node , S t r i n g > generateGraphSpeedTest ( ) { System . out . p r i n t l n ( " > C r e a t i n g Nodes " ) ; createNodes () ; System . out . p r i n t l n ( " > G e n e r a t i n g Rank" ) ; generateRank ( ) ; System . out . p r i n t l n ( " > G e n e r a t i n g Radius " ) ; generateRadius () ; System . out . p r i n t l n ( " > C r e a t i n g Edges " ) ; createEdgesThread ( ) ; System . out . p r i n t l n ( " > Complete " ) ; return g G l o b a l ;

152

81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111

}

// Make MGEOP w i t h a t most e e d g e s public Graph<Node , S t r i n g > generateGraph ( int e ) { boolean i n v a l i d = true ; Graph<Node , S t r i n g > graph = new S p a r s e M u l t i g r a p h <Node , S t r i n g > () ; while ( i n v a l i d ) { createNodes () ; generateRank ( ) ; generateRadius () ; createEdges () ; i f ( graph . getEdgeCount ( ) > e ) { invalid = false ; } } return graph ; }

public s t a t i c void returnNodeThread ( Node a ) { n o d e L i s t . add ( a ) ; g G l o b a l . addVertex ( a ) ; }

private void createNodesThreaded ( ) { long s t a r t = System . nanoTime ( ) ; try { n o d e L i s t = new A r r a y L i s t <Node > () ;

f o r ( int i = 0 ; i < n ; i ++) { NodeThread nt = new NodeThread ( i , m) ;

153

112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127

Thread t = new Thread ( nt ) ; t . start () ; i f ( i == ( n / 4 ) ) { System . out . p r i n t l n ( "25% done Nodes " ) ; t . join () ; } e l s e i f ( i == ( n / 2 ) ) { System . out . p r i n t l n ( "50% done Nodes " ) ; t . join () ; } e l s e i f ( i == ( 3  ( n / 4 ) ) ) { System . out . p r i n t l n ( "75% done Nodes " ) ; t . join () ; }

} } catch ( I n t e r r u p t e d E x c e p t i o n ex ) { Logger . g e t L o g g e r (MGEOP. c l a s s . getName ( ) ) . l o g ( L e v e l . SEVERE, null , ex );

128 129 130 131 132 133 134 135 136 137 138 139 140 141

} long dur = System . nanoTime ( ) - s t a r t ; System . out . p r i n t l n ( dur ) ; }

private void c r e a t e N o d e s ( ) { long s t a r t = System . nanoTime ( ) ; n o d e L i s t = new A r r a y L i s t <Node >(n ) ; Node tmp ;

f o r ( int i = 0 ; i < n ; i ++) { tmp = new Node ( i , m) ; f o r ( int temp = 0 ; temp < m; temp++) { tmp . s e t C o o r d i n a t e s ( Math . random ( ) , temp ) ;

154

142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160

}

n o d e L i s t . add ( tmp ) ; g G l o b a l . addVertex ( tmp ) ; i f ( i == ( n / 4 ) ) { System . out . p r i n t l n ( "25% done Nodes " ) ; } e l s e i f ( i == ( n / 2 ) ) { System . out . p r i n t l n ( "50% done Nodes " ) ; } e l s e i f ( i == ( 3  ( n / 4 ) ) ) { System . out . p r i n t l n ( "75% done Nodes " ) ; }

} long dur = System . nanoTime ( ) - s t a r t ; }

private void generateRank ( ) { C o l l e c t i o n s . s h u f f l e ( n o d e L i s t , new Random( System . nanoTime ( ) ) ) ; F i l e f i l e O u t = new F i l e ( " /home/ m l o z i e r /Work/FB100- DATA/mgeop-models / data -" + d a t a S e t + "-" +k c o r e + "-rank . t x t " ) ;

161 162

try { B u f f e r e d W r i t e r w r i t e r = new B u f f e r e d W r i t e r ( new F i l e W r i t e r ( f i l e O u t ) );

163 164 165 166 167 168 169 170

S t r i n g dataOut = " " ; f o r ( Node n o d e L i s t 1 : n o d e L i s t ) { dataOut = S t r i n g . v a l u e O f ( n o d e L i s t 1 . getID ( ) ) ; w r i t e r . w r i t e ( dataOut ) ; w r i t e r . newLine ( ) ; } writer . close () ; } catch ( IOException ex ) {

155

171

// Logger . g e t L o g g e r (MGEOP. c l a s s . getName ( ) ) . l o g ( L e v e l .SEVERE, n u l l , ex ) ;

172 173 174 175 176 177 178

} }

private void g e n e r a t e R a d i u s ( ) { int rank = 1 ; f o r ( Node v : n o d e L i s t ) { v . setR ( 0 . 5  Math . pow ( Math . pow ( n , -1 b e t a )  Math . pow ( rank , -1 a l p h a ) , 1 . 0 /m) ) ;

179 180 181 182 183 184 185 186 187 188 189 190 191 192

rank++; } }

private void c r e a t e E d g e s I n v ( ) { f o r ( int a = 0 ; a < n o d e L i s t . s i z e ( ) ; a++) { Node x = n o d e L i s t . g e t ( a ) ; f o r ( int b = a + 1 ; b < n o d e L i s t . s i z e ( ) ; b++) { Node y = n o d e L i s t . g e t ( b ) ; if (x . inInfluence (y) ) { p = 1 - ( x . r e t u r n I n f i n i t y D i s t a n c e ( y ) /x . getR ( ) ) ; // System . o u t . p r i n t l n ( p ) ; i f ( Math . random ( ) < p ) { g G l o b a l . addEdge ( x . getID ( ) + "-to -" + y . getID ( ) , x , y) ;

193 194 195 196 197 198

x . addEdge ( y ) ; y . addEdge ( x ) ; } } } }

156

199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229

}

private void c r e a t e E d g e s T e s t ( ) { long s t a r t ; long end = 0 , dur ; f o r ( int a = 0 ; a < n o d e L i s t . s i z e ( ) ; a++) { Node x = n o d e L i s t . g e t ( a ) ; s t a r t = System . nanoTime ( ) ; f o r ( int b = a + 1 ; b < n o d e L i s t . s i z e ( ) ; b++) { Node y = n o d e L i s t . g e t ( b ) ;

i f ( ( x . i n I n f l u e n c e ( y ) ) && ( Math . random ( ) < p ) ) { x . addEdge ( y ) ; y . addEdge ( x ) ; } } dur = System . nanoTime ( ) - s t a r t ; end = end + dur ; } System . out . p r i n t l n ( " T o t a l time : " + end ) ; }

private void c r e a t e E d g e s T h r e a d ( ) { int s = n o d e L i s t . s i z e ( ) ; f o r ( int a = 0 ; a < n o d e L i s t . s i z e ( ) ; a++) { EdgeThread e t = new EdgeThread ( a , p ) ; Thread t = new Thread ( e t ) ; t . start () ; try { i f ( a == ( s / 4 ) ) { System . out . p r i n t l n ( "25% done Edges " ) ;

157

230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249

} e l s e i f ( a == ( s / 2 ) ) { System . out . p r i n t l n ( "50% done Edges " ) ; } e l s e i f ( a == ( 3  ( s / 4 ) ) ) { System . out . p r i n t l n ( "75% done Edges " ) ; } i f ( ( a % 3 ) == 0 ) { t . join () ; } } catch ( E x c e p t i o n e ) {

} } }

private void c r e a t e E d g e s ( ) { int s = n o d e L i s t . s i z e ( ) ; f o r ( int a = 0 ; a < s ; a++) { double s t a r t = System . nanoTime ( ) ; f o r ( int b = a ; b < s ; b++) { i f ( ( Math . random ( ) <= p ) && ( a != b ) && ( ! g G l o b a l . i s N e i g h b o r ( nodeList . get ( a ) , nodeList . get (b) ) ) ) {

250 251

i f ( nodeList . get ( a ) . i n I n f l u e n c e ( nodeList . get (b) ) ) { g G l o b a l . addEdge ( n o d e L i s t . g e t ( a ) . getID ( ) + "-" + n o d e L i s t . g e t ( b ) . getID ( ) , n o d e L i s t . g e t ( a ) , n o d e L i s t . g e t ( b ) ) ;

252 253 254 255 256 257 258

n o d e L i s t . g e t ( a ) . addEdge ( n o d e L i s t . g e t ( b ) ) ; n o d e L i s t . g e t ( b ) . addEdge ( n o d e L i s t . g e t ( a ) ) ; } } } i f ( a == ( s / 4 ) ) { System . out . p r i n t l n ( "25% done Edges " ) ;

158

259 260 261 262 263 264 265 266 267

} e l s e i f ( a == ( s / 2 ) ) { System . out . p r i n t l n ( "50% done Edges " ) ; } e l s e i f ( a == ( 3  ( s / 4 ) ) ) { System . out . p r i n t l n ( "75% done Edges " ) ; } double nElapsed = System . nanoTime ( ) - s t a r t ; // In s e c o n d s double nTotalTime = ( 1 . 0 / ( ( double ) a / ( double ) s ) )  nElapsed ; double nRemaining = nTotalTime - nElapsed ; System . out . p r i n t l n ( ( ( double ) a / ( double ) s  1 0 0 . 0 ) + "%

complete , Estimated "+nRemaining+" s e c o n d s r e m a i n i n g " ) ;
268 269 270 271

} }

}

RandomGraphGenerator.java
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15

package graphpackage ;

import edu . u c i . i c s . jung . graph . Graph ; import edu . u c i . i c s . jung . graph . S p a r s e M u l t i g r a p h ; import edu . u c i . i c s . jung . graph . UndirectedSparseGraph ; import j a v a . t e x t . DecimalFormat ; import j a v a . u t i l . A r r a y L i s t ; import j a v a . u t i l . Arrays ; import j a v a . u t i l . Comparator ; import j a v a . u t i l . L i s t ; import j a v a . u t i l . c o n c u r r e n t . TimeUnit ; import j a v a f x . s c e n e . shape . Box ; import m a t l a b c o n t r o l .  ;

public c l a s s RandomGraphGenerator {

159

16 17 18 19 20 21 22 23 24 25 26 27

private int n ; private double p ;

public s t a t i c Box box ;

public RandomGraphGenerator ( int n , double p ) { this . n = n ; this . p = p ; }

public UndirectedSparseGraph <Node , S t r i n g > generateGNPRandomGraph ( ) { UndirectedSparseGraph <Node , S t r i n g > g = new UndirectedSparseGraph <Node , S t r i n g > () ;

28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43

L i s t <Node> n o d e L i s t = new A r r a y L i s t <Node > () ; System . out . p r i n t l n ( " C r e a t i n g G( n , p )=G( " + n+" , "+p+" ) " ) ; f o r ( int i = 0 ; i < n ; i ++) { Node tmp = new Node ( i ) ; g . addVertex ( tmp ) ; n o d e L i s t . add ( tmp ) ; }

f o r ( int i = 0 ; i < n ; i ++) { Node a = n o d e L i s t . g e t ( i ) ; f o r ( int j = i + 1 ; j < n ; j ++) { Node b = n o d e L i s t . g e t ( j ) ; i f ( Math . random ( ) < p ) { g . addEdge ( a . getID ( ) + "-to -" + b . getID ( ) , a , b ) ; a . addEdge ( b ) ; // NOTE: t h i s l i n e b e l o w i s not needed ( c o m p r e s s e s f i l e omitted ) if

44

b . addEdge ( a ) ;

160

45 46 47 48 49

} }

System . out . p r i n t l n ( ( ( double ) i / ( double ) n complete . " ) ;

 1 0 0 . 0 ) + "%

50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67

} return g ; } private s t a t i c S t r i n g t i m e C o n v e r s i o n ( long t o t a l S e c o n d s ) {

f i n a l int MINUTES IN AN HOUR = 6 0 ; f i n a l int SECONDS IN A MINUTE = 6 0 ;

int s e c o n d s = ( int ) ( t o t a l S e c o n d s % SECONDS IN A MINUTE) ; int t o t a l M i n u t e s = ( int ) ( t o t a l S e c o n d s / SECONDS IN A MINUTE) ; int minutes = t o t a l M i n u t e s % MINUTES IN AN HOUR ; int h o u r s = t o t a l M i n u t e s / MINUTES IN AN HOUR ;

return h o u r s + " h o u r s " + minutes + " minutes " + s e c o n d s + " s e c o n d s " ; } // Given : n = number o f v e r t i c e s , r = r a d i u s o f i n f l u e n c e public UndirectedSparseGraph <Node , S t r i n g > generateGNRRandomGraph ( ) { UndirectedSparseGraph <Node , S t r i n g > g = new UndirectedSparseGraph <Node , S t r i n g > () ;

68 69 70 71 72 73

L i s t <Node> n o d e L i s t = new A r r a y L i s t <Node > () ; double r = p ;

double [ ] x C o o r d i n a t e s = g e n e r a t e N d o u b l e s ( n ) ; double [ ] y C o o r d i n a t e s = g e n e r a t e N d o u b l e s ( n ) ;

161

74 75 76 77 78 79 80 81 82 83 84 85 86 87

f o r ( int x = 0 ; x < n ; x++) { Node tmp = new Node ( x , x C o o r d i n a t e s [ x ] , y C o o r d i n a t e s [ x ] , r ) ; g . addVertex ( tmp ) ; n o d e L i s t . add ( tmp ) ; }

f o r ( int x = 0 ; x < n ; x++) { Node a = n o d e L i s t . g e t ( x ) ; f o r ( int y = x + 1 ; y < n ; y++) { Node b = n o d e L i s t . g e t ( y ) ; i f (a . inInfluence (b) ) { g . addEdge ( a . getID ( ) + "-to -" + b . getID ( ) , a , b ) ; a . addEdge ( b ) ; // NOTE: t h i s l i n e b e l o w i s not needed ( c o m p r e s s e s f i l e i f omitted )

88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103

b . addEdge ( a ) ; } } }

return g ; }

// Generate l i s t o f n number b e t w e e n 0 and 1 public s t a t i c double [ ] g e n e r a t e N d o u b l e s ( int n ) { double [ ] l i s t = new double [ n ] ;

DecimalFormat d f = new DecimalFormat ( "#.###" ) ; f o r ( int i = 0 ; i < n ; i ++) {

l i s t [ i ] = Double . p a r s e D o u b l e ( d f . format ( Math . random ( ) ) ) ; }

162

104 105 106 107

return l i s t ; }

}

163

B.2. SNAP Code (C++) graphgenerator.cpp
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23

#include " s t d a f x . h" #include < s t r i n g > #include < s t d i o . h> #include < i o s t r e a m > #include < f s t r e a m > #include <bd . h> #include <Windows . h> #include < a l g o r i t h m > #include <omp . h> #include < c s t d i o > #include <ctime > #include " m a t l a b F u n c t i o n s . h" #include < v e c t o r > #include < sstream > #include " l o a d F u n c t i o n s . h" #include " g r a p h F u n c t i o n s . h"

int t h r e a d s = 1 8 ; int d y n a m i c t h r e a d s = 1 8 ;

void getMGEOPTheoreticals ( long n , int m, double alpha , double beta , double p , TFltV& r e s u l t s ) {

24 25

r e s u l t s [ 0 ] = 1 + ( 1 / a l p h a ) ; // 0- power law r e s u l t s [ 1 ] = ( p / ( 1 - a l p h a ) )  TMath : : Power ( n , 1 - a l p h a - b e t a ) ; // 1- average degree

26

r e s u l t s [ 2 ] = TMath : : Power ( n , 1 / m) ; // 2- d i a m e t e r

164

27 28 29 30 31 32 33

r e s u l t s [ 3 ] = TMath : : Log (TMath : : Log ( n ) ) ; //3- a v e r a g e d i s t a n c e }

void estimatePowerLaw ( const PUNGraph &Graph ) { // x - d e g r e e s | y - number o f v e r t i c e s TVec<TIntPr > degreeCount ; f o r (PUNGraph : : TObj : : TNodeI NI = Graph->BegNI ( ) ; NI < Graph->EndNI ( ) ; NI++) {

34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56

bool e x i s t = f a l s e ; f o r ( int tmp = 0 ; tmp < degreeCount . Len ( ) ; tmp++) { i f ( degreeCount [ tmp ] . Val1 == NI . GetDeg ( ) ) { degreeCount [ tmp ] . Val2++; e x i s t = true ; } } if (! exist ) { degreeCount . Add( TIntPr ( NI . GetDeg ( ) , 1 ) ) ; } }

int n = degreeCount . Len ( ) ; double b max = 0 ; double s max = 0 ; double e max = n ; f o r ( double i n c r e = 0 ; i n c r e < 0 . 5 ; i n c r e = i n c r e + 0 . 0 0 1 ) { double sum = 0 . 0 ; double sum2 = 0 . 0 ; double sum3 = 0 . 0 ; double sum4 = 0 . 0 ;

165

57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87

double s = i n c r e  n ; double e = n ; f o r ( int tmp = int ( s ) ; tmp < int ( e ) ; tmp++) { int x = degreeCount [ tmp ] . Val1 ; int y = degreeCount [ tmp ] . Val2 ; sum += TMath : : Log ( x )  TMath : : Log ( y ) ; sum2 += TMath : : Log ( x ) ; sum3 += TMath : : Log ( y ) ; sum4 += TMath : : Log ( x )  TMath : : Log ( x ) ; } int n2 = int ( e ) - int ( s ) ; double b = ( ( n2  sum ) - ( sum2  sum3 ) ) / ( ( n2  sum4 ) -(sum2  sum2 ) ) ; i f ( b max > b ) { b max = b ; s max = s ; } }

f o r ( double i n c r e = 0 ; i n c r e < 0 . 5 ; i n c r e = i n c r e + 0 . 0 0 1 ) { double sum = 0 . 0 ; double sum2 = 0 . 0 ; double sum3 = 0 . 0 ; double sum4 = 0 . 0 ;

double s = s max ; double e = ( 1 - i n c r e )  n ; f o r ( int tmp = int ( s ) ; tmp < int ( e ) ; tmp++) { int x = degreeCount [ tmp ] . Val1 ; int y = degreeCount [ tmp ] . Val2 ; sum += TMath : : Log ( x )  TMath : : Log ( y ) ; sum2 += TMath : : Log ( x ) ;

166

88 89 90 91 92 93 94 95 96 97 98 99

sum3 += TMath : : Log ( y ) ; sum4 += TMath : : Log ( x )  TMath : : Log ( x ) ; } int n2 = int ( e ) - int ( s ) ; double b = ( ( n2  sum ) - ( sum2  sum3 ) ) / ( ( n2  sum4 ) - ( sum2  sum2 ) ) ; i f ( b max > b ) { b max = b ; e max = e ; } }

p r i n t f ( " Estimmated Power Law Exponennt ( L e a s t S q u a r e s F i t t i n g ) : %l f \ n" , b max ) ;

100

p r i n t f ( " In r a n g e : (%d , %d ) . . . ( % l f , %l f ) \ n" , int ( s max ) , int ( e max ) , s max , e max ) ;

101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116

}

double c a l A v e r a g e D i s t a n c e ( const PUNGraph& Graph , bool i s C o n n e c t e d ) { double a v g D i s t a n c e = 0 . 0 ; double sum = 0 . 0 ; i f ( ! i s C o n n e c t e d ) return a v g D i s t a n c e ; int n = Graph->GetNodes ( ) ; int c o u n t e r = 1 ; LARGE INTEGER s t a r t ; T i m e r S t a r t (& s t a r t ) ; omp set nested (1) ; omp set num threads (6) ; omp set dynamic ( 6 ) ; # pragma omp p a r a l l e l f o r s c h e d u l e ( dynamic ) s h a r e d ( sum ) f o r ( int x = 0 ; x < n ; x++) {

167

117 118 119 120 121 122 123 124 125 126

f o r ( int y = 0 ; y < n ; y++) { i f ( x <= y ) continue ; sum += TSnap : : GetShortPath ( Graph , x , y ) ; } Try { double n P e r c e n t a g e = ( double ) c o u n t e r / ( double ) n ; // Ranges from 0-1 double nElapsed = TimerQuery(& s t a r t ) ; // In s e c o n d s double nTotalTime = ( 1 . 0 / n P e r c e n t a g e )  nElapsed ; double nRemaining = nTotalTime - nElapsed ; p r i n t f ( " %2.1 f%% complete , Estimated %f s e c o n d s r e m a i n i n g \ r " , ( n P e r c e n t a g e  1 0 0 . 0 ) , nRemaining ) ;

127 128 129 130 131 132 133 134 135 136 137 138 139 140

counter = counter + 1; } Catch {} } p r i n t f ( " \ r \ n" ) ; double na = ( double ) Graph->GetNodes ( ) ; a v g D i s t a n c e = ( sum  2 . 0 ) / ( ( na  na ) - na ) ; return a v g D i s t a n c e ; }

int GetMnDegNId ( const PUNGraph& Graph ) { TIntV MnDegV ; int MnDeg = Graph->GetNodes ( ) ; f o r (PUNGraph : : TObj : : TNodeI NI = Graph->BegNI ( ) ; NI < Graph->EndNI ( ) ; NI++) {

141 142 143 144 145

i f (MnDeg > NI . GetDeg ( ) ) { MnDegV . C l r ( ) ; MnDeg = NI . GetDeg ( ) ; } i f (MnDeg == NI . GetDeg ( ) ) { MnDegV . Add( NI . GetId ( ) ) ; } } EAssertR ( ! MnDegV . Empty ( ) , " Input graph i s empty ! " ) ; return MnDeg ;

168

146 147 148 149 150 151

}

int GetMaxDegNId ( const PUNGraph& Graph ) { TIntV MaxDegV ; int MaxDeg = - 1; f o r (PUNGraph : : TObj : : TNodeI NI = Graph->BegNI ( ) ; NI < Graph->EndNI ( ) ; NI++) {

152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170

i f (MaxDeg < NI . GetDeg ( ) ) { MaxDegV . C l r ( ) ; MaxDeg = NI . GetDeg ( ) ; } i f (MaxDeg == NI . GetDeg ( ) ) { MaxDegV . Add( NI . GetId ( ) ) ; } } EAssertR ( ! MaxDegV . Empty ( ) , " Input graph i s empty ! " ) ; return MaxDeg ; }

void p r i n t G r a p h I n f o O b j ( const PUNGraph &Graph ) { p r i n t f ( " nodes :%d e d g e s :%d \ n" , Graph->GetNodes ( ) , Graph->GetEdges ( ) ) ;

TInt maxDegree = GetMaxDegNId ( Graph ) ; p r i n t f ( "Max Degree : %d \ n" , maxDegree ) ; TFlt avgDegree = 2 . 0  ( double ) Graph->GetEdges ( ) / ( double ) Graph->GetNodes ( ) ; p r i n t f ( "Avg Degree : %f \ n" , avgDegree ) ; TInt minDegree = GetMnDegNId ( Graph ) ; p r i n t f ( "Min Degree : %d \ n" , minDegree ) ;

TFlt d i a m e t e r = TSnap : : GetBfsFullDiam ( Graph , ( int ) ( Graph->GetNodes ( )  0 . 1 0 ) ) ; p r i n t f ( " Diameter : %f \ n" , d i a m e t e r ) ; TFlt e f f D i a m e t e r = TSnap : : GetBfsEffDiam ( Graph , ( int ) ( Graph->GetNodes ( )  0 . 1 0 ) );

171 172 173 174

p r i n t f ( " E f f . Diameter : %f \ n" , e f f D i a m e t e r ) ; std : : s t r i n g isConnected ; bool con ; i f ( minDegree == 0 ) {

169

175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205

i s C o n n e c t e d = " Yes . " ; con = f a l s e ; } else { i s C o n n e c t e d = "No . " ; con = true ; } p r i n t f ( " Does 0- d e g r e e e x i s t ? : %s \ n" , i s C o n n e c t e d . c s t r ( ) ) ; TFlt a v g D i s t a n c e = c a l A v e r a g e D i s t a n c e ( Graph , con ) ; p r i n t f ( " a v g D i s t a n c e : %f \ n" , a v g D i s t a n c e ) ; TFlt c l u s t i n g C f = TSnap : : GetClustCf ( Graph ) ; p r i n t f ( " C l u s t e r i n g C o e f f : %f \ n" , c l u s t i n g C f ) ; }

bool i s D o m i n a t i n g ( const TIntV DS , const PUNGraph &Graph ) { TIntSet s e t ; TIntV c o v e r e d ; int a = 0 ;

omp set nested (1) ; omp set num threads (20) ; omp set dynamic ( 2 0 ) ;

# pragma omp p a r a l l e l f o r s c h e d u l e ( dynamic ) s h a r e d ( a , DS , s e t ) f o r ( a = 0 ; a < DS . Len ( ) ; a++) { # pragma omp c r i t i c a l c o v e r e d . Add(DS [ a ] ) ;

TUNGraph : : TNodeI n b r s = Graph->GetNI (DS [ a ] ) ; f o r ( int temp = 0 ; temp < n b r s . GetOutDeg ( ) ; temp++) { # pragma omp c r i t i c a l

170

206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236

c o v e r e d . Add( n b r s . GetOutNId ( temp ) ) ; } }

s e t . AddKeyV( c o v e r e d ) ; i f ( s e t . Len ( ) == Graph->GetNodes ( ) ) { return true ; } else { return f a l s e ; } }

TIntV dominatingsetDC ( const PUNGraph &Graph ) { TIntV DS ; TIntPrV nodes ; LARGE INTEGER s t a r t ; T i m e r S t a r t (& s t a r t ) ; int c o u n t e r = 1 ;

p r i n t f ( "-- s t a r t i n g DC ---" ) ;

f o r (TUNGraph : : TNodeI NI = Graph->BegNI ( ) ; NI < Graph->EndNI ( ) ; NI++) { nodes . Add( TIntPr ( NI . GetOutDeg ( ) , NI . GetId ( ) ) ) ; DS . Add( NI . GetId ( ) ) ; }

p r i n t f ( " i n i t a l i z e d . \ n" ) ;

nodes . S o r t ( ) ; // l o w e s t t o h i g h e s t s o r t DS . S o r t ( ) ;

171

237 238 239 240 241 242 243 244 245

p r i n t f ( " r u n n i n g . . . \ n" ) ; f o r ( int c = 0 ; c < nodes . Len ( ) ; c++) { TIntV DSTemp = DS ; DSTemp . D e l I f I n ( nodes [ c ] . Val2 ) ; i f ( i s D o m i n a t i n g (DSTemp, Graph ) ) { DS = DSTemp ; } Try { double n P e r c e n t a g e = ( double ) c o u n t e r / ( double ) nodes . Len ( ) ; // Ranges from 0-1

246 247 248 249

double nElapsed = TimerQuery(& s t a r t ) ; // In s e c o n d s double nTotalTime = ( 1 . 0 / n P e r c e n t a g e )  nElapsed ; double nRemaining = nTotalTime - nElapsed ; p r i n t f ( " %2.1 f%% complete , Estimated %f s e c o n d s r e m a i n i n g \ r " , ( n P e r c e n t a g e  1 0 0 . 0 ) , nRemaining ) ;

250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265

counter = counter + 1; } Catch {} }

p r i n t f ( " \ nDS-DC S i z e : %d \ n" , DS . Len ( ) ) ; return DS ; }

TIntV dominatingsetRAI ( const PUNGraph &Graph ) { // RAI a l g o i r t h m TIntV c o v e r S e t , DS ; TIntPrV nodes ; TVec<TIntV> n e i g h b o u r s ; LARGE INTEGER s t a r t ;

172

266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292

T i m e r S t a r t (& s t a r t ) ; int c o u n t e r = 1 ;

f o r (TUNGraph : : TNodeI NI = Graph->BegNI ( ) ; NI < Graph->EndNI ( ) ; NI++) { nodes . Add( TIntPr ( NI . GetOutDeg ( ) , NI . GetId ( ) ) ) ; TIntV nodeNbrs ; f o r ( int deg = 0 ; deg < NI . GetOutDeg ( ) ; deg++) { nodeNbrs . Add( NI . GetNbrNId ( deg ) ) ; } n e i g h b o u r s . Add( nodeNbrs ) ; } nodes . S o r t ( f a l s e ) ; // h i g h e s t t o l o w e s t s o r t e d 1

f o r ( int c = 0 ; c < nodes . Len ( ) ; c++) { i f ( c o v e r S e t . Count ( nodes [ c ] . Val2 ) == 0 ) {

c o v e r S e t . Add( nodes [ c ] . Val2 ) ; DS . Add( nodes [ c ] . Val2 ) ;

TUNGraph : : TNodeI n b r s = Graph->GetNI ( nodes [ c ] . Val2 ) ; f o r ( int temp = 0 ; temp < n b r s . GetOutDeg ( ) ; temp++) { c o v e r S e t . AddUnique ( n b r s . GetOutNId ( temp ) ) ; } }

Try { double n P e r c e n t a g e = ( double ) c o u n t e r / ( double ) nodes . Len ( ) ; // Ranges from 0-1

293 294 295

double nElapsed = TimerQuery(& s t a r t ) ; // In s e c o n d s double nTotalTime = ( 1 . 0 / n P e r c e n t a g e )  nElapsed ; double nRemaining = nTotalTime - nElapsed ;

173

296

p r i n t f ( " %2.1 f%% complete , Estimated %f s e c o n d s r e m a i n i n g \ r " , ( n P e r c e n t a g e  1 0 0 . 0 ) , nRemaining ) ;

297 298 299 300 301

counter = counter + 1; } Catch {} } p r i n t f ( " \ n%d,%d = DS-RAI S i z e : %d \ n" , Graph->GetNodes ( ) , Graph->GetEdges ( ) , DS . Len ( ) ) ;

302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324

return DS ; }

void p r i n t S t a t s M e n u ( ) { p r i n t f ( "Graph S t a t i s t i c s ( B a s i c ) \ n" ) ; p r i n t f ( " \ t 1 -- Min/Avg/Max D e g r e e s \ n" ) ; p r i n t f ( " \ t 2 -- LogLog P l o t with B e s t f i t \ n" ) ; p r i n t f ( " \ t 3 -- \ n" ) ; p r i n t f ( " \ t 4 -- \ n" ) ; p r i n t f ( " \ t 5 -- \ n" ) ; }

void printMenu ( ) { TVec<TStr> o p t i o n s ; o p t i o n s . Add( "gnp o p t i o n s . Add( "mgeop - Generate G( n , p ) Graph Sample " ) ; - Generate MGEOP( n ,m, a , b , p ) Graph Sample " ) ;

o p t i o n s . Add( "dmgeop - Generate D i s t a n c e - MGEOP( n ,m, a , b , p ) Graph Sample " ) ; o p t i o n s . Add( " f b o p t i o n s . Add( "q - Facebook 100 " ) ; - Quit " ) ;

p r i n t f ( "---------------------------------\n" ) ; f o r ( int c o u n t e r = 0 ; c o u n t e r < o p t i o n s . Len ( ) ; c o u n t e r++) { p r i n t f ( " |% s \ n" , o p t i o n s [ c o u n t e r ] . CStr ( ) ) ; }

174

325 326 327 328 329 330 331 332

p r i n t f ( "---------------------------------\n" ) ; p r i n t f ( "> " ) ; }

int main ( int argc , char  argv [ ] ) { PUNGraph GraphPt ; Env = TEnv( argc , argv , TNotify : : S t d N o t i f y ) ; p r i n t f ( "Graph Ge n e r a t o r By Marc L o z i e r \ n b u i l d : %s , %s . Time : %s \ n" , , DATE , TExeTm : : GetCurTm ( ) ) ; TIME

333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354

TExeTm ExeTm ; time64 t long time ; t i m e 6 4 (& l o n g t i m e ) ; Try {

i f ( Env . IsEndOfRun ( ) ) { return 0 ; } TInt : : Rnd . PutSeed (ExeTm . G e t S e c I n t ( ) ) ; // i n i t i a l i z e random s e e d TFlt : : Rnd . PutSeed (ExeTm . G e t S e c I n t ( ) ) ;

s t d : : s t r i n g menu option ; char i n p u t [ 2 5 6 ] ; omp set nested (1) ; omp set num threads ( threads ) ; omp set dynamic ( d y n a m i c t h r e a d s ) ;

p r i n t f ( " S t a r t i n g MATLAB Engine . . . " ) ; startMatlab () ; p r i n t f ( " [OK] \ n" ) ; printMenu ( ) ;

while ( menu option != "q" ) {

175

355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385

s t d : : g e t l i n e ( s t d : : c i n , menu option ) ;

i f ( menu option == "gnp" ) { p r i n t f ( " 0 - Generate sample ( n , p ) \ n" ) ; p r i n t f ( " 1 - G e n e r a l Chart [ + ] \ n" ) ; p r i n t f ( " 2 - Dominating S e t \ n" ) ; p r i n t f ( " \n > " ) ;

s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; int input num = a t o i ( i n p u t ) ;

TStr f i l e n a m e ; long n gnp ; double p gnp ; switch ( input num ) { case 0 : p r i n t f ( "n = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; n gnp = a t o i ( i n p u t ) ; p r i n t f ( "p = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; p gnp = a t o f ( i n p u t ) ;

f i l e n a m e = TStr : : Fmt( " gnp %l d %4.2 f . b i n " , n gnp , p gnp ) ; GraphPt = generateGNP ( n gnp , p gnp , f i l e n a m e ) ; break ; case 1 : break ; case 2 : break ; }

176

386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411

} e l s e i f ( menu option == " 8 " | | menu option == "mgeop" ) { p r i n t f ( " 1 - Generate from FB100 p a r a m e t e r s \ n" ) ; p r i n t f ( " 2 - G e n e r a l Chart [ + ] \ n" ) ; p r i n t f ( " 3 - Dominating S e t (DS-RAI) " ) ; p r i n t f ( " \n > " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ;

int input num = a t o i ( i n p u t ) ;

p r i n t f ( "FB s e t (0 - 99) = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; s t d : : v e c t o r <s t d : : s t r i n g > r a n g e = s p l i t ( input , '- ' ) ; int s t a r t = a t o i ( r a n g e [ 0 ] . c s t r ( ) ) ; int end = a t o i ( r a n g e [ 1 ] . c s t r ( ) ) ; printf (" Iterations = ") ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; int i t e r a t i o n s = a t o i ( i n p u t ) ;

s t d : : i f s t r e a m f i l e ( " mgeop parameters . c s v " ) ; std : : s t r i n g l i n e i n p u t ;

i f ( input num == 1 ) { i f ( ! f i l e . good ( ) ) { p r i n t f ( " E r r o r o p e n i n g FB100 parameter f i l e ( mgeop parameters . c s v ) \ n. ") ;

412 413 414 415

} else { g e t l i n e ( f i l e , l i n e i n p u t ) ; // read h e a d e r o f columns f o r ( int i = 0 ; i < 1 0 0 ; i ++) {

177

416 417 418 419 420 421 422 423 424 425 426 427

getline ( file , line input ) ; i f ( i < s t a r t ) continue ; i f ( i > end ) continue ; s t d : : v e c t o r <s t d : : s t r i n g > data = s p l i t ( l i n e i n p u t , ' , ' ) ;

long n mgeop = a t o l ( data [ 1 ] . c s t r ( ) ) ; long e mgeop = a t o l ( data [ 2 ] . c s t r ( ) ) ; int m mgeop = a t o i ( data [ 5 ] . c s t r ( ) ) ; double a mgeop = a t o f ( data [ 3 ] . c s t r ( ) ) ; double b mgeop = a t o f ( data [ 4 ] . c s t r ( ) ) ; double p mgeop = 1 . 0 0 ; f o r ( int c u r r e n t i t e r a t i o n = 0 ; c u r r e n t i t e r a t i o n < i t e r a t i o n s ; c u r r e n t i t e r a t i o n ++) {

428 429 430

TStr f i l e n a m e ; f i l e n a m e = TStr : : Fmt( " mgeop %s . b i n " , data [ 0 ] . c s t r ( ) ) ; GraphPt = generateMGEOP ( n mgeop , m mgeop , a mgeop , b mgeop , p mgeop , f i l e n a m e ) ;

431 432 433 434 435 436 437 438 439 440

// d e f a u l t : c l u s t e r c o e f f i c i e n t , d i s t a n c e , diameter , power law } } } f i l e . close () ; } e l s e i f ( input num == 2 ) { std : : ofstream f i l e o u t ( " mgeop p results . txt " ) ; i f ( ! f i l e . good ( ) ) { p r i n t f ( " E r r o r o p e n i n g FB100 parameter f i l e ( mgeop parameters . c s v ) \ n. ") ;

441 442 443

} else { g e t l i n e ( f i l e , l i n e i n p u t ) ; // read h e a d e r o f columns

178

444 445 446 447 448 449

f o r ( int i = 0 ; i < 1 0 0 ; i ++) { getline ( file , line input ) ; i f ( i < s t a r t ) continue ; i f ( i > end ) continue ; s t d : : v e c t o r <s t d : : s t r i n g > data = s p l i t ( l i n e i n p u t , ' , ' ) ; TStr f i l e n a m e = TStr : : Fmt( " mgeop %s p 0 c o m p r e s s e d . smat " , data [ 0 ] . c str () ) ;

450 451 452 453 454 455 456

GraphPt = l o a d F i l e ( f i l e n a m e ) ;

TFlt e = ( double ) GraphPt->GetEdges ( ) ; TFlt v = ( double ) GraphPt->GetNodes ( ) ; TInt maxDegree = GetMaxDegNId ( GraphPt ) ; int avgDegree = ( int ) ( ( 2 . 0  ( double ) GraphPt->GetEdges ( ) / ( double ) GraphPt->GetNodes ( ) ) + 0 . 5 ) ;

457 458 459

TInt minDegree = GetMnDegNId ( GraphPt ) ; TFlt d e n s i t y = ( 2  e ) / ( v  ( v - 1 ) ) ; TStr output = TStr : : Fmt( "%s \ t%d \ t%d \ t%d \ t%d \ t%d \ t %.3 f \ n" , data [ 0 ] . c s t r ( ) , GraphPt->GetNodes ( ) , GraphPt->GetEdges ( ) , minDegree , avgDegree , maxDegree , d e n s i t y ) ;

460 461 462 463 464 465 466 467 468 469 470

f i l e o u t << output . CStr ( ) ; } } fileout . close () ; } e l s e i f ( input num == 3 ) { std : : ofstream f i l e o u t d s r a i 0 ( "0 r a i m g e o p d o m i n t a i n g r e s u l t s . txt " ) ; std : : ofstream f i l e o u t d s r a i 1 ( "1 r a i m g e o p d o m i n t a i n g r e s u l t s . txt " ) ; std : : ofstream f i l e o u t d s r a i 2 ( "2 r a i m g e o p d o m i n t a i n g r e s u l t s . txt " ) ; std : : ofstream f i l e o u t d s r a i 3 ( "3 r a i m g e o p d o m i n t a i n g r e s u l t s . txt " ) ; std : : ofstream f i l e o u t d s r a i 4 ( "4 r a i m g e o p d o m i n t a i n g r e s u l t s . txt " ) ;

179

471 472 473 474

std : : ofstream f i l e o u t d s r a i 5 ( "5 r a i m g e o p d o m i n t a i n g r e s u l t s . txt " ) ;

i f ( ! f i l e . good ( ) ) { p r i n t f ( " E r r o r o p e n i n g FB100 parameter f i l e ( mgeop parameters . c s v ) \ n. ") ;

475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499

} else { TStrV d a t a s e t s ; g e t l i n e ( f i l e , l i n e i n p u t ) ; // read h e a d e r o f columns f o r ( int i = 0 ; i < 1 0 0 ; i ++) { getline ( file , line input ) ; i f ( i < s t a r t ) continue ; i f ( i > end ) continue ; s t d : : v e c t o r <s t d : : s t r i n g > data = s p l i t ( l i n e i n p u t , ' , ' ) ; TStr f i l e n a m e = TStr : : Fmt( " mgeop %s . b i n " , data [ 0 ] . c s t r ( ) ) ; d a t a s e t s . Add( f i l e n a m e ) ; }

f o r ( int z = 0 ; z < d a t a s e t s . Len ( ) ; z++) { TStr f i l e n a m e = d a t a s e t s [ z ] ; GraphPt = l o a d F i l e ( f i l e n a m e ) ; f o r ( int k = 0 ; k <= 5 ; k++) TIntV d e l ; TIntPrV e d g e s d e l ; PUNGraph grp ; grp . New ( ) ; {

grp = TSnap : : GetKCore ( GraphPt , k ) ; while ( GetMnDegNId ( grp ) < k ) {

180

500

f o r (TUNGraph : : TNodeI NI = grp ->BegNI ( ) ; NI < grp ->EndNI ( ) ; NI++) {

501 502 503

i f ( NI . GetOutDeg ( ) < k ) { d e l . Add( NI . GetId ( ) ) ; f o r (TUNGraph : : TNodeI NIA = grp ->BegNI ( ) ; NIA < grp -> EndNI ( ) ; NIA++) {

504 505 506

f o r ( int u = 0 ; u < NIA . GetDeg ( ) ; u++) { i f (NIA . GetNbrNId ( u ) == NI . GetId ( ) ) { e d g e s d e l . Add( TIntPr (NIA . GetNbrNId ( u ) , NI . GetId ( ) ) );

507 508 509 510 511 512 513 514 515 516 517

} } } } }

f o r ( int d e l l e n = 0 ; d e l l e n < d e l . Len ( ) ; d e l l e n ++) { grp ->DelNode ( d e l [ d e l l e n ] ) ; } f o r ( int d e l l e n = 0 ; d e l l e n < d e l . Len ( ) ; d e l l e n ++) { grp ->DelEdge ( e d g e s d e l [ d e l l e n ] . Val1 , e d g e s d e l [ d e l l e n ] . Val2 ) ;

518 519 520 521 522 523 524 525

} }

grp ->Def rag ( ) ; GraphPt = grp ; p r i n t f ( "%d,%d \ n" , grp ->GetNodes ( ) , grp ->GetEdges ( ) ) ; TIntV d s r a i k = dominatingsetRAI ( grp ) ; TStr c o r e = TStr : : Fmt( "%d&%d \\\\ \\ h l i n e \ n" , grp ->GetNodes ( ) , d s r a i k . Len ( ) ) ;

181

526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548

switch ( k ) { case 0 : f i l e o u t d s r a i 0 << c o r e . CStr ( ) ; break ; case 1 : f i l e o u t d s r a i 1 << c o r e . CStr ( ) ; break ; case 2 : f i l e o u t d s r a i 2 << c o r e . CStr ( ) ; break ; case 3 : f i l e o u t d s r a i 3 << c o r e . CStr ( ) ; break ; case 4 : f i l e o u t d s r a i 4 << c o r e . CStr ( ) ; break ; case 5 : f i l e o u t d s r a i 5 << c o r e . CStr ( ) ; break ; } } } fileout ds rai0 . close () ; fileout ds rai1 . close () ; fileout ds rai2 . close () ; fileout ds rai3 . close () ; fileout ds rai4 . close () ; fileout ds rai5 . close () ;

549 550 551 552 553 554

} f i l e . close () ; } } e l s e i f ( menu option == " 9 " | | menu option == "dmgeop" ) { p r i n t f ( " 0 - Generate sample \ n" ) ;

182

555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582

p r i n t f ( " 1 - Generate from FB100 p a r a m e t e r s \ n" ) ; p r i n t f ( " 2 - G e n e r a l Chart [ + ] \ n" ) ; p r i n t f ( " 3 - Dominating S e t (RAI) \ n" ) ; p r i n t f ( " 4 - Power Law Graphs \ n >" ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ;

int input num = a t o i ( i n p u t ) ;

std : : s t r i n g l i n e i n p u t ;

i f ( input num == 0 ) { p r i n t f ( "n = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; int n temp = a t o i ( i n p u t ) ; p r i n t f ( "m = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; int m temp = a t o i ( i n p u t ) ; p r i n t f ( "a = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; double a temp = a t o f ( i n p u t ) ; p r i n t f ( "b = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; double b temp = a t o f ( i n p u t ) ; printf (" Iterations = ") ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; int i t e r a t i o n s = a t o i ( i n p u t ) ; TStr f i l e n a m e = TStr : : Fmt( " dmgeop %d %d . b i n " , n temp , m temp ) ; GraphPt = generateMGEOPDistance ( n temp , m temp , a temp , b temp , filename ) ;

583 584

} e l s e i f ( input num == 1 ) {

183

585 586 587 588 589 590 591 592 593 594 595 596 597 598 599

s t d : : i f s t r e a m f i l e ( " mgeop parameters . c s v " ) ;

p r i n t f ( "FB s e t (0 - 99) = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; s t d : : v e c t o r <s t d : : s t r i n g > r a n g e = s p l i t ( input , '- ' ) ; int s t a r t = a t o i ( r a n g e [ 0 ] . c s t r ( ) ) ; int end = a t o i ( r a n g e [ 1 ] . c s t r ( ) ) ;

printf (" Iterations = ") ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; int i t e r a t i o n s = a t o i ( i n p u t ) ;

i f ( ! f i l e . good ( ) ) { p r i n t f ( " E r r o r o p e n i n g FB100 parameter f i l e ( mgeop parameters . c s v ) \ n. ") ;

600 601 602 603 604 605 606 607 608 609 610 611 612 613 614

} else { g e t l i n e ( f i l e , l i n e i n p u t ) ; // read h e a d e r o f columns f o r ( int i = 0 ; i < 1 0 0 ; i ++) { getline ( file , line input ) ; i f ( i < s t a r t ) continue ; i f ( i > end ) continue ; s t d : : v e c t o r <s t d : : s t r i n g > data = s p l i t ( l i n e i n p u t , ' , ' ) ;

long n mgeop = a t o l ( data [ 1 ] . c s t r ( ) ) ; long e mgeop = a t o l ( data [ 2 ] . c s t r ( ) ) ; int m mgeop = a t o i ( data [ 5 ] . c s t r ( ) ) ; double a mgeop = a t o f ( data [ 3 ] . c s t r ( ) ) ; double b mgeop = a t o f ( data [ 4 ] . c s t r ( ) ) ; double p mgeop = 1 . 0 0 ;

184

615 616

f o r ( int c u r r e n t i t e r a t i o n = 0 ; c u r r e n t i t e r a t i o n < i t e r a t i o n s ; c u r r e n t i t e r a t i o n ++) {

617 618

TStr f i l e n a m e ; f i l e n a m e = TStr : : Fmt( " dmgeop %s %d . b i n " , data [ 0 ] . c s t r ( ) , current iteration ) ;

619

GraphPt = generateMGEOPDistance ( n mgeop , m mgeop , a mgeop , b mgeop , f i l e n a m e ) ;

620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635

} } } f i l e . close () ; } e l s e i f ( input num == 2 ) { p r i n t f ( "FB s e t (0 - 99) = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; s t d : : v e c t o r <s t d : : s t r i n g > r a n g e = s p l i t ( input , '- ' ) ; int s t a r t = a t o i ( r a n g e [ 0 ] . c s t r ( ) ) ; int end = a t o i ( r a n g e [ 1 ] . c s t r ( ) ) ;

s t d : : i f s t r e a m f i l e ( " mgeop parameters . c s v " ) ; std : : ofstream f i l e o u t ( " r e s u l t s . txt " ) ; i f ( ! f i l e . good ( ) ) { p r i n t f ( " E r r o r o p e n i n g FB100 parameter f i l e ( mgeop parameters . c s v ) \ n. ") ;

636 637 638 639 640 641

} else { g e t l i n e ( f i l e , l i n e i n p u t ) ; // read h e a d e r o f columns f o r ( int i = 0 ; i < 1 0 0 ; i ++) { getline ( file , line input ) ; i f ( i < s t a r t ) continue ;

185

642 643 644 645 646 647 648 649 650

i f ( i > end ) continue ; s t d : : v e c t o r <s t d : : s t r i n g > data = s p l i t ( l i n e i n p u t , ' , ' ) ; TStr f i l e n a m e = TStr : : Fmt( " dmgeop %s 0 . b i n " , data [ 0 ] . c s t r ( ) ) ; GraphPt = l o a d F i l e ( f i l e n a m e ) ;

TFlt e = ( double ) GraphPt->GetEdges ( ) ; TFlt v = ( double ) GraphPt->GetNodes ( ) ; TInt maxDegree = GetMaxDegNId ( GraphPt ) ; int avgDegree = ( int ) ( ( 2 . 0  ( double ) GraphPt->GetEdges ( ) / ( double ) GraphPt->GetNodes ( ) ) + 0 . 5 ) ;

651 652 653

TInt minDegree = GetMnDegNId ( GraphPt ) ; TFlt d e n s i t y = ( 2  e ) / ( v  ( v - 1 ) ) ; TStr output = TStr : : Fmt( "%s \ t%d \ t%d \ t%d \ t%d \ t%d \ t %.3 f \ n" , data [ 0 ] . c s t r ( ) , GraphPt->GetNodes ( ) , GraphPt->GetEdges ( ) , minDegree , avgDegree , maxDegree , d e n s i t y ) ;

654 655 656 657 658 659 660 661 662 663 664 665 666 667

f i l e o u t << output . CStr ( ) ; } } fileout . close () ; } e l s e i f ( input num == 3 ) { // Dominating S e t std : : ofstream f i l e o u t d s d c 0 ( "0 dc dmgeop domintaing results . txt " ) ; std : : ofstream f i l e o u t d s d c 1 ( "1 dc dmgeop domintaing results . txt " ) ; std : : ofstream f i l e o u t d s d c 2 ( "2 dc dmgeop domintaing results . txt " ) ; std : : ofstream f i l e o u t d s d c 3 ( "3 dc dmgeop domintaing results . txt " ) ; std : : ofstream f i l e o u t d s d c 4 ( "4 dc dmgeop domintaing results . txt " ) ; std : : ofstream f i l e o u t d s d c 5 ( "5 dc dmgeop domintaing results . txt " ) ; std : : ofstream f i l e o u t d s r a i 0 ( "0 r a i d m g e o p d o m i n t a i n g r e s u l t s . txt " ) ;

186

668

std : : ofstream f i l e o u t d s r a i 1 ( "1 r a i d m g e o p d o m i n t a i n g r e s u l t s . txt " ) ;

669

std : : ofstream f i l e o u t d s r a i 2 ( "2 r a i d m g e o p d o m i n t a i n g r e s u l t s . txt " ) ;

670

std : : ofstream f i l e o u t d s r a i 3 ( "3 r a i d m g e o p d o m i n t a i n g r e s u l t s . txt " ) ;

671

std : : ofstream f i l e o u t d s r a i 4 ( "4 r a i d m g e o p d o m i n t a i n g r e s u l t s . txt " ) ;

672

std : : ofstream f i l e o u t d s r a i 5 ( "5 r a i d m g e o p d o m i n t a i n g r e s u l t s . txt " ) ;

673 674 675 676 677 678 679 680 681 682

p r i n t f ( "FB s e t (0 - 99) = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; s t d : : v e c t o r <s t d : : s t r i n g > r a n g e = s p l i t ( input , '- ' ) ; int s t a r t = a t o i ( r a n g e [ 0 ] . c s t r ( ) ) ; int end = a t o i ( r a n g e [ 1 ] . c s t r ( ) ) ;

s t d : : i f s t r e a m f i l e ( " mgeop parameters . c s v " ) ;

i f ( ! f i l e . good ( ) ) { p r i n t f ( " E r r o r o p e n i n g FB100 parameter f i l e ( mgeop parameters . c s v ) \ n. ") ;

683 684 685 686 687 688 689 690 691 692

} else { TStrV d a t a s e t s ; g e t l i n e ( f i l e , l i n e i n p u t ) ; // read h e a d e r o f columns f o r ( int i = 0 ; i < 1 0 0 ; i ++) { getline ( file , line input ) ; i f ( i < s t a r t ) continue ; i f ( i > end ) continue ; s t d : : v e c t o r <s t d : : s t r i n g > data = s p l i t ( l i n e i n p u t , ' , ' ) ; TStr f i l e n a m e = TStr : : Fmt( " dmgeop %s 0 . b i n " , data [ 0 ] . c s t r ( ) ) ;

187

693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708

d a t a s e t s . Add( f i l e n a m e ) ; }

f o r ( int z = 0 ; z < d a t a s e t s . Len ( ) ; z++) { TStr f i l e n a m e = d a t a s e t s [ z ] ; GraphPt = l o a d F i l e ( f i l e n a m e ) ; f o r ( int k = 0 ; k <= 5 ; k++) TIntV d e l ; TIntPrV e d g e s d e l ; PUNGraph grp ; grp . New ( ) ; {

grp = TSnap : : GetKCore ( GraphPt , k ) ; while ( GetMnDegNId ( grp ) < k ) {

f o r (TUNGraph : : TNodeI NI = grp ->BegNI ( ) ; NI < grp ->EndNI ( ) ; NI++) {

709 710 711

i f ( NI . GetOutDeg ( ) < k ) { d e l . Add( NI . GetId ( ) ) ; f o r (TUNGraph : : TNodeI NIA = grp ->BegNI ( ) ; NIA < grp -> EndNI ( ) ; NIA++) {

712 713 714

f o r ( int u = 0 ; u < NIA . GetDeg ( ) ; u++) { i f (NIA . GetNbrNId ( u ) == NI . GetId ( ) ) { e d g e s d e l . Add( TIntPr (NIA . GetNbrNId ( u ) , NI . GetId ( ) ) );

715 716 717 718 719 720

} } } } }

188

721 722 723 724 725

f o r ( int d e l l e n = 0 ; d e l l e n < d e l . Len ( ) ; d e l l e n ++) { grp ->DelNode ( d e l [ d e l l e n ] ) ; } f o r ( int d e l l e n = 0 ; d e l l e n < d e l . Len ( ) ; d e l l e n ++) { grp ->DelEdge ( e d g e s d e l [ d e l l e n ] . Val1 , e d g e s d e l [ d e l l e n ] . Val2 ) ;

726 727 728 729 730 731 732 733 734 735 736

} }

grp ->Def rag ( ) ; GraphPt = grp ; p r i n t f ( "%d,%d \ n" , grp ->GetNodes ( ) , grp ->GetEdges ( ) ) ; // TStr c o r e ;

i f ( input num == 3 ) { TIntV d s r a i k = dominatingsetRAI ( grp ) ; TStr c o r e = TStr : : Fmt( "%d&%d \\\\ \\ h l i n e \ n" , grp ->GetNodes ( ) , d s r a i k . Len ( ) ) ;

737 738 739 740 741 742 743 744 745 746 747 748 749

switch ( k ) { case 0 : f i l e o u t d s r a i 0 << c o r e . CStr ( ) ; break ; case 1 : f i l e o u t d s r a i 1 << c o r e . CStr ( ) ; break ; case 2 : f i l e o u t d s r a i 2 << c o r e . CStr ( ) ; break ; case 3 : f i l e o u t d s r a i 3 << c o r e . CStr ( ) ; break ;

189

750 751 752 753 754 755 756 757 758 759 760

case 4 : f i l e o u t d s r a i 4 << c o r e . CStr ( ) ; break ; case 5 : f i l e o u t d s r a i 5 << c o r e . CStr ( ) ; break ; } } e l s e i f ( input num == 4 ) { TIntV d s d c k = dominatingsetDC ( grp ) ; TStr c o r e = TStr : : Fmt( "%d&%d \\\\ \\ h l i n e \ n" , grp ->GetNodes ( ) , d s d c k . Len ( ) ) ;

761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779

switch ( k ) { case 0 : f i l e o u t d s d c 0 << c o r e . CStr ( ) ; break ; case 1 : f i l e o u t d s d c 1 << c o r e . CStr ( ) ; break ; case 2 : f i l e o u t d s d c 2 << c o r e . CStr ( ) ; break ; case 3 : f i l e o u t d s d c 3 << c o r e . CStr ( ) ; break ; case 4 : f i l e o u t d s d c 4 << c o r e . CStr ( ) ; break ; case 5 : f i l e o u t d s d c 5 << c o r e . CStr ( ) ; break ;

190

780 781 782 783 784 785 786 787

} }

} } } fileout ds rai0 . close () ; fileout ds rai1 . close () ; fileout ds rai2 . close () ; fileout ds rai3 . close () ; fileout ds rai4 . close () ; fileout ds rai5 . close () ;

788

fileout ds dc0 . close () ; fileout ds dc1 . close () ; fileout ds dc2 . close () ; fileout ds dc3 . close () ; fileout ds dc4 . close () ; fileout ds dc5 . close () ;

789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806

} e l s e i f ( input num == 4 ) { // power Law p r i n t f ( " 0 - Facebook d a t a s e t e q u i v a l e n t \ n" ) ; p r i n t f ( " 1 - Filename \ n" ) ; p r i n t f ( "> " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; int input num = a t o i ( i n p u t ) ;

switch ( input num ) { case 0 : break ; case 1 : p r i n t f ( " Filename = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; GraphPt = l o a d F i l e ( TStr ( i n p u t ) ) ; g e t H i s t o g r a m ( GraphPt ) ; break ;

191

807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837

} } } e l s e i f ( menu option == " 10 " | | menu option == " s t a t s " ) { printStatsMenu ( ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; i f ( a t o i ( i n p u t ) == 2 ) { g e t L o g L o g P l o t B e s t f i t ( GraphPt ) ; } } e l s e i f ( menu option == " 11 " | | menu option == " r a i " ) {

} e l s e i f ( menu option == " 12 " | | menu option == " dc " ) {

} e l s e i f ( menu option == " 13 " | | menu option == " f b " ) { p r i n t f ( " 1 - Generate from p a r a m e t e r s \ n" ) ; p r i n t f ( " 2 - G e n e r e t e from f i l e \ n" ) ; p r i n t f ( " 3 - Dominating S e t (RAI) \ n" ) ; p r i n t f ( " 4 - Dominating S e t (DC) \ n" ) ; p r i n t f ( " 5 - Dominating S e t (RAI & DC) \ n" ) ; p r i n t f ( "> " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ;

i f ( a t o i ( i n p u t ) == 1 ) { p r i n t f ( "FB s e t (0 - 99) = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; s t d : : v e c t o r <s t d : : s t r i n g > r a n g e = s p l i t ( input , '- ' ) ; int s t a r t = a t o i ( r a n g e [ 0 ] . c s t r ( ) ) ; int end = a t o i ( r a n g e [ 1 ] . c s t r ( ) ) ;

192

838 839 840 841 842 843 844 845 846 847 848

p r i n t f ( "number o f i t e r a t i o n s = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; int i t e r a t i o n s = a t o i ( i n p u t ) ;

p r i n t f ( "1-p=1\ n2-v a r y i n g p \ n> " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; int p t y p e = a t o i ( i n p u t ) ; s t d : : i f s t r e a m f i l e ( " mgeop parameters . c s v " ) ; std : : s t r i n g l i n e i n p u t ; i f ( ! f i l e . good ( ) ) { p r i n t f ( " E r r o r o p e n i n g FB100 parameter f i l e ( mgeop parameters . c s v ) \ n. ") ;

849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865

} else { g e t l i n e ( f i l e , l i n e i n p u t ) ; // read h e a d e r o f columns f o r ( int i = 0 ; i < 1 0 0 ; i ++) { getline ( file , line input ) ; i f ( i < s t a r t ) continue ; i f ( i > end ) continue ; s t d : : v e c t o r <s t d : : s t r i n g > data = s p l i t ( l i n e i n p u t , ' , ' ) ;

long n mgeop = a t o l ( data [ 1 ] . c s t r ( ) ) ; long e mgeop = a t o l ( data [ 2 ] . c s t r ( ) ) ; int m mgeop = a t o i ( data [ 5 ] . c s t r ( ) ) ; double a mgeop = a t o f ( data [ 3 ] . c s t r ( ) ) ; double b mgeop = a t o f ( data [ 4 ] . c s t r ( ) ) ; double p mgeop = 1 . 0 0 ; i f ( p t y p e == 2 ) { p mgeop = ( ( ( 2 . 0  e mgeop ) / n mgeop )  ( 1 . 0 - a mgeop )  TMath : : Power ( n mgeop , a mgeop + b mgeop ) ) / n mgeop ;

866

}

193

867

f o r ( int c u r r e n t i t e r a t i o n = 0 ; c u r r e n t i t e r a t i o n < i t e r a t i o n s ; c u r r e n t i t e r a t i o n ++) {

868 869 870 871

TStr f i l e n a m e ;

i f ( p t y p e == 2 ) { f i l e n a m e = TStr : : Fmt( " p %s %d . b i n " , data [ 0 ] . c s t r ( ) , current iteration ) ;

872 873 874

} else { f i l e n a m e = TStr : : Fmt( "%s %d . b i n " , data [ 0 ] . c s t r ( ) , current iteration ) ;

875 876 877

}

GraphPt = generateMGEOP ( n mgeop , m mgeop , a mgeop , b mgeop , p mgeop , f i l e n a m e ) ;

878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893

} } } f i l e . close () ;

} e l s e i f ( a t o i ( i n p u t ) == 2 ) { p r i n t f ( "FB s e t (0 - 99) = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; s t d : : v e c t o r <s t d : : s t r i n g > r a n g e = s p l i t ( input , '- ' ) ; int s t a r t = a t o i ( r a n g e [ 0 ] . c s t r ( ) ) ; int end = a t o i ( r a n g e [ 1 ] . c s t r ( ) ) ; s t d : : i f s t r e a m f i l e ( " mgeop parameters . c s v " ) ; std : : s t r i n g l i n e i n p u t ;

std : : ofstream f i l e o u t ( " r e s u l t s . txt " ) ;

194

894 895 896

i f ( ! f i l e . good ( ) ) { p r i n t f ( " E r r o r o p e n i n g FB100 parameter f i l e ( mgeop parameters . c s v ) \ n. ") ;

897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912

} else { p r i n t f ( " D a t a s e t Name\ tNodes \ tEdges \ Min \ Avg \Max\ D e n s i t y \ n" ) ; g e t l i n e ( f i l e , l i n e i n p u t ) ; // read h e a d e r o f columns f o r ( int i = 0 ; i < 1 0 0 ; i ++) { getline ( file , line input ) ; i f ( i < s t a r t ) continue ; i f ( i > end ) continue ; s t d : : v e c t o r <s t d : : s t r i n g > data = s p l i t ( l i n e i n p u t , ' , ' ) ; TStr f i l e n a m e = TStr : : Fmt( "%s . smat " , data [ 0 ] . c s t r ( ) ) ; GraphPt = l o a d F i l e ( f i l e n a m e ) ;

TFlt e = ( double ) GraphPt->GetEdges ( ) ; TFlt v = ( double ) GraphPt->GetNodes ( ) ; TInt maxDegree = GetMaxDegNId ( GraphPt ) ; TFlt avgDegree = 2 . 0  ( double ) GraphPt->GetEdges ( ) / ( double ) GraphPt->GetNodes ( ) ;

913 914 915

TInt minDegree = GetMnDegNId ( GraphPt ) ; TFlt d e n s i t y = ( 2  e ) / ( v  ( v - 1 ) ) ; TStr output = TStr : : Fmt( "%s \ t%d \ t%d \ t%d \ t%f \ t%d \ t%f \ n" , data [ 0 ] . c s t r ( ) , GraphPt->GetNodes ( ) , GraphPt->GetEdges ( ) , minDegree , avgDegree , maxDegree , d e n s i t y ) ;

916 917 918 919 920

f i l e o u t << output . CStr ( ) ; } } fileout . close () ; f i l e . close () ;

195

921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946

} e l s e i f ( a t o i ( i n p u t ) == 5 ) { p r i n t f ( "FB s e t (0 - 99) = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; s t d : : v e c t o r <s t d : : s t r i n g > r a n g e = s p l i t ( input , '- ' ) ; int s t a r t = a t o i ( r a n g e [ 0 ] . c s t r ( ) ) ; int end = a t o i ( r a n g e [ 1 ] . c s t r ( ) ) ; s t d : : i f s t r e a m f i l e ( " mgeop parameters . c s v " ) ; std : : s t r i n g l i n e i n p u t ;

// s t d : : o f s t r e a m f i l e o u t (" r e s u l t s . t x t ") ; std : : ofstream f i l e o u t d s d c 0 ( "0 d c d o m i n t a i n g r e s u l t s . txt " ) ; /  s t d : : o f s t r e a m f i l e o u t d s d c 1 ("1 d c d o m i n t a i n g r e s u l t s . t x t ") ; s t d : : o f s t r e a m f i l e o u t d s d c 2 ("2 d c d o m i n t a i n g r e s u l t s . t x t ") ; s t d : : o f s t r e a m f i l e o u t d s d c 3 ("3 d c d o m i n t a i n g r e s u l t s . t x t ") ; s t d : : o f s t r e a m f i l e o u t d s d c 4 ("4 d c d o m i n t a i n g r e s u l t s . t x t ") ; s t d : : o f s t r e a m f i l e o u t d s d c 5 ("5 d c d o m i n t a i n g r e s u l t s . t x t ") ;  / // s t d : : o f s t r e a m f i l e o u t d s r a i 0 ("0 r a i d o m i n t a i n g r e s u l t s . t x t ") ; /  s t d : : o f s t r e a m f i l e o u t d s r a i 1 ("1 r a i d o m i n t a i n g r e s u l t s . t x t ") ; s t d : : o f s t r e a m f i l e o u t d s r a i 2 ("2 r a i d o m i n t a i n g r e s u l t s . t x t ") ; s t d : : o f s t r e a m f i l e o u t d s r a i 3 ("3 r a i d o m i n t a i n g r e s u l t s . t x t ") ; s t d : : o f s t r e a m f i l e o u t d s r a i 4 ("4 r a i d o m i n t a i n g r e s u l t s . t x t ") ; s t d : : o f s t r e a m f i l e o u t d s r a i 5 ("5 r a i d o m i n t a i n g r e s u l t s . t x t ") ;  /

i f ( ! f i l e . good ( ) ) { p r i n t f ( " E r r o r o p e n i n g FB100 parameter f i l e ( mgeop parameters . c s v ) \ n. ") ;

947 948 949 950

} else { // p r i n t f (" D a t a s e t Name\ tNodes \ t E d g e s \ Min \ Avg \ Max \ D e n s i t y \ n ") ; g e t l i n e ( f i l e , l i n e i n p u t ) ; // read h e a d e r o f columns

196

951 952 953 954 955 956 957 958 959 960 961 962

f o r ( int i = 0 ; i < 1 0 0 ; i ++) { getline ( file , line input ) ; i f ( i < s t a r t ) continue ; i f ( i > end ) continue ; s t d : : v e c t o r <s t d : : s t r i n g > data = s p l i t ( l i n e i n p u t , ' , ' ) ; TStr f i l e n a m e = TStr : : Fmt( " p %s 0 . b i n " , data [ 0 ] . c s t r ( ) ) ; GraphPt = l o a d F i l e ( f i l e n a m e ) ;

TFlt e = ( double ) GraphPt->GetEdges ( ) ; TFlt v = ( double ) GraphPt->GetNodes ( ) ; TInt maxDegree = GetMaxDegNId ( GraphPt ) ; int avgDegree = ( int ) ( ( 2 . 0  ( double ) GraphPt->GetEdges ( ) / ( double ) GraphPt->GetNodes ( ) ) + 0 . 5 ) ;

963 964 965

TInt minDegree = GetMnDegNId ( GraphPt ) ; TFlt d e n s i t y = ( 2  e ) / ( v  ( v - 1 ) ) ; TStr output = TStr : : Fmt( "%s \ t%d \ t%d \ t%d \ t%d \ t%d \ t %.3 f \ n" , data [ 0 ] . c s t r ( ) , GraphPt->GetNodes ( ) , GraphPt->GetEdges ( ) , minDegree , avgDegree , maxDegree , d e n s i t y ) ;

966 967 968 969

// f i l e o u t << o u t p u t . CStr ( ) ;

TIntV d s d c = dominatingsetDC ( GraphPt ) ; TStr c o r e = TStr : : Fmt( "%d \ t%d \ n" , GraphPt->GetNodes ( ) , d s d c . Len () ) ;

970 971 972 973 974 975 976 977

f i l e o u t d s d c 0 << c o r e . CStr ( ) ;

} } fileout ds dc0 . close () ; f i l e . close () ;

197

978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999

} } e l s e i f ( menu option == "q" ) { return 1 ; } e l s e i f ( menu option == " c p u t h r e a d s " ) { p r i n t f (" threads = ") ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; threads = a t o i ( input ) ; omp set num threads ( threads ) ; } e l s e i f ( menu option == " cpu dynamic " ) { p r i n t f ( " threads dynamic = " ) ; s t d : : c i n . g e t l i n e ( input , 2 5 6 ) ; dynamic threads = a t o i ( input ) ; omp set dynamic ( d y n a m i c t h r e a d s ) ; } p r i n t f ( "> " ) ; } // end o f m e n u o p t i o n s stopMatlab ( ) ; } Catch { p r i n t f ( " \ nrun time : %s (%s ) \ n" , ExeTm . GetTmStr ( ) , TSecTm : : GetCurTm ( ) . GetTmStr ( ) . CStr ( ) ) ;

1000 1001 1002 1003 1004 1005 1006

}

p r i n t f ( " \ n P r e s s e n t e r t o e x i t . \ n" ) ; s t d : : s t r i n g nodepause ; s t d : : g e t l i n e ( s t d : : c i n , nodepause ) ; return 0 ; }

198

loadFunctions.h
1 2 3 4

#include " s t d a f x . h" #include < v e c t o r >

s t d : : v e c t o r <s t d : : s t r i n g > &s p l i t ( const s t d : : s t r i n g &, char , s t d : : v e c t o r <s t d : : s t r i n g > &) ;

5 6 7 8 9

s t d : : v e c t o r <s t d : : s t r i n g > s p l i t ( const s t d : : s t r i n g &, char ) ;

PUNGraph readTXT ( TStr ) ; PUNGraph readSMAT ( TStr ) ; PUNGraph l o a d F i l e ( TStr ) ;

loadFunctions.cpp
1 2 3 4 5 6 7

#include " s t d a f x . h" #include < f s t r e a m > #include < v e c t o r > #include < s t d i o . h> #include < sstream > // S p l i t s t r i n g f u n c t i o n s s t d : : v e c t o r <s t d : : s t r i n g > &s p l i t ( const s t d : : s t r i n g &s , char delim , s t d : : v e c t o r < s t d : : s t r i n g > &e l e m s ) {

8 9 10 11 12 13 14 15 16 17

std : : stringstream ss ( s ) ; s t d : : s t r i n g item ; while ( s t d : : g e t l i n e ( s s , item , d e l i m ) ) { e l e m s . push back ( item ) ; } return e l e m s ; } s t d : : v e c t o r <s t d : : s t r i n g > s p l i t ( const s t d : : s t r i n g &s , char d e l i m ) { s t d : : v e c t o r <s t d : : s t r i n g > e l e m s ; s p l i t ( s , delim , e l e m s ) ;

199

18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48

return e l e m s ; }

PUNGraph readTXT ( TStr f i l e n a m e ) { PUNGraph GraphPt = TUNGraph : : New ( ) ; int nodes1 , nodes2 ; s t d : : i f s t r e a m f i n ( f i l e n a m e . CStr ( ) ) ;

i f ( ! f i n . good ( ) ) { p r i n t f ( " E r r o r f i l e d o e s not e x i s t . \ n" ) ; return GraphPt ; } while ( ! f i n . e o f ( ) ) {

f i n >> nodes1 >> nodes2 ; i f ( ! GraphPt->IsNode ( nodes1 ) ) GraphPt->AddNode ( nodes1 ) ; i f ( ! GraphPt->IsNode ( nodes2 ) ) GraphPt->AddNode ( nodes2 ) ; GraphPt->AddEdge ( nodes2 , nodes1 ) ; } fin . close () ;

GraphPt->Def rag ( ) ; return GraphPt ; } PUNGraph readSMAT ( TStr f i l e n a m e ) { PUNGraph GraphPt = TUNGraph : : New ( ) ; int nodes1 , nodes2 , edgesA , e d g e s ; s t d : : i f s t r e a m f i n ( f i l e n a m e . CStr ( ) ) ;

i f ( ! f i n . good ( ) ) { p r i n t f ( " E r r o r f i l e d o e s not e x i s t . \ n" ) ; return GraphPt ;

200

49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72

}

f i n >> nodes1 >> nodes2 >> edgesA ;

f o r ( int i = 0 ; i < nodes1 ; i ++) { GraphPt->AddNode ( i ) ; } f o r ( int i = 0 ; i < edgesA ; i ++) { f i n >> nodes1 >> nodes2 >> e d g e s ; GraphPt->AddEdge ( nodes2 , nodes1 ) ; } fin . close () ;

GraphPt->Def rag ( ) ; return GraphPt ; }

PUNGraph l o a d F i l e ( TStr f i l e n a m e ) { PUNGraph GraphPt = TUNGraph : : New ( ) ;

p r i n t f ( " Loading f i l e : %s . . . " , f i l e n a m e . CStr ( ) ) ;

// l o a d b i n f o r f a s t e r l o a d i n g s t d : : v e c t o r <s t d : : s t r i n g > names = s p l i t ( s t d : : s t r i n g ( f i l e n a m e . CStr ( ) ) . c s t r ( ) , '. ');

73 74 75 76 77 78

s t d : : i f s t r e a m t e s t b i n ( names [ 0 ] + " . b i n " ) ; i f ( t e s t b i n . good ( ) ) { test bin . close () ; TStr f i l e n a m e = TStr : : Fmt( "%s . b i n " , names [ 0 ] . c s t r ( ) ) ; TFIn FIn ( f i l e n a m e ) ; GraphPt = TUNGraph : : Load ( FIn ) ;

201

79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105

GraphPt->Def rag ( ) ; p r i n t f ( " Completed . \ n" ) ; return GraphPt ; }

// c h e c k e x t e n s i o n i f ( f i l e n a m e . I s S t r I n ( TStr : : Fmt( " . smat " ) ) ) { // . smat f i l e GraphPt = readSMAT ( f i l e n a m e ) ; } e l s e i f ( f i l e n a m e . I s S t r I n ( TStr : : Fmt( " . t x t " ) ) ) { GraphPt = TSnap : : LoadEdgeList <PUNGraph>( f i l e n a m e , 0 , 1 ) ; } else { p r i n t f ( " Sorry , f i l e type (.% s ) not r e c o g n i z e d . \ n" , names [ 1 ] . c s t r ( ) ) ; } GraphPt->Def rag ( ) ; p r i n t f ( " Completed . \ n" ) ;

// c r e a t e BIN f i l e p r i n t f ( " \ n C r e a t i n g BIN f i l e f o r o p t i m i z a t i o n . . . " ) ; TStr f i l e n a m e = TStr : : Fmt( "%s . b i n " , names [ 0 ] . c s t r ( ) ) ; TFOut FOut ( f i l e n a m e ) ; GraphPt->Save ( FOut ) ; p r i n t f ( " Completed . \ n" ) ;

return GraphPt ; }

graphFunctions.h
1 2

#include " s t d a f x . h"

202

3 4 5 6

void T i m e r S t a r t (LARGE INTEGER  ) ; double TimerQuery (LARGE INTEGER  ) ; PUNGraph generateGNP ( const long , const double , TStr ) ; PUNGraph generateMGEOP ( const long , const long , const double , const double , const double , TStr ) ;

7

PUNGraph generateMGEOPDistance ( const long , const long , const double , const double , TStr ) ;

8 9 10

void GetHypercubeCoordinates ( const int &, TRnd &, TFltV &) ; double getMaxElement ( const TFltV &, const TFltV &, const TIntVV &, int , int ) ; double G e t I n f i n i t y D i s t a n c e ( const TFltV &, const TFltV &, const int , const TIntVV &) ;

11

TIntVV g e n e r a t e C o m b i n a t i o n s ( int , TIntV &) ;

graphFunctions.cpp
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17

#include " s t d a f x . h" #include < f s t r e a m > #include < v e c t o r > #include < s t d i o . h> #include < sstream > #include <omp . h>

LARGE INTEGER l i F r e q ;

// High P r e c i s i o n Event Timers . void T i m e r S t a r t (LARGE INTEGER  pSpec ) { QueryPerformanceCounter ( pSpec ) ; QueryPerformanceFrequency(& l i F r e q ) ; } double TimerQuery (LARGE INTEGER  pSpec ) { LARGE INTEGER l i ; QueryPerformanceCounter(& l i ) ;

203

18 19 20 21 22 23 24 25 26 27 28

return ( l i . QuadPart - pSpec ->QuadPart ) / ( double ) l i F r e q . QuadPart ; }

void GetHypercubeCoordinates ( const int& Dim , TRnd& Rnd , TFltV& ValV ) { i f ( ValV . Len ( ) != Dim) { ValV . Gen (Dim) ; } f o r ( int i = 0 ; i < Dim ; i ++) { ValV [ i ] = Rnd . GetUniDev ( ) ; } }

double getMaxElement ( const TFltV& u , const TFltV& v , const TIntVV& s e t s , int i i , int m) {

29 30 31 32 33 34 35 36 37 38

TFltV r e s u l t s ; r e s u l t s . Gen (m) ; f o r ( int i = 0 ; i < m; i ++) { r e s u l t s [ i ] = abs ( u [ i ] - v [ i ] - ( ( double ) s e t s . At ( i i , i ) ) ) ; } r e s u l t s . Sort () ; return ( double ) r e s u l t s . Last ( ) ; }

double G e t I n f i n i t y D i s t a n c e ( const TFltV& u , const TFltV& v , const int& dim , const TIntVV& s e t s ) {

39 40 41 42 43 44 45 46

TFltV r e s u l t ; int s i z e = ( int ) pow ( 3 , dim ) ; r e s u l t . Gen ( s i z e ) ; f o r ( int i = 0 ; i < s i z e ; i ++) { r e s u l t [ i ] = getMaxElement ( u , v , s e t s , i , dim ) ; } r e s u l t . Sort ( false ) ; return ( double ) r e s u l t . Last ( ) ;

204

47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77

}

TIntVV g e n e r a t e C o m b i n a t i o n s ( int a r r a y S i z e , TIntV& p o s s i b l e V a l u e s ) { int c a r r y ; TIntV i n d i c e s ( a r r a y S i z e ) ; int comb = ( int ) pow ( 3 , a r r a y S i z e ) ; TIntVV s e t s ( comb , a r r a y S i z e ) ; int count = 0 ; int b = 0 ;

f o r ( int q = 0 ; q < a r r a y S i z e ; q++) { indices [ q ] = 0; }

do { f o r ( int i = 0 ; i < a r r a y S i z e ; i ++) { s e t s . PutXY( count , b , p o s s i b l e V a l u e s [ i n d i c e s [ i ] ] ) ; b++; }

b = 0; count++;

carry = 1; f o r ( int i = a r r a y S i z e - 1 ; i >= 0 ; i --) { i f ( c a r r y == 0 ) break ;

i n d i c e s [ i ] += c a r r y ; carry = 0;

205

78 79 80 81 82 83 84

i f ( i n d i c e s [ i ] == 3 ) { carry = 1; indices [ i ] = 0; } } } while ( c a r r y != 1 ) ; // C a l l t h i s method i t e r a t i v e l y u n t i l a c a r r y i s l e f t over ;

85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107

return s e t s ; }

PUNGraph generateGNP ( const long n , const double p , TStr f i l e n a m e ) { PUNGraph GraphPt = TUNGraph : : New ( ) ; int c o u n t e r = 1 ; f o r ( long i = 0 ; i < n ; i ++) { GraphPt->AddNode ( i ) ; }

LARGE INTEGER s t a r t ; T i m e r S t a r t (& s t a r t ) ; # pragma omp p a r a l l e l f o r s c h e d u l e ( dynamic ) s h a r e d ( GraphPt ) f o r ( long a = 0 ; a < n ; a++) { f o r ( long b = 0 ; b < n ; b++) { i f ( b <= a ) continue ; i f ( TFlt : : Rnd . GetUniDev ( ) <= p ) { # pragma omp c r i t i c a l GraphPt->AddEdge ( a , b ) ; } } Try {

206

108 109 110 111 112

double n P e r c e n t a g e = ( double ) c o u n t e r / ( double ) n ; // Ranges from 0-1 double nElapsed = TimerQuery(& s t a r t ) ; // In s e c o n d s double nTotalTime = ( 1 . 0 / n P e r c e n t a g e )  nElapsed ; double nRemaining = nTotalTime - nElapsed ; p r i n t f ( " %2.1 f%% complete , Estimated %f s e c o n d s r e m a i n i n g \ r " , ( n P e r c e n t a g e  1 0 0 . 0 ) , nRemaining ) ;

113 114 115 116 117 118 119 120 121 122 123 124

counter = counter + 1; } Catch {} // n o t h i n g } GraphPt->Def rag ( ) ; TFOut FOut ( f i l e n a m e ) ; GraphPt->Save ( FOut ) ; return GraphPt ; }

PUNGraph generateMGEOP ( const long n , const long m, const double alpha , const double beta , const double p , TStr f i l e n a m e ) {

125 126 127 128 129 130 131 132 133 134 135 136

PUNGraph GraphPt = TUNGraph : : New ( ) ; TFltV ValRadius ; TFltV ValV ; p r i n t f ( " C r e a t i n g graph : \ n A l l o c a t i n g nodes . . . \ n" ) ; ValRadius . Gen ( n ) ; TVec<TFltV> c o o r d ;

f o r ( long i = 0 ; i < n ; i ++) { GetHypercubeCoordinates (m, TFlt : : Rnd , ValV ) ;

/  For THESIS Sample i f ( i == 0) {

207

137 138 139 140 141 142 143 144 145 146 147 148 149

ValV . Gen ( 2 ) ; ValV [ 0 ] = 0 . 1 8 9 4 ; ValV [ 1 ] = 0 . 1 2 8 4 ; } e l s e i f ( i == 1) { ValV . Gen ( 2 ) ; ValV [ 0 ] = 0 . 7 4 3 9 ; ValV [ 1 ] = 0 . 7 2 3 2 ; } e l s e i f ( i == 2) { ValV . Gen ( 2 ) ; ValV [ 0 ] = 0 . 4 2 0 0 ; ValV [ 1 ] = 0 . 9 2 1 3 ; } / c o o r d . Add( ValV ) ; ValRadius [ i ] = 0 . 5  TMath : : Power (TMath : : Power ( ( double ) ( i + 1 ) , - 1.0  a l p h a )  TMath : : Power ( ( double ) n , - 1.0  b e t a ) , 1 . 0 / m) ;

150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166

GraphPt->AddNode ( i ) ; }

p r i n t f ( " Nodes g e n e r a t e d . \ n" ) ; TIntV i t m s ; i t m s . Add( - 1) ; i t m s . Add ( 0 ) ; i t m s . Add ( 1 ) ; TIntVV s e t s = g e n e r a t e C o m b i n a t i o n s (m, i t m s ) ;

LARGE INTEGER s t a r t ; T i m e r S t a r t (& s t a r t ) ; // c r e a t e e d g e s int c o u n t e r = 1 ; # pragma omp p a r a l l e l s h a r e d ( c o u n t e r , n , coord , m, s e t s , ValRadius , s t a r t ) { long x = 0 ; # pragma omp f o r s c h e d u l e ( s t a t i c , n / 2 0 ) f o r ( x = 0 ; x < n ; x++) { f o r ( long y = 0 ; y < n ; y++) {

208

167 168 169

i f ( y <= x ) continue ; i f ( TFlt : : Rnd . GetUniDev ( ) <= p ) { i f ( G e t I n f i n i t y D i s t a n c e ( c o o r d [ x ] , c o o r d [ y ] , m, s e t s ) <= ValRadius [ x ]) {

170 171 172 173 174 175 176 177 178 179 180

# pragma omp c r i t i c a l GraphPt->AddEdge ( x , y ) ; } } } Try { double n P e r c e n t a g e = ( double ) c o u n t e r / ( double ) n ; // Ranges from 0-1 double nElapsed = TimerQuery(& s t a r t ) ; // In s e c o n d s double nTotalTime = ( 1 . 0 / n P e r c e n t a g e )  nElapsed ; double nRemaining = nTotalTime - nElapsed ; p r i n t f ( "%d Nodes l e f t . Estimated %f s e c o n d s r e m a i n i n g \ r " , ( int ) ( n- c o u n t e r ) , nRemaining ) ;

181 182 183 184 185 186 187 188 189 190 191 192

counter = counter + 1; } Catch { // n o t h i n g } } }

GraphPt->Def rag ( ) ; TFOut FOut ( f i l e n a m e ) ; GraphPt->Save ( FOut ) ; p r i n t f ( "Graph c o m p l e t e (%d , %d ) - %s \ n" , GraphPt->GetNodes ( ) , GraphPt-> GetEdges ( ) , f i l e n a m e ) ;

193 194

return GraphPt ; }

209

195 196

PUNGraph generateMGEOPDistance ( const long n , const long m, const double alpha , const double beta , TStr f i l e n a m e ) {

197 198 199 200 201 202 203 204 205

PUNGraph GraphPt = TUNGraph : : New ( ) ; TFltV ValRadius ; TFltV ValV ; TVec<TFltV> c o o r d ;

p r i n t f ( " C r e a t i n g graph : \ n A l l o c a t i n g nodes . . . \ n" ) ; ValRadius . Gen ( n ) ;

// Generate random m - c o o r d i n a t e s , r a d i u s f o r a l l nodes ( rank i s nodes id , since arbitrary )

206 207 208 209

f o r ( long i = 0 ; i < n ; i ++) { GetHypercubeCoordinates (m, TFlt : : Rnd , ValV ) ; c o o r d . Add( ValV ) ; ValRadius [ i ] = 0 . 5  TMath : : Power (TMath : : Power ( ( double ) ( i + 1 ) , - 1.0  a l p h a )  TMath : : Power ( ( double ) n , - 1.0  b e t a ) , 1 . 0 / m) ;

210 211 212 213 214 215 216 217 218 219 220 221 222

GraphPt->AddNode ( i ) ; }

p r i n t f ( " Nodes g e n e r a t e d . \ n" ) ; TIntV i t m s ; i t m s . Add( - 1) ; i t m s . Add ( 0 ) ; i t m s . Add ( 1 ) ; TIntVV s e t s = g e n e r a t e C o m b i n a t i o n s (m, i t m s ) ;

LARGE INTEGER s t a r t ; T i m e r S t a r t (& s t a r t ) ; // c r e a t e e d g e s int c o u n t e r = 1 ;

# pragma omp p a r a l l e l s h a r e d ( c o u n t e r , n , coord , m, s e t s , ValRadius , s t a r t )

210

223 224 225 226 227 228 229

{ long x = 0 ; # pragma omp f o r s c h e d u l e ( dynamic ) f o r ( x = 0 ; x < n ; x++) { f o r ( long y = 0 ; y < n ; y++) { i f ( y <= x ) continue ; i f ( G e t I n f i n i t y D i s t a n c e ( c o o r d [ x ] , c o o r d [ y ] , m, s e t s ) <= ValRadius [ x ] ) {

230

i f ( TFlt : : Rnd . GetUniDev ( ) <= ( 1 - ( G e t I n f i n i t y D i s t a n c e ( c o o r d [ x ] , c o o r d [ y ] , m, s e t s ) / ValRadius [ x ] ) ) ) {

231 232 233 234 235 236 237 238 239 240 241 242

# pragma omp c r i t i c a l GraphPt->AddEdge ( x , y ) ; }

} } Try { double n P e r c e n t a g e = ( double ) c o u n t e r / ( double ) n ; // Ranges from 0-1 double nElapsed = TimerQuery(& s t a r t ) ; // In s e c o n d s double nTotalTime = ( 1 . 0 / n P e r c e n t a g e )  nElapsed ; double nRemaining = nTotalTime - nElapsed ; p r i n t f ( " %2.1 f%% complete , Estimated %f s e c o n d s r e m a i n i n g \ r " , ( n P e r c e n t a g e  1 0 0 . 0 ) , nRemaining ) ;

243 244 245 246 247 248 249 250

counter = counter + 1; } Catch { // n o t h i n g } } }

p r i n t f ( " \ nend e d g e s \ n" ) ;

211

251 252 253 254 255 256

GraphPt->Def rag ( ) ; TFOut FOut ( f i l e n a m e ) ; GraphPt->Save ( FOut ) ; return GraphPt ;

}

matlabFunctions.h
1 2 3 4 5 6 7 8 9

#include " s t d a f x . h"

void s t a r t M a t l a b ( ) ; void g e t H i s t o g r a m ( const PUNGraph &) ; void printMatlabOutput ( ) ; TFltPr bestPowerLawLocation ( const PUNGraph &) ; void g e t L o g L o g P l o t B e s t f i t ( const PUNGraph &) ; void getLogLogPlot ( const PUNGraph &) ; void stopMatlab ( ) ;

matlabFunctions.cpp
1 2 3 4 5 6 7 8 9 10 11 12

#include " s t d a f x . h" #include < f s t r e a m > #include < v e c t o r > #include < s t d i o . h> #include < sstream > #include " e n g i n e . h"

// G l o b a l V a r i a b l e s Engine  ep ; char  b u f f ; int n b u f f = 4 0 9 6 ;

212

13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28

// S t a r t MATLAB Engine void s t a r t M a t l a b ( ) { i f ( ! ( ep = engOpen (NULL) ) ) { MessageBox ( (HWND)NULL, (LPSTR) "Can ' t s t a r t MATLAB e n g i n e " , (LPSTR) "Engwindemo . c " , MB OK) ; e x i t ( - 1) ; } i f ( ( b u f f = ( char  ) m a l l o c ( n b u f f ) ) == NULL) p r i n t f ( " Unable t o a l l o c a t e output b u f f e r \ n" ) ; engOutputBuffer ( ep , b u f f , n b u f f ) ; }

// Histogram void g e t H i s t o g r a m ( const PUNGraph &Graph ) { std : : s t r i n g evalaa ( " f i g u r e ; histogram ( [ " ) ; f o r (PUNGraph : : TObj : : TNodeI NI = Graph->BegNI ( ) ; NI < Graph->EndNI ( ) ; NI++) {

29 30 31 32 33 34 35 36 37 38 39 40 41 42

e v a l a a += s t d : : t o s t r i n g ( NI . GetDeg ( ) ) + " " ; } e v a l a a += " ] ) " ; e n g E v a l S t r i n g ( ep , e v a l a a . c s t r ( ) ) ;

}

void printMatlabOutput ( ) { i f ( b u f f != NULL) printf ( buff ) ; }

TFltPr bestPowerLawLocation ( const PUNGraph &Graph ) { // x - d e g r e e s | y - number o f v e r t i c e s

213

43 44

TVec<TIntPr > degreeCount ; f o r (PUNGraph : : TObj : : TNodeI NI = Graph->BegNI ( ) ; NI < Graph->EndNI ( ) ; NI++) {

45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72

bool e x i s t = f a l s e ; f o r ( int tmp = 0 ; tmp < degreeCount . Len ( ) ; tmp++) { i f ( degreeCount [ tmp ] . Val1 == NI . GetDeg ( ) ) { degreeCount [ tmp ] . Val2++; e x i s t = true ; } } if (! exist ) { degreeCount . Add( TIntPr ( NI . GetDeg ( ) , 1 ) ) ; } }

int n = degreeCount . Len ( ) ; double b max = 0 ; double s max = 0 ; double e max = n ; f o r ( double i n c r e = 0 ; i n c r e < 0 . 5 ; i n c r e = i n c r e + 0 . 0 0 1 ) { double sum = 0 . 0 ; double sum2 = 0 . 0 ; double sum3 = 0 . 0 ; double sum4 = 0 . 0 ;

double s = i n c r e  n ; double e = n ; f o r ( int tmp = int ( s ) ; tmp < int ( e ) ; tmp++) { int x = degreeCount [ tmp ] . Val1 ; int y = degreeCount [ tmp ] . Val2 ;

214

73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103

sum += TMath : : Log ( x )  TMath : : Log ( y ) ; sum2 += TMath : : Log ( x ) ; sum3 += TMath : : Log ( y ) ; sum4 += TMath : : Log ( x )  TMath : : Log ( x ) ; } int n2 = int ( e ) - int ( s ) ; i f ( n2 < 0 . 1  n ) continue ; double b = ( ( n2  sum ) - ( sum2  sum3 ) ) / ( ( n2  sum4 ) - ( sum2  sum2 ) ) ; i f ( b max > b ) { b max = b ; s max = s ; } }

f o r ( double i n c r e = 0 ; i n c r e < 0 . 5 ; i n c r e = i n c r e + 0 . 0 0 1 ) { double sum = 0 . 0 ; double sum2 = 0 . 0 ; double sum3 = 0 . 0 ; double sum4 = 0 . 0 ;

double s = s max ; double e = ( 1 - i n c r e )  n ; f o r ( int tmp = int ( s ) ; tmp < int ( e ) ; tmp++) { int x = degreeCount [ tmp ] . Val1 ; int y = degreeCount [ tmp ] . Val2 ; sum += TMath : : Log ( x )  TMath : : Log ( y ) ; sum2 += TMath : : Log ( x ) ; sum3 += TMath : : Log ( y ) ; sum4 += TMath : : Log ( x )  TMath : : Log ( x ) ; } int n2 = int ( e ) - int ( s ) ; i f ( n2 < 0 . 1  n ) continue ; double b = ( ( n2  sum ) - ( sum2  sum3 ) ) / ( ( n2  sum4 ) - ( sum2  sum2 ) ) ;

215

104 105 106 107 108 109 110 111 112 113 114 115 116 117

i f ( b max > b ) { b max = b ; e max = e ; } }

return TFltPr ( s max , e max ) ;

} // LogLog P l o t w i t h Line o f Best - f i t void g e t L o g L o g P l o t B e s t f i t ( const PUNGraph &Graph ) { char  command = " " ; TVec<TIntPr > degreeCount ; f o r (PUNGraph : : TObj : : TNodeI NI = Graph->BegNI ( ) ; NI < Graph->EndNI ( ) ; NI++) {

118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133

bool e x i s t = f a l s e ; f o r ( int tmp = 0 ; tmp < degreeCount . Len ( ) ; tmp++) { i f ( degreeCount [ tmp ] . Val1 == NI . GetDeg ( ) ) { degreeCount [ tmp ] . Val2++; e x i s t = true ; } } if (! exist ) { degreeCount . Add( TIntPr ( NI . GetDeg ( ) , 1 ) ) ; } }

s t d : : s t r i n g cmd( "x = [ " ) ; s t d : : s t r i n g cmd2 ( " y = [ " ) ;

TFltPr r a n g e = bestPowerLawLocation ( Graph ) ;

216

134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150

f o r ( int tmp = int ( r a n g e . Val1 ) ; tmp < int ( r a n g e . Val2 ) ; tmp++) { cmd += s t d : : t o s t r i n g ( degreeCount [ tmp ] . Val2 ) + " " ; cmd2 += s t d : : t o s t r i n g ( degreeCount [ tmp ] . Val1 ) + " " ; }

cmd += " ] ; " ; cmd2 += " ] ; " ; cmd += cmd2 ; cmd += " [ x , i n d e x ] = s o r t ( x ) ; y = y ( i n d e x ) ; y2 = x ; x = y ; y = y2 ; " ; cmd += " f i g u r e ; h o l d on ; " ; cmd += " l o g l o g ( x , y , '. ') ;";

cmd += "p = p o l y f i t ( l o g ( x ) , l o g ( y ) , 1 ) ; " ; cmd += " y h a t = exp ( p ( 1 )  l o g ( x ) + p ( 2 ) ) ; " ; cmd += " l o g l o g ( x , y h a t ) ; " ; cmd += " l a b e l = [ ' l o g ( y ) = ' num2str ( p ( 1 ) ) ' l o g ( x ) + ' num2str ( p ( 2 ) ) ] ; " ; cmd += " l e g e n d ( ' data ' , l a b e l ) ; s e t ( gca , ' x s c a l e ' , ' l o g ' ) ; s e t ( gca , ' y s c a l e ' , ' l o g ' ) ;";

151 152 153 154 155 156 157 158 159 160

e n g E v a l S t r i n g ( ep , cmd . c s t r ( ) ) ; printMatlabOutput ( ) ; }

// LogLog P l o t void getLogLogPlot ( const PUNGraph &Graph ) { std : : s t r i n g evalaa ( " f i g u r e ; l oglog ( [ " ) ; f o r (PUNGraph : : TObj : : TNodeI NI = Graph->BegNI ( ) ; NI < Graph->EndNI ( ) ; NI++) {

161 162

e v a l a a += s t d : : t o s t r i n g ( NI . GetDeg ( ) ) + " " ; }

217

163 164 165 166 167 168 169 170 171 172

e v a l a a += " ] ) ; g r i d ; " ; e n g E v a l S t r i n g ( ep , e v a l a a . c s t r ( ) ) ; }

// Stop MATLAB Engine void stopMatlab ( ) { e n g C l o s e ( ep ) ; delete [ ] b u f f ; }

218

Bibliography
[1] L.A. Adamic, O. Buyukkokten, E. Adar, A social network caught in the web, First Monday 8 (2003). [2] Y. Ahn, S. Han, H. Kwak, S. Moon, H. Jeong, Analysis of topological characteristics of huge on-line social networking services, In: Proceedings of the 16th International Conference on World Wide Web, 2007. [3] N. Alon, J. Spencer, The Probabilistic Method, Wiley, New York, 2000. [4] L. Backstorm, P. Boldi, M. Rosa, J. Ugander, S. Vigna, Four degrees of separation, In: Proceedings of the 4th Annual ACM Web Science Conference, 2012. [5] A.L. Barab´ asi, R. Albert, Emergence of scaling in random networks, Science 286 (1999) 509-512. [6] P. M. Blau, Population structure and exchange process, Ethik Und Sozialwissenschaften 6 (1995) 20-22. [7] B. Bollob´ as, O. Riordan, J. Spencer, G. Tusn´ ady, The degree sequence of a scale-free random graph process, Random Structures and Algorithms 18 (2001) 279-290. [8] A. Bonato, A Course on the Web Graph, American Mathematical Society, Providence, Rhode Island, 2008. [9] A. Bonato, D.F. Gleich, M. Kim, D. Mitsche, P. Pralat, A. Tian, S.J. Young, Dimensionality matching of social networks using motifs and eigenvalues, PLOS ONE 9 (2014) e106052. [10] A. Bonato, N. Hadi, P. Horn, P. Pralat, C. Wang, Models of On-Line Social Networks, Internet Mathematics 6 (2011) 285-313. [11] A. Bonato, J. Janssen, P. Pralat, Geometric protean graphs, Internet Mathematics 8 (2012) 2­28. [12] A. Bonato, M. Lozier, D. Mitsche, X. P´ erez-Gim´ enez, P. Pralat, The domination number of on-line social networks and random geometric graphs, In: Proceedings of the 12th Conference on Theory and Applications of Models of Computation (TAMC'15), 2015. [13] T.F. Coleman, J.J. Mor´ e, Estimation of sparse Jacobian matrices and graph coloring problems, SIAM Journal on Numerical Analysis 20 (1983) 187-209. [14] B. Corominas-Murtra, B. Fuches, S. Thurner, Detection of the elite structure in a virtual multiplex social system by means of a generalized K-core, Preprint 2015.

219

[15] N.J. Cowan, E.J. Chastain, D.A. Vilhena, J.S. Freudenberg, C.T. Bergstrom, Nodal dynamics, not degree distributions, determine the structural controllability of complex networks, PLOS ONE 7 (2012) e38398. [16] D. Crandall, D. Cosley, D. Huttenlocher, J. Kleinberg, S. Suri, Feedback effects between similarity and social influence in on-line communities, In: Proceedings of the 14th ACM SIGKDD Intl. Conf. on Knowledge Discovery and Data Mining, 2008. [17] P. Erd os, A. R´ enyi, On random graphs I, Publicationes Mathematicae Debrecen 6 (1959) 290-297. [18] E. Estrada, Spectral scaling and good expansion properties in complex networks, Europhysics Letters 73 (2006), 649­655. [19] M.R. Garey, D.S. Johnson, Computers and intractability: a guide to theory of NP-completeness, W.H. Freeman & Company, New York, 1979. [20] S. Golder, D. Wilkinson, B. Huberman, Rhythms of social interaction: messaging within a massive on-line network, In: Proceedings of 3rd International Conference on Communities and Technologies, 2007. [21] G.R. Grimmett, D.R. Stirzaker, Probability and Random Processes, Oxford University Press, 2001. [22] S. Janson, T. Luczak, A. Rucinski, Random Graphs, Wiley-Interscience Series in Discrete Mathematics and Optimization, 2000. [23] A. Java, X. Song, T. Finin, B. Tseng, Why we twitter: understanding microblogging usage and communities, In: Proceedings of the Joint 9th WEBKDD and 1st SNA-KDD Workshop 2007, 2007. [24] A.D.I. Kramer, J.E. Guillory, J.T. Hancock, Experimental evidence of massive-scale emotional contagion through social networks, In: Proceedings of the National Academy of Sciences, 2014. [25] R. Kumar, J. Novak, A. Tomkins, Structure and evolution of on-line social networks, In: In Proceedings of the 12th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2006. [26] H. Kwak, C. Lee, H. Park, S. Moon, What is twitter, a social network or a news media?, In: Proceedings of the 19th International World Wide Web Conference, 2010. [27] J. Leskovec, D. Chakrabarti, J. Kleinberg, C. Faloutsos, Realistic, mathematically tractable graph generation and evolution, using Kronecker multiplication, In: Proceedings of European Conference on Principles and Practice of Knowledge Discovery in Databases, 2005. [28] J. Leskovec, J. Kleinberg, C. Faloutsos, Graphs over time: densification laws, shrinking diameters and possible explanations, In: Proceedings of the 13th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2005.

220

[29] S. Lattanzi, D. Sivakumar, Affiliation Networks, In: In Proceedings of the 41st Annual ACM Symposium on Theory of Computing, 2009. [30] M. McPherson, A Blau space primer: prolegomenon to an ecology of affiliation, In: Industrial and Corporate Change, Oxford University Press, 2004. [31] J.M. McPherson, J.R. Ranger-Moore, Evolution on a dancing landscape: organizations and networks in dynamic Blau space, Social Forces (1991) 70 19-42. [32] M. McPherson, L. Smith-John, J.M. Cook, Birds of a feather: Homophily in social networks, Annual Review of Sociology 27 (2001) 415-444. [33] T. Milenkovi´ c, V. Memi sevi´ c, A. Bonato, N. Pr zulj, Dominating biological networks, PLOS ONE 6 (2013) (8), e23016. [34] S. Milgram, The small world problem, Psychology Today 2 (1967) 60-67. [35] A. Mislove, M. Marcon, K. Gummadi, P. Druschel, B. Bhattacharjee, Measurement and analysis of on-line social networks, In: Proceedings of the 7th ACM SIGCOMM Conference on Internet Measurement, 2007. [36] M.E.J. Newman, J. Park, Why social networks are different from other types of networks, Physical Review E 68(3) 036122 (2003). [37] Ø. Ore, Theory of Graphs, American Mathematical Society Colloquium Publications, Providence, Rhode Island, 1962. [38] V. Pareto, Cours d'Economie Politique, Geneva: Droz, 1896. [39] M. Rai, S. Verma, S. Tapaswi, A power aware minimum connected dominating set for wireless sensor networks, Journal of networks 4 (2009) 511-519. [40] I. Stojmenovic, M. Seddigh, J. Zunic, Dominating sets and neighbor elimination-based broadcasting algorithms in wireless networks, IEEE Transactions on Parallel and Distributed Systems 13 (2002) 14-25. [41] A.L. Traud, P.J. Mucha, M.A. Porter, Social structure of Facebook networks, Physica A: Statistical Mechanics and its Applications 391 (2012) 4165-4180. [42] J.M.M. van Rooij, J. Nederlof, T.C. van Dijk, Inclusion/Exclusion Meets Measure and Conquer, Algorithms - ESA 2009 5757 (2009) 554-565. [43] B. Viswanath, A. Mislove, M. Cha, K.P. Gummadi, On the evolution of user interaction in Facebook, In: Proceedings of the 2nd ACM SIGCOMM Workshop on Social Networks (WOSN'09), 2009. [44] D.J. Watts, S. H. , CollectiStrogatzve dynamics of `small-world' networks, Nature 393 (1998) 440­442. [45] J. Wu, M. Cardei, F. Dai, S. Yang, Extended Dominating Set and its Applications in Ad-Hoc Networks using Cooperative Communication, In: IEEE Transactions on Parallel and Distributed Systems, 2006.

221

